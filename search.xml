<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Docker部署Python项目]]></title>
    <url>%2Fdocker-deploy-python%2F</url>
    <content type="text"><![CDATA[使用 Docker 部署 Python 项目 前提准备首先生成项目依赖文件 1pip freeze &gt; requirements.txt 此时会在项目目录下生成 requirements.txt 文件 创建 Dockerfile 文件 12345678910# 基于镜像基础FROM python:3.7# 设置代码文件夹工作目录 /appWORKDIR /app# 复制当前代码文件到容器中 /appADD . /app# 安装所需的包RUN pip install -i http://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.com -r requirements.txt# Run app.py when the container launchesCMD ["python", "main.py"] 比如我们的项目入口文件是 main.py 命令行对应配置即可 个人习惯使用 docker-compose 启动 , 创建 docker-compose.yml 文件 1234567version: '3'services: pes-spider: build: . restart: always volumes: - /etc/localtime:/etc/localtime:ro 以上具体配置可参考往期文章 Dockerfile详解 上传文件将项目 py 文件 、以上2个 docker 文件 ,依赖文件 requirements.txt 上传到服务器同一目录 构建&amp;运行1234# 首次构建docker-compose up -d# 若更新了py文件需要重新构建镜像及容器docker-compose up -d --build 参考链接 Docker下部署python项目 Docker如何部署Python项目]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python项目自动生成requirements.txt文件]]></title>
    <url>%2Fpython-requirements%2F</url>
    <content type="text"><![CDATA[通过设置 requirements.txt 来快速安装依赖库. 生成文件1pip freeze &gt; requirements.txt 此时会在项目目录下生成 requirements.txt 文件 安装依赖文件格式 12requests==1.2.0 Flask==0.10.1 通过命令安装依赖 1pip install -r requirements.txt 使用镜像往往很多库下载起来会很慢 , 我们需要使用国内镜像仓库. 常用镜像 清华：https://pypi.tuna.tsinghua.edu.cn/simple 阿里云：http://mirrors.aliyun.com/pypi/simple/ 中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ 华中理工大学：http://pypi.hustunique.com/ 山东理工大学：http://pypi.sdutlinux.org/ 豆瓣：http://pypi.douban.com/simple/ 指定镜像仓库安装 requirements.txt 依赖 1pip install -i http://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.com -r requirements.txt 参考链接 python 项目自动生成requirements.txt文件 Python用国内镜像下载REQUIREMENTS.TXT中的所有包]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转-Python问题浅谈]]></title>
    <url>%2Fpython-import%2F</url>
    <content type="text"><![CDATA[本文转自 知乎 模块导入原理 ModuleNotFoundError 绝对路径 导入相对 路径导入 添加路径到sys.path 参考 最近遇到一个python import的问题，经过是这样的： 我先实现好一个功能模块，这个功能模块有多级目录和很多 .py 文件，然后把该功能模块放到其他目录下作为子模块，运行代码时，就报错ModuleNotFoundError。 为了解决这个问题，就把 python 的 import 部分给研究了一下（本文不介绍import的语法）。 模块导入原理一个module(模块)就是一个.py文件，一个package(包)就是一个包含.py文件的文件夹（对于python2，该文件夹下还需要__init__.py）。 我这里只考虑python3的情况。 在python脚本被执行，python导入其他包或模块时，python会根据sys.path列表里的路径寻找这些包或模块。如果没找到的话，程序就会报错ModuleNotFoundError。 既然要根据sys.path列表里的路径找到这些需要导入包或模块，就需要知道这个列表里都是些什么东西。 先看下如下程序： 1234$ /usr/bin/python3.5&gt;&gt;&gt; import sys&gt;&gt;&gt; print(sys.path)[&apos;&apos;, &apos;/usr/lib/python35.zip&apos;, &apos;/usr/lib/python3.5&apos;, &apos;/usr/lib/python3.5/plat-x86_64-linux-gnu&apos;, &apos;/usr/lib/python3.5/lib-dynload&apos;, &apos;/home/username/.local/lib/python3.5/site-packages&apos;, &apos;/usr/local/lib/python3.5/dist-packages&apos;, &apos;/usr/lib/python3/dist-packages&apos;] sys.path列表中的每个元素为一个搜索模块的路径，程序中要导入包或模块就需要在这些路径中进行查找，主要分为三种情况： 当前执行脚本（主动执行，而不是被其他模块调用）所在路径。上面例子是在交互界面进行操作，没有执行脚本，所以为空字符串。 python内置的标准库路径，PYTHONPATH。 安装的第三方模块路径。 在运行程序时，先在第一个路径下查找所需模块，没找到就到第二个路径下找，以此类推，按顺序在所有路径都查找后依然没找到所需模块，则抛出错误。列表的第一项是调用python解释器的脚本所在的目录，所以默认先在脚本所在路径下寻找模块。 所以从这里可以知道的是，如果我们在脚本所在路径下定义和python标准库同名的模块，那么程序就会调用我们自定义的该模块而不是标准库中的模块。 ModuleNotFoundError知道了调用模块的流程，现在来分析一下文章最开始提到的那个错误。 假设功能模块的目录树为： 1234567891011121314package_0├── module_0.py├── module_1.py├── package_1│ ├── __init__.py│ ├── module_2.py│ ├── module_3.py│ └── package_2│ ├── __init__.py│ ├── module_21.py│ └── module_22.py└── package_3 ├── __init__.py └── module_4.py 要构建一个package，则对应文件夹下需要包含__init.py文件（python2版本）。 执行命令为 python module_0.py，即通过 module_0.py 来调用python解释器，则该脚本文件所在的路径（’/home/…/package_0’）会被添加到 sys.path 中，可以通过该路径找到其他模块的，比如下面这些语句： 1234# module_0.pyimport module_1from package_1 import module_2from package_1.package_2 import module_21 而在 module_2.py 中加入下面这句： 12# module_2.pyimport module_3 分为下面两种情况： 执行 python module_2.py 时，不会出现错误。 执行 python module_0.py 时，出现错误：ModuleNotFoundError: No module named &#39;module_3&#39;。 第一种情况把路径（’/home/…/package_0/package_1’）添加到 sys.path 中，可以通过package_1 找到 module_3。 第二种情况把路径（’/home/…/package_0’）添加到 sys.path 中，该路径下就不能在 module_2.py 中通过这种方式找到module_3，因为module_2.py 在路径/home/.../package_0/package_1下。 绝对路径导入在上面第二种情况中想调用module_3的话，可以使用绝对路径导入的方式： 12# module_2.pyfrom package_1 import module_3 即在路径/home/.../package_0/package_1下先找到package_1，再找到module_3。 同理，想在module_21.py中调用module_22，可以使用如下方式： 12# module_21.pyfrom package_1.package_2 import module_21 绝对导入根据从项目根文件夹开始的完整路径导入各个模块。 使用绝对路径的方式就可以解决这个问题，但是如果package_0这个文件夹要放到其他项目中，则这个文件夹下的所有相关导入都要修改，即在绝对导入的基础上再加一层。 而且如果文件夹层级太多，调用一个模块就需要写很长一串，显得很冗余。想要简单一些的话，可以考虑相对路径导入。 相对路径导入相对导入的形式取决于当前位置以及要导入的模块、包或对象的位置。相对导入看起来就比绝对导入简洁一些。 相对导入使用点符号来指定位置。 单点表示引用的模块或包与当前模块在同一目录中（同一个包中）。 两点表示在当前模块所在位置的父目录中。 还是执行命令为 python module_0.py，想在 module_2.py 中导入其他模块，可以使用如下方法： 123# module_2.pyfrom . import module_3from .package_2 import module_21 第一行表示调用和module_2 在同一路径的module_3 模块。 第二行表示调用和module_2 在同一路径的package_2 包下的module_21 模块。 还有两种用法： from .. import module_name：导入本模块上一级目录的模块。 from ..package_name import module_name。导入本模块上一级目录下的包中的模块。 不过相对导入要注意两个地方（仍然执行命令为 python module_0.py）： 第一个： 在 module_21 中导入 module_2：from .. import module_2 在 module_2 中导入 module_4：from ..package_3 import module_4 理论上这两句都没错，但是第二句会报如下错误： 1ValueError: attempted relative import beyond top-level package 这个报错的意思是：试图在顶级包（top-level package）之外进行相对导入。也就是说相对导入只适用于顶级包之内的模块。 如果将 module_0.py 当作执行模块，则和该模块同级的 package_1 和 package_3 就是顶级包（top-level package），而 module_2 在package_1中，module_0、module_1和module_4都在 package_1之外，所以调用这三个模块时，就会报这个错误。 第二个： 还有个注意点就是使用了相对导入的模块文件不能作为顶层执行文件，即不能通过 python 命令执行，比如执行python module_0.py，在 module_0 中添加如下语句： 12# module_0.pyfrom .package_1 import module_2 报错如下： 1ModuleNotFoundError: No module named &apos;__main__.package_1&apos;; &apos;__main__&apos; is not a package python 的相对导入会通过模块的 __name__ 属性来判断该模块的位置，当模块作为顶层文件被执行时，其 __name__ 这个值为 __main__，不包含任何包的名字，而当这个模块被别的模块调用时，其 __name__ 的值为这个模块和其所在包的名字，比如 module_2 的 __name__ 值为 package_1.module_2。 。。。其实这个内部原理我也没弄清楚，可以查看这个stackoverflow 问题，最后结论就是使用了相对导入的模块文件不能被直接运行，只能通过其他模块调用。 使用相对导入没有绝对导入那么直观，而且如果目录结构发生改变，则也要修改对应模块的导入语句。所以我最后使用的是下面这种方法。 添加路径到sys.path前面说过程序只会在sys.path 列表的路径中搜索模块，那么就可以想到另一个解决方法，即将想调用包或模块的路径添加到sys.path 中。 还是执行 python module_0.py，已经知道在 module_2.py 中直接导入module_3 模块会报错，除了使用绝对导入和相对导入，还可以将module_2.py 所在目录添加到sys.path 中。 1234# module_2.pysys.path.append(os.path.dirname(__file__))import module_3from package_2 import module_21 sys.path.append(os.path.dirname(__file__)) 表示的含义如下： 使用 sys.path.append 将某路径添加到sys.path 中。 __file__ 获得该模块文件的绝对路径 os.path.dirname(__file__) 获得模块文件所在的目录 所以这条语句就是把模块文件所在的目录添加到sys.path 中。 通过这种方法可以比较灵活地把其他路径添加到sys.path 中，而没有什么限制。 比如导入module_4.py 所在路径： 123# module_2.pysys.path.append(os.path.join(os.path.dirname(__file__), '../package_3'))import module_4 其中的 os.path.join(os.path.dirname(__file__), &#39;../package_3&#39;) 的值为：/home/zxd/Documents/package_0/package_1/../package_3，两点表示上一级目录。然后我们就可以直接导入module_4 了。 当通过这种方法导入工程文件中的很多模块路径在sys.path 中时，如果工程文件中存在重名模块，可能会报错：ImportError: cannot import name。这个要小心一点。 参考Absolute vs Relative Imports in Python Python Modules and Packages – An Introduction Working with Modules in Python The Definitive Guide to Python import Statements z.defying：import 问题浅谈)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PyQT5环境搭建及应用打包]]></title>
    <url>%2Fhello-pyqt5%2F</url>
    <content type="text"><![CDATA[通用开发框架 electorn：基于node-js，跨平台，开发成本低，运行效率低 qt：基于C++，跨平台，效率高，开发成本高 javafx：基于java，主要用于跨平台桌面程序开发 flutter：基于dart语言，谷歌开源移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面 Python方案 PyQt：PyQt5是Qt v5的Python版本，功能强大复杂，提供QT Designer设计UI （GPL V3协议，开源，商用收费） Pyside: PySide2是来自QT for Python项目的官方Python模块 （LGPL协议，闭源商用） Tkinter：Python标准库，Tk GUI 工具包的接口 ，布局通过代码实现，简单易用，但开发效率低 WxPython：开源免费，提供wxFormbuilder，压缩版PyQT 因为现有脚本绝大多数是基于Python开发，同时调研了上述框架的官方支持力度及网络资料丰富程度，最终还是选用了最流行最强大的PyQt 。 本文主要详细介绍下PyQt5完整入门教程，包含环境配置，使用Qt Disinger设计UI，最终完成一个天气预报的GUI实例开发。 环境为：Windows 10 + Python 3.8 + PyCharm 2019.2 PyQt环境配置安装PyQtPyQt当前最新版为PyQt5 5.14.1 直接pip安装即可： 12pip install PyQt5pip install pyqt5-tools 建议使用国内源，进行快速安装： 12pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyqt5pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyqt5-tools PyCharm配置环境启动PyCharm后，新建一个PyQt5空项目后，需要配置Qt Designer、pyuic、pyrcc工具，相关配置方法如下： Qt DesignerQt Designer 是通过拖拽的方式放置控件，并实时查看控件效果进行快速UI设计。最终生成.ui文件（实质上是XML格式的文件），可以通过pyuic5工具转换成.py文件。 在Pycharm中，依次打开 File - Settings - Tools - External Tools，点击 + Create Tool，配置如下： 123Name: QtDisignerProgram : C:\Python38\Lib\site-packages\pyqt5_tools\Qt\bin\designer.exe # 当前designer目录，请根据实际修改Working directory: $FileDir$ Qt Designer 汉化默认Qt Designer是英文版的，可以使用翻译文件进行汉化，下载地址：百度网盘，提取码：kxvx 下载文件 designer_zh_CN.qm后， 拷贝至本地pyqt5_tools的translations文件夹下即可，示例目录： 1C:\Python38\Lib\site-packages\pyqt5_tools\Qt\bin\translations 在PyCharm主界面，依次点击 Tools - External Tools - QtDisigner，即可启动中文界面的Qt Disigner PyUIC 配置PyUIC主要是把Qt Designer生成的.ui文件换成.py文件。 在Pycharm中，依次打开 File - Settings - Tools - External Tools，点击 + Create Tool，配置如下： 1234Name: PyUICProgram : C:\Python38\python.exe # 当前Python目录，请根据实际修改Arguments: -m PyQt5.uic.pyuic $FileName$ -o $FileNameWithoutExtension$.pyWorking directory: $FileDir$ PyRCC 配置PyRCC主要是把编写的.qrc资源文件换成.py文件。 在Pycharm中，依次打开 File - Settings - Tools - External Tools，点击 + Create Tool，配置如下： 1234Name: PyRCCProgram : C:\Python38\Scripts\pyrcc5.exe # 当前rcc工具目录，请根据实际修改Arguments: $FileName$ -o $FileNameWithoutExtension$_rc.pyWorking directory: $FileDir$ 应用打包若需要打包成客户端 , 先安装插件 pyinstaller 1pip install PyInstaller 进入需要打包的目录下 , 执行命令 1Pyinstaller [opts] yourprogram.py 示例 1pyinstaller -F -W main.py opts可选参数 参数 含义 -F 指定打包后只生成一个exe格式的文件 -D -onedir 创建一个目录 , 包含exe文件, 但会依赖很多文件(默认选项) -c -console , -nowindowed , 使用控制台 , 无窗口(默认) -w -windowed, -noconsole 使用窗口 , 无控制台 -p 添加搜索路径 , 让其找到对应的库 -i 改变生成应用的icon图标 Pyinstaller在PyCharm的支持配置点击 Settings-&gt;Tools-&gt;External Tools , 新增 Tool Name : 自定义工具名称 Program : pyinstaller.exe 文件所在的路径 , 通常在项目目录下的 Scripts 文件夹内 Arguments : -F $FileNameWithoutExtension$.py -w -i logo.ico 参数命令见上文 Working directory : $FileDir$ 保存配置 , 然后选择要执行的文件 , 例如 main.py 右键点击-&gt;External Tools-&gt; Pyinstaller Exe 然后开始打包 , 完成后项目目录下会出现 dist 文件夹 , 可执行包就在其中 参考资料 https://www.riverbankcomputing.com/static/Docs/PyQt5/ http://code.py40.com/face 《PyQt5快速开发与实战 PDF》 网盘地址 提取码：k3xx CSDN:Python GUI pycharm+Pyqt5 配置以及打包exe Python打包工具PyInstaller的安装与pycharm配置支持PyInstaller详细方法 大爱的博客]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>PyQt5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决Docker镜像拉取慢]]></title>
    <url>%2Fdocker-pull-speedup%2F</url>
    <content type="text"><![CDATA[在国内服务器上操作 Docker 拉取镜像太慢 ,无非是镜像在国外 . 解决办法就是配置国内镜像源 , 一般由阿里、网易、docker 中国官方等等 推荐方案1. 编辑 /etc/docker/daemon.json (若无 , 则创建) , 添加以下 json 123&#123; "registry-mirrors": ["https://docker.mirrors.ustc.edu.cn", "http://hub-mirror.c.163.com", "https://registry.docker-cn.com"]&#125; 2. 重启 docker 服务 1systemctl restart docker 参考链接Docker - 解决镜像拉取慢]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TextView添加SpannableString并设置点击色]]></title>
    <url>%2Fspannablestring-issue%2F</url>
    <content type="text"><![CDATA[通常在项目的注册等服务页面 , 会有一些条款 注册即表示同意《xx服务协议》 , 开发需要对服务协议的部分设置超链点击. 通常我们用 SpannableString 来实现富文本功能 , 下面将说明使用方法及遇到的问题. 在搜索引擎帮助下 , 常规做法是这样 1234567891011 TextView tv = (TextView) findViewById(R.id.tv_content); String content = "This is a text,click me" ; SpannableString spannableString = new SpannableString(content); spannableString.setSpan(new Clickable(v -&gt; &#123; // 点击事件 &#125;), start, end,Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);// 必须设置否则无法点击 tv.setMovementMethod(LinkMovementMethod.getInstance());// 不设置该属性，点击后会有背景色 tv.setHighlightColor(getResources().getColor(android.R.color.transparent)); tv.setText(spannableString); 这里使用 setHighlightColor(...) API 的原因是在点击富文本中的链接后 , 链接背景会变为系统主题中的默认 Highlight 颜色 , Android 4.0 以上默认是淡绿色(低版本中是黄色) , 产生 UI 效果的不协调 , 所以这里设置其为透明. 然而这样设置后 , 仍有点击超链的时候界面无任何 UI 响应 , 超链还有下划线等问题 , 于是需要进行一些自定义. 自定义TouchableSpan.java 123456789101112131415161718192021public abstract class TouchableSpan extends ClickableSpan &#123; private boolean mIsPressed; private int mNormalTextColor; private int mPressedTextColor; public TouchableSpan(int normalTextColor, int pressedTextColor) &#123; mNormalTextColor = normalTextColor; mPressedTextColor = pressedTextColor; &#125; public void setPressed(boolean isSelected) &#123; mIsPressed = isSelected; &#125; @Override public void updateDrawState(TextPaint ds) &#123; super.updateDrawState(ds); ds.setColor(mIsPressed ? mPressedTextColor : mNormalTextColor); ds.setUnderlineText(false); &#125;&#125; 设置文字点击颜色 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class LinkTouchMovementMethod extends LinkMovementMethod &#123; private TouchableSpan mPressedSpan; @Override public boolean onTouchEvent(TextView textView, Spannable spannable, MotionEvent event) &#123; if (event.getAction() == MotionEvent.ACTION_DOWN) &#123; mPressedSpan = getPressedSpan(textView, spannable, event); if (mPressedSpan != null) &#123; mPressedSpan.setPressed(true); Selection.setSelection(spannable, spannable.getSpanStart(mPressedSpan), spannable.getSpanEnd(mPressedSpan)); &#125; &#125; else if (event.getAction() == MotionEvent.ACTION_MOVE) &#123; TouchableSpan touchedSpan = getPressedSpan(textView, spannable, event); if (mPressedSpan != null &amp;&amp; touchedSpan != mPressedSpan) &#123; mPressedSpan.setPressed(false); mPressedSpan = null; Selection.removeSelection(spannable); &#125; &#125; else &#123; if (mPressedSpan != null) &#123; mPressedSpan.setPressed(false); super.onTouchEvent(textView, spannable, event); &#125; mPressedSpan = null; Selection.removeSelection(spannable); &#125; return true; &#125; private TouchableSpan getPressedSpan(TextView textView, Spannable spannable, MotionEvent event) &#123; int x = (int) event.getX(); int y = (int) event.getY(); x -= textView.getTotalPaddingLeft(); y -= textView.getTotalPaddingTop(); x += textView.getScrollX(); y += textView.getScrollY(); Layout layout = textView.getLayout(); int line = layout.getLineForVertical(y); int off = layout.getOffsetForHorizontal(line, x); TouchableSpan[] link = spannable.getSpans(off, off, TouchableSpan.class); TouchableSpan touchedSpan = null; if (link.length &gt; 0) &#123; touchedSpan = link[0]; &#125; return touchedSpan; &#125;&#125; 工具类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497public class SpannableStringUtils &#123; private SpannableStringUtils() &#123; throw new UnsupportedOperationException("u can't instantiate me..."); &#125; /** * 获取建造者 * * @return &#123;@link Builder&#125; */ public static Builder getBuilder(@NonNull CharSequence text) &#123; return new Builder(text); &#125; public static class Builder &#123; private int defaultValue = 0x12000000; private CharSequence text; private int flag; @ColorInt private int foregroundColor; @ColorInt private int backgroundColor; @ColorInt private int quoteColor; private boolean isLeadingMargin; private int first; private int rest; private boolean isBullet; private int gapWidth; private int bulletColor; private float proportion; private float xProportion; private boolean isStrikethrough; private boolean isUnderline; private boolean isSuperscript; private boolean isSubscript; private boolean isBold; private boolean isItalic; private boolean isBoldItalic; private String fontFamily; private Layout.Alignment align; private boolean imageIsBitmap; private Bitmap bitmap; private boolean imageIsDrawable; private Drawable drawable; private boolean imageIsUri; private Uri uri; private boolean imageIsResourceId; @DrawableRes private int resourceId; private TouchableSpan clickSpan; private String url; private boolean isBlur; private float radius; private BlurMaskFilter.Blur style; private SpannableStringBuilder mBuilder; private Builder(@NonNull CharSequence text) &#123; this.text = text; flag = Spanned.SPAN_EXCLUSIVE_EXCLUSIVE; foregroundColor = defaultValue; backgroundColor = defaultValue; quoteColor = defaultValue; proportion = -1; xProportion = -1; mBuilder = new SpannableStringBuilder(); &#125; /** * 设置标识 * * @param flag &lt;ul&gt; * &lt;li&gt;&#123;@link Spanned#SPAN_INCLUSIVE_EXCLUSIVE&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link Spanned#SPAN_INCLUSIVE_INCLUSIVE&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link Spanned#SPAN_EXCLUSIVE_EXCLUSIVE&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link Spanned#SPAN_EXCLUSIVE_INCLUSIVE&#125;&lt;/li&gt; * &lt;/ul&gt; * @return &#123;@link Builder&#125; */ public Builder setFlag(int flag) &#123; this.flag = flag; return this; &#125; /** * 设置前景色 * * @param color 前景色 * @return &#123;@link Builder&#125; */ public Builder setForegroundColor(@ColorInt int color) &#123; this.foregroundColor = color; return this; &#125; /** * 设置背景色 * * @param color 背景色 * @return &#123;@link Builder&#125; */ public Builder setBackgroundColor(@ColorInt int color) &#123; this.backgroundColor = color; return this; &#125; /** * 设置引用线的颜色 * * @param color 引用线的颜色 * @return &#123;@link Builder&#125; */ public Builder setQuoteColor(@ColorInt int color) &#123; this.quoteColor = color; return this; &#125; /** * 设置缩进 * * @param first 首行缩进 * @param rest 剩余行缩进 * @return &#123;@link Builder&#125; */ public Builder setLeadingMargin(int first, int rest) &#123; this.first = first; this.rest = rest; isLeadingMargin = true; return this; &#125; /** * 设置列表标记 * * @param gapWidth 列表标记和文字间距离 * @param color 列表标记的颜色 * @return &#123;@link Builder&#125; */ public Builder setBullet(int gapWidth, int color) &#123; this.gapWidth = gapWidth; bulletColor = color; isBullet = true; return this; &#125; /** * 设置字体比例 * * @param proportion 比例 * @return &#123;@link Builder&#125; */ public Builder setProportion(float proportion) &#123; this.proportion = proportion; return this; &#125; /** * 设置字体横向比例 * * @param proportion 比例 * @return &#123;@link Builder&#125; */ public Builder setXProportion(float proportion) &#123; this.xProportion = proportion; return this; &#125; /** * 设置删除线 * * @return &#123;@link Builder&#125; */ public Builder setStrikethrough() &#123; this.isStrikethrough = true; return this; &#125; /** * 设置下划线 * * @return &#123;@link Builder&#125; */ public Builder setUnderline() &#123; this.isUnderline = true; return this; &#125; /** * 设置上标 * * @return &#123;@link Builder&#125; */ public Builder setSuperscript() &#123; this.isSuperscript = true; return this; &#125; /** * 设置下标 * * @return &#123;@link Builder&#125; */ public Builder setSubscript() &#123; this.isSubscript = true; return this; &#125; /** * 设置粗体 * * @return &#123;@link Builder&#125; */ public Builder setBold() &#123; isBold = true; return this; &#125; /** * 设置斜体 * * @return &#123;@link Builder&#125; */ public Builder setItalic() &#123; isItalic = true; return this; &#125; /** * 设置粗斜体 * * @return &#123;@link Builder&#125; */ public Builder setBoldItalic() &#123; isBoldItalic = true; return this; &#125; /** * 设置字体 * * @param fontFamily 字体 * &lt;ul&gt; * &lt;li&gt;monospace&lt;/li&gt; * &lt;li&gt;serif&lt;/li&gt; * &lt;li&gt;sans-serif&lt;/li&gt; * &lt;/ul&gt; * @return &#123;@link Builder&#125; */ public Builder setFontFamily(@Nullable String fontFamily) &#123; this.fontFamily = fontFamily; return this; &#125; /** * 设置对齐 * * Layout.Alignment align * * @return &#123;@link Builder&#125; */ public Builder setAlign(@Nullable Layout.Alignment align) &#123; this.align = align; return this; &#125; /** * 设置图片 * * @param bitmap 图片位图 * @return &#123;@link Builder&#125; */ public Builder setBitmap(@NonNull Bitmap bitmap) &#123; this.bitmap = bitmap; imageIsBitmap = true; return this; &#125; /** * 设置图片 * * @param drawable 图片资源 * @return &#123;@link Builder&#125; */ public Builder setDrawable(@NonNull Drawable drawable) &#123; this.drawable = drawable; imageIsDrawable = true; return this; &#125; /** * 设置图片 * * @param uri 图片uri * @return &#123;@link Builder&#125; */ public Builder setUri(@NonNull Uri uri) &#123; this.uri = uri; imageIsUri = true; return this; &#125; /** * 设置图片 * * @param resourceId 图片资源id * @return &#123;@link Builder&#125; */ public Builder setResourceId(@DrawableRes int resourceId) &#123; this.resourceId = resourceId; imageIsResourceId = true; return this; &#125; /** * 设置点击事件 * &lt;p&gt;需添加view.setMovementMethod(LinkMovementMethod.getInstance())&lt;/p&gt; * * @param clickSpan 点击事件 * @return &#123;@link Builder&#125; */ public Builder setClickSpan(@NonNull TouchableSpan clickSpan) &#123; this.clickSpan = clickSpan; return this; &#125; /** * 设置超链接 * &lt;p&gt;需添加view.setMovementMethod(LinkMovementMethod.getInstance())&lt;/p&gt; * * @param url 超链接 * @return &#123;@link Builder&#125; */ public Builder setUrl(@NonNull String url) &#123; this.url = url; return this; &#125; /** * 设置模糊 * &lt;p&gt;尚存bug，其他地方存在相同的字体的话，相同字体出现在之前的话那么就不会模糊，出现在之后的话那会一起模糊&lt;/p&gt; * &lt;p&gt;推荐还是把所有字体都模糊这样使用&lt;/p&gt; * * @param radius 模糊半径（需大于0） * @param style 模糊样式&lt;ul&gt; * &lt;li&gt;&#123;@link Blur#NORMAL&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link Blur#SOLID&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link Blur#OUTER&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link Blur#INNER&#125;&lt;/li&gt; * &lt;/ul&gt; * @return &#123;@link Builder&#125; */ public Builder setBlur(float radius, BlurMaskFilter.Blur style) &#123; this.radius = radius; this.style = style; this.isBlur = true; return this; &#125; /** * 追加样式字符串 * * @param text 样式字符串文本 * @return &#123;@link Builder&#125; */ public Builder append(@NonNull CharSequence text) &#123; setSpan(); this.text = text; return this; &#125; /** * 创建样式字符串 * * @return 样式字符串 */ public SpannableStringBuilder create() &#123; setSpan(); return mBuilder; &#125; /** * 设置样式 */ private void setSpan() &#123; int start = mBuilder.length(); mBuilder.append(this.text); int end = mBuilder.length(); if (foregroundColor != defaultValue) &#123; mBuilder.setSpan(new ForegroundColorSpan(foregroundColor), start, end, flag); foregroundColor = defaultValue; &#125; if (backgroundColor != defaultValue) &#123; mBuilder.setSpan(new BackgroundColorSpan(backgroundColor), start, end, flag); backgroundColor = defaultValue; &#125; if (isLeadingMargin) &#123; mBuilder.setSpan(new LeadingMarginSpan.Standard(first, rest), start, end, flag); isLeadingMargin = false; &#125; if (quoteColor != defaultValue) &#123; mBuilder.setSpan(new QuoteSpan(quoteColor), start, end, 0); quoteColor = defaultValue; &#125; if (isBullet) &#123; mBuilder.setSpan(new BulletSpan(gapWidth, bulletColor), start, end, 0); isBullet = false; &#125; if (proportion != -1) &#123; mBuilder.setSpan(new RelativeSizeSpan(proportion), start, end, flag); proportion = -1; &#125; if (xProportion != -1) &#123; mBuilder.setSpan(new ScaleXSpan(xProportion), start, end, flag); xProportion = -1; &#125; if (isStrikethrough) &#123; mBuilder.setSpan(new StrikethroughSpan(), start, end, flag); isStrikethrough = false; &#125; if (isUnderline) &#123; mBuilder.setSpan(new UnderlineSpan(), start, end, flag); isUnderline = false; &#125; if (isSuperscript) &#123; mBuilder.setSpan(new SuperscriptSpan(), start, end, flag); isSuperscript = false; &#125; if (isSubscript) &#123; mBuilder.setSpan(new SubscriptSpan(), start, end, flag); isSubscript = false; &#125; if (isBold) &#123; mBuilder.setSpan(new StyleSpan(Typeface.BOLD), start, end, flag); isBold = false; &#125; if (isItalic) &#123; mBuilder.setSpan(new StyleSpan(Typeface.ITALIC), start, end, flag); isItalic = false; &#125; if (isBoldItalic) &#123; mBuilder.setSpan(new StyleSpan(Typeface.BOLD_ITALIC), start, end, flag); isBoldItalic = false; &#125; if (fontFamily != null) &#123; mBuilder.setSpan(new TypefaceSpan(fontFamily), start, end, flag); fontFamily = null; &#125; if (align != null) &#123; mBuilder.setSpan(new AlignmentSpan.Standard(align), start, end, flag); align = null; &#125; if (imageIsBitmap || imageIsDrawable || imageIsUri || imageIsResourceId) &#123; if (imageIsBitmap) &#123; mBuilder.setSpan(new ImageSpan(App.getApp(), bitmap), start, end, flag); bitmap = null; imageIsBitmap = false; &#125; else if (imageIsDrawable) &#123; mBuilder.setSpan(new ImageSpan(drawable), start, end, flag); drawable = null; imageIsDrawable = false; &#125; else if (imageIsUri) &#123; mBuilder.setSpan(new ImageSpan(App.getApp(), uri), start, end, flag); uri = null; imageIsUri = false; &#125; else &#123; mBuilder.setSpan(new ImageSpan(App.getApp(), resourceId), start, end, flag); resourceId = 0; imageIsResourceId = false; &#125; &#125; if (clickSpan != null) &#123; mBuilder.setSpan(clickSpan, start, end, flag); clickSpan = null; &#125; if (url != null) &#123; mBuilder.setSpan(new URLSpan(url), start, end, flag); url = null; &#125; if (isBlur) &#123; mBuilder.setSpan(new MaskFilterSpan(new BlurMaskFilter(radius, style)), start, end, flag); isBlur = false; &#125; flag = Spanned.SPAN_EXCLUSIVE_EXCLUSIVE; &#125; &#125;&#125; 使用 12345678910111213141516171819202122SpannableStringBuilder builder = SpannableStringUtils .getBuilder("登录/注册表示您同意") .append(" 《xxx隐私政策》 ") .setForegroundColor(linkColor) .setClickSpan(new TouchableSpan(linkColor,linkPressedColor) &#123; @Override public void onClick(View widget) &#123; // 点击事件 &#125; &#125;) .append("和") .append(" 《xxx服务协议》 ") .setForegroundColor(linkColor) .setClickSpan(new TouchableSpan(linkColor,linkPressedColor) &#123; @Override public void onClick(View widget) &#123; // 点击事件 &#125; &#125;).create(); textView.setText(builder); textView.setHighlightColor(transparent); textView.setMovementMethod(new LinkTouchMovementMethod()); 综上即可实现功能并解决提及问题 参考链接掘金:TextView添加SpannableString并添加点击色]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>SpannableString</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转-BottomSheet详解]]></title>
    <url>%2Fbottomsheet%2F</url>
    <content type="text"><![CDATA[本文转自 掘金: BottomSheet详解 关系 BottomSheet不是真正存在的类，而是一种称呼，表示该种控件类型，参照Google翻译，本文以下称之为“底页”，就是从屏幕底部弹出的工具条。与之对应是BottomSheetBehavior的行为类，它需要附属某个控件使用。该行为性质包括： 可以从底部弹出 可以上下拖拽布局 可以单击淡黑色遮罩隐藏/关闭 BottomSheetDialog继承Dialog，是一种对话框，它是拥有BottomSheetBehavior行为的对话框，从而实现从底部弹出和上下拉伸的效果。 BottomSheetDialogFragment是包含BottomSheetDialog的片段（Fragment），所以它可以同时利用Fragment的特点和BottomSheet这一交互效果 BottomSheetBehavior使用在xml布局文件中与CoordinatorLayout配合使用。如下设置后，NestedScrollView具有BottomSheetBehavior的性质，且一开始就显示在布局中，初始的显示高度为peekHeight值。背景没有淡黑色遮罩，可以上下拖拽。 关键语句app:layout_behavior=&quot;@string/bottom_sheet_behavior&quot;。 NestedScrollView的子视图只能有一个。 123456789101112131415161718192021&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent" android:fitsSystemWindows="true"&gt; &lt;android.support.v4.widget.NestedScrollView android:id="@+id/bottom_sheet" android:layout_width="match_parent" android:layout_height="wrap_content" app:behavior_hideable="true" app:behavior_peekHeight="50dp" app:layout_behavior="@string/bottom_sheet_behavior"&gt; &lt;!--内部布局--&gt; &lt;/android.support.v4.widget.NestedScrollView&gt; &lt;/android.support.design.widget.CoordinatorLayout&gt; 上述代码中有两个属性值得注意。 app:behavior_hideable：当我们上下拖拽时，布局是否可以全部隐藏。如果设置为真，那么你向下滑完之后，布局会被隐藏起来，然后就滑不出来了。。。（除非你写了按钮之类的逻辑控制它的行为）所以要谨慎。 app:behavior_peekHeight：是当底页关闭的时候，底部我们能看到的高度，默认是0不可见。 获取行为在布局文件中声明之后，就可以在代码中获取行为了。 1234// 获取视图View = findViewById(R.id.bottom_sheet);// 获取行为BottomSheetBehavior behavior = BottomSheetBehavior.from(view); 方法行为的一些常用的方法。 方法名 用法示例 说明 setHideable setHideable(true) 对应app:behavior_hideable属性 setPeekHeight setPeekHeight(500) 对应app:behavior_peekHeight属性 setBottomSheetCallback / 设置监听回调 setState setState(BottomSheetBehavior.STATE_EXPANDED) 设置底页状态 BottomSheetCallback123456789101112behavior.setBottomSheetCallback(new BottomSheetBehavior.BottomSheetCallback() &#123; @Override public void onStateChanged(@NonNull View bottomSheet, int newState) &#123; //监听BottomSheet状态的改变 &#125; @Override public void onSlide(@NonNull View bottomSheet, float slideOffset) &#123; //监听拖拽中的回调，根据slideOffset可以做一些动画 &#125;&#125;); 底页行为一共有五种状态。 STATE_HIDDEN: 隐藏状态。默认是false，可通过app:behavior_hideable属性设置。 STATE_COLLAPSED: 折叠关闭状态。可通过app:behavior_peekHeight来设置显示的高度，peekHeight默认是0。 STATE_DRAGGING: 被拖拽状态 STATE_SETTLING: 拖拽松开之后到达终点位置（collapsed or expanded）前的状态。 STATE_EXPANDED: 完全展开的状态。 BottomSheetDialog这是具有底页行为性质的对话框，不需要与CoordinatorLayout配合使用。弹出时，背景为出现一层淡黑色遮罩。需要相关逻辑控制它的弹出。 使用布局文件设计BottomSheetDialog内部的视图。Xml可以不用被CoordinatorLayout包裹，但是还是推荐实用推荐的滑动控件NestedScrollView。 使用代码使用上述的布局文件，假设名称为layout_bsd。可以获取行为实现自定义。要注意的是从视图的父视图（(View)view.getParent()）获取底页行为，否则会报错： The view is not a child of CoordinatorLayout. 123456BottomSheetDialog dialog = new BottomSheetDialog(context);View view = getLayoutInflater.inflate(R.layout.layout_bsd, null);dialog.setContentView(view);// 获取行为，用于自定义BottomSheetBehavior behavior = BottomSheetBehavior.from((View)view.getParent());dialog.show(); BottomSheetDialogFragment有两种用法。 当作中装了一个底页对话框的Fragment。实际是与底页对话框的作用和使用方法是相同的。 具有底页行为的Fragment。 用法1 披着 Fragment 外衣的 Dialog重写BottomSheetDialogFragment中的onCreateDialog方法。可以看到和上面BottomSheetDialog的代码是相同的。同样可以在中间获取行为用于自定义。要注意是子视图的扩充用到的是View.inflate的静态方法，否则会报错。 123456789@Overridepublic Dialog onCreateDialog(Bundle savedInstanceState)&#123; BottomSheetDialog dialog = (BottomSheetDialog) super.onCreateDialog(savedInstanceState); View view = View.inflate(getContext(), R.layout.dialog_bottom_sheet, null); dialog.setContentView(view); mBehavior = BottomSheetBehavior.from((View) view.getParent()); return dialog;&#125; 用法2 Fragment重写BottomSheetDialogFragment中的onCreateView方法。代码与Fragment的常规写法相同。不过不好的一点是不容易获取行为。如果要强行获取行为的话，可以使用以下的代码。 12345678910111213141516171819@Overridepublic void onStart() &#123; super.onStart(); Dialog dialog = getDialog(); if (dialog != null) &#123; View bottomSheet = dialog.findViewById(R.id.design_bottom_sheet); bottomSheet.getLayoutParams().height = ViewGroup.LayoutParams.MATCH_PARENT; &#125; View view = getView(); view.post(() -&gt; &#123; View parent = (View) view.getParent(); CoordinatorLayout.LayoutParams params = (CoordinatorLayout.LayoutParams) (parent).getLayoutParams(); CoordinatorLayout.Behavior behavior = params.getBehavior(); BottomSheetBehavior bottomSheetBehavior = (BottomSheetBehavior) behavior; bottomSheetBehavior.setPeekHeight(view.getMeasuredHeight()); ((View)bottomSheet.getParent()).setBackgroundColor(Color.TRANSPARENT); &#125;);&#125; 但是如果这两个方法都重写了，那么以onCreateView里的视图为准，onCreateDialog会被覆盖。 扩展: 通过设置style实现圆角样式如下设置好之后，在创建BottomSheetDialog时传入样式。 1BottomSheetDialog dialog = new BottomSheetDialog(context, R.style.BottomSheetDialog); 123456789101112131415161718192021222324252627&lt;!--styles.xml文件--&gt;&lt;style name="BottomSheet" parent="Widget.Design.BottomSheet.Modal"&gt; &lt;!--背景，顶部两个圆角--&gt; &lt;item name="android:background"&gt;@drawable/bg_bottom_sheet&lt;/item&gt;&lt;/style&gt;&lt;style name="BottomSheetDialog" parent="Theme.Design.Light.BottomSheetDialog"&gt; &lt;item name="android:windowIsFloating"&gt;false&lt;/item&gt; &lt;!--底部弹出条的样式（相当于背景）--&gt; &lt;item name="bottomSheetStyle"&gt;@style/BottomSheet&lt;/item&gt; &lt;!--状态栏颜色--&gt; &lt;item name="android:statusBarColor"&gt;@color/transparent&lt;/item&gt; &lt;!--导航条颜色--&gt; &lt;item name="android:navigationBarColor"&gt;@color/white&lt;/item&gt;&lt;/style&gt;&lt;!--以下是@drawable/bg_bottom_sheet--&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle"&gt; &lt;corners android:topLeftRadius="16dp" android:topRightRadius="16dp"&gt; &lt;/corners&gt; &lt;solid android:color="@android:color/white"/&gt; &lt;padding android:top="16dp" android:left="8dp" android:right="8dp" /&gt;&lt;/shape&gt; 效果图 .png) 参考BottomSheet、BottomSheetDialog使用详解 StackOverflow]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>BottomSheet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转-Dockerfile详解]]></title>
    <url>%2Fdockerfile%2F</url>
    <content type="text"><![CDATA[一段时间未写 Dockerfile , 有些忘记编写规则 , 于是转发一篇详解文章 , 以做记录 本文转自 看完这篇,再也不用担心不会写dockerfile了 Dockerfile是Docker用来构建镜像的文本文件,包括自定义的指令和格式。可以通过docker build命令从Dockerfile中构建镜像。用户可以通过统一的语法命令来根据需求进行配置，通过这份统一的配置文件，在不同的文件上进行分发，需要使用时就可以根据配置文件进行自动化构建，这解决了开发人员构建镜像的复杂过程。 Dockerfile使用Dockerfile描述了组装对象的步骤，其中每条指令都是单独运行的。除了FROM指令，其他每条命令都会在上一条指令所生成镜像的基础上执行，执行完后会生成一个新的镜像层，新的镜像层覆盖在原来的镜像之上从而形成了新的镜像。Dockerfile所生成的最终镜像就是在基础镜像上面叠加一层层的镜像层组建的。 Dockerfile指令Dockerfile的基本格式如下: 12# CommentINSTRUCTION arguments 在Dockerfile中,指令(INSTRUCTION)不区分大小写，但是为了与参数区分，推荐大写。Docker会顺序执行Dockerfile中的指令，第一条指令必须是FROM指令，它用于指定构建镜像的基础镜像。在Dockerfile中以#开头的行是注释，而在其他位置出现的#会被当成参数。 Dockerfile中的指令有FROM、MAINTAINER、RUN、CMD、EXPOSE、ENV、ADD、COPY、ENTRYPOING、VOLUME、USER、WORKDIR、ONBUILD,错误的指令会被忽略。下面将详细讲解一些重要的Docker指令。 FROM格式: FROM &lt;image&gt; 或者 FROM &lt;image&gt;:&lt;tag&gt; FROM指令的功能是为后面的指令提供基础镜像,因此Dockerfile必须以FROM指令作为第一条非注释指令。从公共镜像库中拉取镜像很容易,基础镜像可以选择任何有效的镜像。在一个Dockerfile中FROM指令可以出现多次,这样会构建多个镜像。tag的默认值是latest,如果参数image或者tag指定的镜像不存在，则返回错误。 ENV格式: ENV &lt;key&gt; &lt;value&gt; 或者 ENV &lt;key&gt;=&lt;value&gt; ENV指令可以为镜像创建出来的容器声明环境变量。并且在Dockerfile中，ENV指令声明的环境变量会被后面的特定指令(即ENV、ADD、COPY、WORKDIR、EXPOSE、VOLUME、USER)解释使用。 其他指令使用环境变量时，使用格式为$variable_name或者${variable_name}。如果在变量面前添加斜杠\可以转义。如\\$foo或者\\${foo}将会被转换为$foo和${foo},而不是环境变量所保存的值。另外，ONBUILD指令不支持环境替换。 COPY格式: COPY &lt;src&gt; &lt;dest&gt; COPY指令复制所指向的文件或目录,将它添加到新镜像中,复制的文件或目录在镜像中的路径是&lt;dest&gt;。&lt;src&gt;所指定的源可以有多个,但必须是上下文根目录中的相对路径。不能只用形如 COPY ../something /something这样的指令。此外,&lt;src&gt;可以使用通配符指向所有匹配通配符的文件或目录，例如，COPY home* /mydir/ 表示添加所有以”hom”开头的文件到目录/mydir/中。 &lt;dest&gt;可以是文件或目录，但必须是目标镜像中的绝对路径或者相对于WORKDIR的相对路径(WORKDIR即Dockerfile中WORKDIR指令指定的路径,用来为其他指令设置工作目录)。若&lt;dest&gt;以反斜杠/结尾则其指向的是目录；否则指向文件。&lt;src&gt;同理。若&lt;dest&gt;是一个文件，则&lt;src&gt;的内容会被写到&lt;dest&gt;中；否则&lt;src&gt;指向的文件或目录中的内容会被复制添加到&lt;dest&gt;目录中。当&lt;src&gt;指定多个源时，&lt;dest&gt;必须是目录。如果&lt;dest&gt;不存在，则路径中不存在的目录会被创建。 ADD格式: ADD &lt;src&gt; &lt;dest&gt; ADD与COPY指令在功能上很相似，都支持复制本地文件到镜像的功能，但ADD指令还支持其他功能。&lt;src&gt;可以是指向网络文件的URL,此时若&lt;dest&gt;指向一个目录，则URL必须是完全路径，这样可以获得网络文件的文件名filename，该文件会被复制添加到&lt;dest&gt;/&lt;filename&gt;。比如 ADD http://example.com/config.pro… / 会创建文件/config.property。 &lt;src&gt;还可以指向一个本地压缩归档文件，该文件会在复制到容器时会被解压提取，如ADD sxample.tar.xz /。但是若URL中的文件为归档文件则不会被解压提取。 ADD 和 COPY指令虽然功能相似，但一般推荐使用COPY,因为COPY只支持本地文件，相比ADD而言，它更加透明。 EXPOSE格式: EXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...] EXPOSE指令通知Docker该容器在运行时侦听指定的网络端口。可以指定端口是侦听TCP还是UDP，如果未指定协议，则默认值为TCP。这个指令仅仅是声明容器打算使用什么端口而已，并不会自动在宿主机进行端口映射,可以在运行的时候通过docker -p指定。 12EXPOSE 80/tcpEXPOSE 80/udp USER格式: USER &lt;user&gt;[:&lt;group] 或者 USER &lt;UID&gt;[:&lt;GID&gt;] USER指令设置了user name和user group(可选)。在它之后的RUN,CMD以及ENTRYPOINT指令都会以设置的user来执行。 WORKER格式: WORKDIR /path/to/workdir WORKDIR指令设置工作目录，它之后的RUN、CMD、ENTRYPOINT、COPY以及ADD指令都会在这个工作目录下运行。如果这个工作目录不存在，则会自动创建一个。WORKDIR指令可在Dockerfile中多次使用。如果提供了相对路径，则它将相对于上一个WORKDIR指令的路径。例如 1234WORKDIR /aWORKDIR bWORKDIR cRUN pwd 输出结果是 /a/b/c RUN格式1： RUN &lt;command&gt; (shell格式)格式2： RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] (exec格式，推荐使用) RUN指令会在前一条命令创建出的镜像的基础上创建一个容器，并在容器中运行命令，在命令结束运行后提交容器为新镜像，新镜像被Dockerfile中的下一条指令使用。 RUN指令的两种格式表示命令在容器中的两种运行方式。当使用shell格式时，命令通过/bin/sh -c运行。当使用exec格式时，命令是直接运行的，容器不调用shell程序，即容器中没有shell程序。exec格式中的参数会被当成JSON数组被Docker解析，故必须使用双引号而不能使用单引号。因为exec格式不会在shell中执行，所以环境变量的参数不会被替换。 比如执行RUN [&quot;echo&quot;, &quot;$HOME&quot;]指令时，$HOME不会做变量替换。如果希望运行shell程序，指令可以写成 RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo&quot;, &quot;$HOME&quot;]。 CMDCMD指令有3种格式。 格式1：CMD &lt;command&gt; (shell格式)格式2：CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] (exec格式，推荐使用)格式3：CMD [&quot;param1&quot;, &quot;param2&quot;] (为ENTRYPOINT指令提供参数) CMD指令提供容器运行时的默认值，这些默认值可以是一条指令，也可以是一些参数。一个Dockerfile中可以有多条CMD指令，但只有最后一条CMD指令有效。CMD [“param1”, “param2”]格式是在CMD指令和ENTRYPOINT指令配合时使用的，CMD指令中的参数会添加到ENTRYPOING指令中.使用shell和exec格式时，命令在容器中的运行方式与RUN指令相同。 不同之处在于，RUN指令在构建镜像时执行命令，并生成新的镜像；CMD指令在构建镜像时并不执行任何命令，而是在容器启动时默认将CMD指令作为第一条执行的命令。如果用户在命令行界面运行docker run命令时指定了命令参数，则会覆盖CMD指令中的命令。 ENDPOINTENTRYPOINT指令有两种格式。 格式1：ENTRYPOINT &lt;command&gt; (shell格式)格式2：ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] (exec格式，推荐格式) ENTRYPOINT指令和CMD指令类似，都可以让容器在每次启动时执行相同的命令，但它们之间又有不同。一个Dockerfile中可以有多条ENTRYPOINT指令，但只有最后一条ENTRYPOINT指令有效。 当使用Shell格式时，ENTRYPOINT指令会忽略任何CMD指令和docker run命令的参数，并且会运行在bin/sh -c中。这意味着ENTRYPOINT指令进程为bin/sh -c的子进程,进程在容器中的PID将不是1，且不能接受Unix信号。即当使用docker stop &lt;container&gt;命令时，命令进程接收不到SIGTERM信号。 推荐使用exec格式，使用此格式时，docker run传入的命令参数会覆盖CMD指令的内容并且附加到ENTRYPOINT指令的参数中。从ENTRYPOINT的使用中可以看出，CMD可以是参数，也可以是指令，而ENTRYPOINT只能是命令；另外，docker run命令提供的运行命令参数可以覆盖CMD,但不能覆盖ENTRYPOINT。 Dockerfile实践心得使用标签给镜像打上标签，有利于帮助了解进镜像功能 谨慎选择基础镜像选择基础镜像时，尽量选择当前官方镜像库的肩宽，不同镜像的大小不同，目前Linux镜像大小由如下关系: busybox &lt; debian &lt; centos &lt; ubuntu 同时在构建自己的Docker镜像时,只安装和更新必须使用的包。此外相比Ubuntu镜像，更推荐使用Debian镜像，因为它非常轻量级(目前其大小是在100MB以下),并且仍然是一个完整的发布版本。 充分利用缓存Docker daemon会顺序执行Dockerfile中的指令，而且一旦缓存失效，后续命令将不能使用缓存。为了有效地利用缓存，需要保证指令的连续性，尽量将所有Dockerfile文件相同的部分都放在前面，而将不同的部分放到后面。 正确使用ADD与COPY命令当在Dockerfile中的不同部分需要用到不同的文件时，不要一次性地将这些文件都添加到镜像中去，而是在需要时添加，这样也有利于重复利用docker缓存。另外考虑到镜像大小问题，使用ADD指令去获取远程URL中的压缩包不是推荐的做法。应该使用RUN wget或RUN curl代替。这样可以删除解压后不在需要的文件，并且不需要在镜像中在添加一层。 错误做法: 123ADD http://example.com/big.tar.xz /usr/src/things/RUN tar -xJf /usr/src/things/big.tar.xz -C /usr/src/thingsRUN make -C /usr/src/things all 正确的做法 1234RUN mkdir -p /usr/src/things \ &amp;&amp; curl -SL http://example.com/big.tar.xz \ | tar -xJC /usr/src/things \ &amp;&amp; make -C /usr/src/things all RUN指令在使用较长的RUN指令时可以使用反斜杠\分隔多行。大部分使用RUN指令的常见是运行apt-wget命令，在该场景下请注意以下几点。 不要在一行中单独使用指令RUN apt-get update。当软件源更新后，这样做会引起缓存问题，导致RUN apt-get install指令运行失败。所以,RUN apt-get update和RUN apt-get install应该写在同一行。比如 RUN apt-get update &amp;&amp; apt-get install -y package-1 package-2 package-3 避免使用指令RUN apt-get upgrade 和 RUN apt-get dist-upgrade。因为在一个无特权的容器中，一些必要的包会更新失败。如果需要更新一个包(如package-1)，直接使用命令RUN apt-get install -y package-1。 CMD和ENTRYPOINT命令CMD和ENTRYPOINT命令指定是了容器运行的默认命令，推荐二者结合使用。使用exec格式的ENTRYPOINT指令设置固定的默认命令和参数，然后使用CMD指令设置可变的参数。 比如下面这个例子: 123456FROM busyboxWORKDIR /appCOPY run.sh /appRUN chmod +x run.shENTRYPOINT ["/app/run.sh"]CMD ["param1"] run.sh内容如下: 12#!/bin/shecho &quot;$@&quot; 运行后输出结果为param1, Dockerfile中CMD和ENTRYPOINT的顺序不重要(CMD写在ENTRYPOINT前后都可以)。 当在windows系统下build dockerfile你可能会遇到这个问题 1standard_init_linux.go:207: exec user process caused &quot;no such file or directory&quot; 这是因为sh文件的fileformat是dos,这里需要修改为unix,不需要下载额外的工具，一般我们机器上安装了git会自带git bash,进入git bash,使用vi 编辑，在命令行模式下修改(:set ff=unix)。 不要在Dockerfile中做端口映射使用Dockerfile的EXPOSE指令，虽然可以将容器端口映射在主机端口上，但会破坏Docker的可移植性，且这样的镜像在一台主机上只能启动一个容器。所以端口映射应在docker run命令中用-p 参数指定 12345# 不要再Dockerfile中做如下映射EXPOSE 80:8080# 仅暴露80端口,需要另做映射EXPOSE 80 实践DockerfileJava服务的Dockerfile12345678FROM openjdk:8-jre-alpineENV spring_profiles_active=devENV env_java_debug_enabled=falseEXPOSE 8080WORKDIR /appADD target/smcp-web.jar /app/target/smcp-web.jarADD run.sh /appENTRYPOINT ./run.sh 可以看到基础镜像是openjdk,然后设置了两个环境变量,服务访问端口是9090(意味着springboot应用中指定了server.port=8080),设置了工作目录是/app。通过ENTRYPOINT设定了启动镜像时要启动的命令(./run.sh)。这个脚本中的内容如下: 12345678#!/bin/sh# Set debug options if requiredif [ x&quot;$&#123;env_java_debug_enabled&#125;&quot; != x ] &amp;&amp; [ &quot;$&#123;env_java_debug_enabled&#125;&quot; != &quot;false&quot; ]; then java_debug_args=&quot;-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005&quot;fi# ex: env_jvm_flags=&quot;-Xmx1200m -XX:MaxRAM=1500m&quot; for productionjava $java_debug_args $env_jvm_flags -XX:+UnlockExperimentalVMOptions -XX:+UseCGroupMemoryLimitForHeap -jar target/smcp-web.jar 如果我们要指定jvm的一些参数,可以通过在环境变量中设置env_jvm_flags来指定。 Maven Dockerfilemaven的Dockerfile也写的很好，这里我发上来也给大家参考下 12345678910111213141516171819202122FROM openjdk:8-jdkARG MAVEN_VERSION=3.6.3ARG USER_HOME_DIR="/root"ARG SHA=c35a1803a6e70a126e80b2b3ae33eed961f83ed74d18fcd16909b2d44d7dada3203f1ffe726c17ef8dcca2dcaa9fca676987befeadc9b9f759967a8cb77181c0ARG BASE_URL=https://apache.osuosl.org/maven/maven-3/$&#123;MAVEN_VERSION&#125;/binariesRUN mkdir -p /usr/share/maven /usr/share/maven/ref \ &amp;&amp; curl -fsSL -o /tmp/apache-maven.tar.gz $&#123;BASE_URL&#125;/apache-maven-$&#123;MAVEN_VERSION&#125;-bin.tar.gz \ &amp;&amp; echo "$&#123;SHA&#125; /tmp/apache-maven.tar.gz" | sha512sum -c - \ &amp;&amp; tar -xzf /tmp/apache-maven.tar.gz -C /usr/share/maven --strip-components=1 \ &amp;&amp; rm -f /tmp/apache-maven.tar.gz \ &amp;&amp; ln -s /usr/share/maven/bin/mvn /usr/bin/mvnENV MAVEN_HOME /usr/share/mavenENV MAVEN_CONFIG "$USER_HOME_DIR/.m2"COPY mvn-entrypoint.sh /usr/local/bin/mvn-entrypoint.shCOPY settings-docker.xml /usr/share/maven/ref/ENTRYPOINT ["/usr/local/bin/mvn-entrypoint.sh"]CMD ["mvn"] 可以看到它是基于openjdk这个基础镜像来创建的，先去下载maven的包，然后进行了安装。 然后又设置了MAVEN_HOME和MAVEN_CONFIG这两个环境变量，最后通过mvn-entrypoing.sh来进行了启动。 前端服务的两阶段构建我有一个前端服务，目录结构如下： 12$ ls frontend/myaccount/ resources/ third_party/ myaccount目录下是放置的js,vue等，resources放置的是css,images等。third_party放的是第三方应用。 这里采用了两阶段构建，即采用上一阶段的构建结果作为下一阶段的构建数据 1234567891011121314151617FROM node:alpine as builderWORKDIR '/build'COPY myaccount ./myaccountCOPY resources ./resourcesCOPY third_party ./third_partyWORKDIR '/build/myaccount'RUN npm installRUN npm rebuild node-sassRUN npm run buildRUN ls /build/myaccount/distFROM nginxEXPOSE 80COPY --from=builder /build/myaccount/dist /usr/share/nginx/html 需要注意结尾的 --from=builder这里和开头是遥相呼应的。]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Dockerfile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转-正则]]></title>
    <url>%2Fregex%2F</url>
    <content type="text"><![CDATA[在研发中 , 经常用到正则表达式 , 看过很多次 , 在用时却记不住 , 这里转篇结合例子讲解的文章以记录. 转自 掘金 正则表达式1.1 基本语法通过一张图表来对正则表达式的基本进行一个回顾 single char quantifiers(数量) position(位置) \d 匹配数字 * 0个或者更多 ^一行的开头 \w 匹配word(数字、字母) + 1个或更多，至少1个 $一行的结尾 \W 匹配非word(数字、字母) ? 0个或1个,一个Optional \b 单词”结界”(word bounds) \s 匹配white space(包括空格、tab等) {min,max}出现次数在一个范围内 \S 匹配非white space(包括空格、tab等) {n}匹配出现n次的 . 匹配任何，任何的字符 1.1.1 single char假设你有一段字符如下: 1These are some phone numbers 917-555-1234. Also, you can call me at 645.555.1234 and of course I&apos;m always reachable at (212)867-5309. \w 将匹配所有word，当然，() - 等字符除外 \w\w\w 注意正则表达式是匹配一个连续串的规则，所以可以看到三个字母的单词可以匹配到，6个单词的也可以匹配到。 \s\s 匹配到一行中连续两个空格 quantifiers假设我们有一段话: 12The colors of the rainbow have many colours and the rainbow does not have a single colour. 我们想把所有的颜色找出来colors colours colour 答案 colou?rs? 嗯，看起来很简单，很方便。 好了，现在想要匹配一行中的4个数字，或者一行中的5个字母等，这时候用quantifiers就非常方便了。 我现在想找5个字母组成的单词 \w{5} 这样可以吗？嗯..不行的，看下它匹配的内容,如下: ‘These are some phone numbers 915-555-1234…’ 的确，我们模板给的很简单，它只找一行中，连续出现5个字母的序列。所以现在改进一下好了 \w{5}\s 为了能找到单词，所以我希望5个字母后，跟一个空格的序列，这样应该可以了吧，看下匹配情况： ‘Theseare some phonenumbers915-555-1234…’ 嗯，是的，只有目前这些方法，是做不到的。 所以，我们需要第三个工具 “position” 1.1.2 position回到刚才的问题之前，先熟悉下^ $ 和 \b 12345678This is somthingis abouta blahwordssequence of wordsHello andGoodBye and Go gogo! 来看下各种正则所匹配的内容 \w+ 这个应该毫无疑问，匹配所有的words ^\w+ 多了一个 ^ ,这样子,就只能匹配到每一行开头的单词了 \w+$ 这样就能匹配到每行的最后一个字母了 回到刚才的问题 现在想找5个字母组成的单词 就变得很简单了，使用单词结界符\b 答案就是\b\w{5}\b 1.1.3 找个电话号码最后，找一个刚才出现的电话号123-456-1231 用以上最基本的正则方法就是 \d{3}-\d{3}-\d{4}，这样就找到了。 但是有的时候，电话号码是123.456.1234 或者 (212)867-4233的结构怎么办呢？ 正则表达式中的或或者其他表达方式，下面一一来介绍。 1.2 字符分类(char class)前面记录了最基本的方法 , 接下来说一下分类符 [] 这个符号用来表示逻辑关系或，比如[abc]表示a或者b或c.[-.]表示符号-或者.号(注意这里，在[]中的.号代表的就是这个符号，但是如果在其外面，表示个匹配所有。 所以如果不在[]之中，想要匹配’.’，就要通过转意符号\.) 1.2.1 分类的简单应用字符序列: 1The lynk is quite a link don&apos;t you think? l nk l(nk 正则表达式： l[yi (]nk 结果: 1lynk link l nk l(nk 很容易理解的，就是表达或逻辑。 1.2.2 匹配所有可能的电话号码好了，现在回到之前遗留的问题，有以下字段，请匹配所有可能的电话号码： 123These are some phone numbers 915-134-3122. Also,you can call me at 643.123.1333 and of course,I&apos;m always reachable at (212)867-5509 好的，一步一步来，刚才我们使用\d{3}-\d{3}-\d{4}匹配了连字符的情况。现在我们可以很轻松的把.这种情况加进去了 第一步： \d{3}[-.]\d{3}[-.]\d{4} 第二步: 为了能够匹配括号，可以使用?来，因为这是一个option选择。所以最后就成了 1\(?\d&#123;3&#125;[-.)]\d&#123;3&#125;[-.]\d&#123;4&#125; 这里还是要说明，在[]中，特殊字符不需要转义，可以直接使用，比如[.()],但是在外面，是需要转义的\( \.等 1.2.3 []的特殊语法刚才介绍了最简单和基本的功能，但是有些特殊的地方需要注意 1. -连接符是第一个字符时 比如[-.]的含义是连字符-或者点符.。 但是，如果当连字符不是第一个字符时，比如[a-z]，这就表示是从字母a到字符z。 2. []中的^ ^在之前介绍中，是表示一行开头，但是在[]中，有着不同的含义。 [ab] 表示a或者b [^ab] 啥都行，只要不是a或b(anythings except a and b)，相当于取反 1.2.4 []和()除了使用[]表示或逻辑,()也是可以的。用法是(a|b)表示a或者b 比如下面的例子，匹配所有email 123gaoyaqi411@126.com dyumc@google.net sam@sjtu.edu 思路： 首先要想我到底相匹配什么，这里我想匹配的是 任何一个以words开头的，一个或更多 \w+ 紧接着是一个@符号 \w+@ 接着有一个或者更多的words \w+@\w+ 接着一个.标点 \w+@\w+\. 接着一个com net 或 edu \w+@\w+\.(com|net|edu) 还是提醒注意第四步的\.转义符号 好了，这样几可以匹配以上的所有邮箱了。但是还有一个问题，因为邮箱用户名是可以有.的，比如vincent.ko@126.com 其实仍然很简单，修复如下： [\w.]+@\w+\.(com|net|edu) 1.2.5 总结 []的作用，用英文表达就是”alternation”,表达一个或的逻辑； /[-.(]/ 在符号中的连字符-放在第一位表示连字符本身，如果放在中间，表示”从..到..”，比如[a-z]表示a-z [.)] 括号中的特殊符号不需要转义，就表示其本身 [^ab]括号中的^表示非，anythings exceptaandb (a|b)也可表示选择，但是它有更强大的功能…. 所以，()的强大功能是什么呢？ 分组捕获，这对序列的替换、交换是很有帮助的。 后面一节进行学习记录 1.3 分组捕获(capturing groups)什么是分组捕获，现在回到之前电话号码的例子 12345678212-555-1234915-412-1333//我想要保留区号，把后面的电话号码变为通用性的👇👇👇👇👇👇👇👇👇👇👇👇212-xxx-xxxx915-xxx-xxxx 按照之前的做法\d{3}-\d{3}-\d{4},这种匹配的方式，是将整个电话号码作为一个组(group)匹配起来。 我们把212-555-1234这样的叫Group0。 这个时候，如果我们加了一个括号\d{3}-(\d{3})-\d{4}，那么匹配到的555就叫Group1。 以此类推，如果有两个小括号\d{3}-(\d{3})-(\d{4})那么分组就是下面的情况： 1.3.1 选择分组现在组已经分好，那么如何选择已经匹配的分组？ 这里有两种方法，第一种使用$符号，比如$1 代表555,$2代表1234；第二种，使用\,比如\1代表555。两种的使用场景不一样，先讲$ 现在为了满足最开始的要求，我们可以这么做 123reg: \(?(\d&#123;3&#125;)[-.)]\d&#123;3&#125;[-.]\d&#123;4&#125;replace: $1-xxx-xxxx 1.3.2 实景训练1. 现在有一个名单列表 , 但是姓和名是反过来的, 需要调正 1234shiffina, Danielshifafl, Daniellshquer, Danny... 实现方法: 123reg: (\w+),\s(\w+)replace: $2 $1 注意：$0 是所有匹配到的，所以第一个加括号的是$1 2. 匹配markdown中的link标签，并替换为html标签 123[google](http://google.com)[itp](http://itp.nyu.edu)[Coding Rainbow](http://codingrainbow.com) 解析： 这道题有些坑，需要慢慢来。 看到这个，第一个想考虑匹配[google]这个东西，立马想到正则表达式\[.*\]。 这个是巨大的坑，在当前来看，它的确能正确匹配到上面的三条。 但是如果文本是这样的： 123[google](http://google.com),[test][itp](http://itp.nyu.edu)[Coding Rainbow](http://codingrainbow.com) 看到了，第一行的内容会全部匹配下来，而不能区分[google]和[test]。 之所以这样，是因为.是贪婪的，他表示所有，所有能匹配到的，所以当然也包括了]，一直到这一行的最后一个]，它才停止。 所以为了让它能正确匹配，需要去掉这种贪婪的属性。这里用到？ 。 当?放在了quantifiers符号后，表示去掉贪婪属性，匹配到终止条件，即可停下。 \[.*?\]这样子，就可以将[google]和[test]分开 接下来完成所有内容： 123reg: \[(.*?)\]\((http.*?)\)replace: &lt;a href=&quot;$2&quot;&gt;$1&lt;/a&gt; 1.3.3 使用 \ 选择器$选择符是在替换的时候进行的标志或选择，但是如果在正则表达式本身，就要使用\选择了。比如以下的场景 12This is is a a dog , I think think this is is reallya a good good dog. Don&apos;t you you thinks so so ? 我们想要匹配比如is is so so这样连续的序列，就用到了下面的表达方式: (\w+)\s\1 嗯，差不多达到效果，但是有一些小的bug。比如第一句话This is is a 这个就匹配不准确，会把第一个This的后面字母匹配进去。 这就用到第一节说的字符结界 \b了，就变成了\b(\w+)\s\1\b 好了，大功告成，就不贴效果图了，自行脑补就好了。 1.3.4 总结 分组捕获，使用()进行数据分组，编号0代表整个匹配项，选择的分组从1号开始 选择器可以使用$1和\1，但是使用场景不同，\用在正则表达式自己身上 ?符号可以禁止贪婪属性，放在.*之后，表示一次匹配遇到重点就可以停止。否则将会一直向后匹配。 1.4 在JavaScript中的应用这里就不贴了, 若需要查看 ,请参考 作者文章]]></content>
      <categories>
        <category>regex</category>
      </categories>
      <tags>
        <tag>regex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx之proxy_pass详解]]></title>
    <url>%2Fnginx-proxy_pass%2F</url>
    <content type="text"><![CDATA[记录下 Nginx proxy_pass 常用规则 , 以免遗忘 在 Nginx 中配置 proxy_pass 代理转发时 , 如果在 proxy_pass 后面的 url 加 / ,表示绝对路径 ; 如果没有 / , 表示相对路径 , 把匹配的路径部分也会代理走 实例假设以下四种情况分别用 http://192.168.1.1/proxy/test.html 进行访问 1123location /proxy/ &#123; proxy_pass http://127.0.0.1/;&#125; 代理到 URL: http://127.0.0.1/test.html 2相对第一种 , 尾部少个 / 123location /proxy/ &#123; proxy_pass http://127.0.0.1;&#125; 代理到 URL: http://127.0.0.1/proxy/test.html 3123location /proxy/ &#123; proxy_pass http://127.0.0.1/aaa/;&#125; 代理到 URL: http://127.0.0.1/aaa/test.html 4相对第三种 , 末尾少个 / 123location /proxy/ &#123; proxy_pass http://127.0.0.1/aaa;&#125; 代理到 URL: http://127.0.0.1/aaatest.html 参考链接简书]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[App中的羊角符]]></title>
    <url>%2Fcny-symbol-issue%2F</url>
    <content type="text"><![CDATA[人民币羊角符是 App 开发中常使用的符号 . 在使用中却偶发觉符号显示不正常 , 在此做记录 两种羊角符人民币羊角符 人民币符号为：¥。书写顺序为：先写大写字母“Y”，再在竖划上加上二横，即为“¥”，读音为：yuán（音：元） 日元羊角符 日圆（円），又称作日元，其纸币称为日本银行券，是日本的官方货币，于1871年制定。日圆也经常在美元和欧元之后被当作储备货币。货币符号“¥”，国际标准化组织ISO4217订定其标准代号为JPY。日语罗马字写作Yen。 从定义上看 , 两种羊角符长得一样 , 手写是没有区别的 . 但是在计算机上是有区别的 1￥¥ 若看不出区别 , 可以复制到浏览器中再看看 二者在 UTF-8 表中的区别 前者是全角元 , 后者是半角元 . 二者在不同的机型上表现不一致 , 全角元在某些机型上只显示一横 , 而半角元都是两横 , 因此实际开发中应该使用半角元 参考链接CSDN: Android中的羊角符 CSDN: 如何解决羊角符只显示一横的问题]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>App</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转-win10系统端口占用查看]]></title>
    <url>%2Fwin10-port-issue%2F</url>
    <content type="text"><![CDATA[最近win10电脑重启后总是有进程占用端口 , 使得科学上网软件自启时报错 , 这里记录下解决过程 管理员打开 cmd 输入netstat -aon|findstr 8080命令 , 其中8080是被占用的端口号 , 在显示的信息中找到占用端口的进程号PID 输入tasklist|findstr 2524 其中2524是第二步中找出的进程号 打开任务管理器 , 找到对应进程的应用,结束掉进程即可 原文链接度娘]]></content>
      <categories>
        <category>Issue</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter研发报错归整]]></title>
    <url>%2Fflutter-issue%2F</url>
    <content type="text"><![CDATA[记录一些 Flutter 研发中遇到错误及处理. 1. Unexpected end of file from server在新环境安装好 Flutter 环境后 , 运行项目报错 Exception in thread &quot;main&quot; java.net.SocketException: Unexpected end of file from server 搜索后发现是因为 gradle 设置了代理 . 前往 C:/Users/&lt;username&gt;/.gradle/gradle.properties ) (不是项目下的gradle.properties) , 删除多余的代理设置 systemProp.https.proxyPort=1080 … 参考链接简书: 解决Flutter报错 Unexpected… 2. Waiting for another flutter command to release the startup lock…在安装依赖时 , 偶尔出现 Waiting for another flutter command to release the startup lock... , 通常是上一个命令还未执行完毕 , 但是因为墙的原因可能继续等待也未必成功 . 想要终止等待状态 , 需要前往 flutter 安装目录下删除 bin/cache/lockfile 文件即可 . 若显示该文件被使用中无法删除 , 则先杀死 dart 进程再删除即可 12345// Linuxkillall -9 dart// Windowstaskkill /F /IM dart.exe 参考链接知乎]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ElementUI组件修改样式覆盖无效]]></title>
    <url>%2Felement-ui-style-issue%2F</url>
    <content type="text"><![CDATA[在使用ElementUI组件库开发时往往会需要对组件进行样式修改 , 为了 Vue 页面样式模块化 , 不对全局样式造成污染 , 我们往往都会加入 scoped 属性用来限制样式的作用域 , 然后这也会导致当我们修改部分 UI 组件样式失效. 为了避免这种问题 , 我们常用以下方式来解决 1. 深度作用选择器&gt;&gt;&gt; 12345&lt;style scoped&gt;.box &gt;&gt;&gt; .content &#123; font-size:20px;&#125;&lt;/style&gt; 2. /deep/ 预处理器 less 下使用深度选择器 /deep/ 与 &gt;&gt;&gt; 作用相同 通过 &gt;&gt;&gt; 可以使得在使用 scoped 属性的情况下 , 穿透 scoped , 修改其他组件的值 1234567&lt;style scoped lang="less"&gt;.select &#123; /deep/ .ivu-card-body &#123; width: 100%; &#125; &#125;&lt;/style&gt; 参考链接CSDN:elementUI组件修改样式 覆盖无效]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker常用命令]]></title>
    <url>%2Fdocker-command%2F</url>
    <content type="text"><![CDATA[很多实用的 Docker 命令经常不记得 , 记录于此 列出所有容器ID 1docker ps -aq 停止所有容器 1docker stop $(docker ps -aq) 删除所有容器 1docker rm $(docker ps -aq) 删除所有不使用的镜像 1docker image prune --force --all 删除所有停止的容器 1docker container prune -f 清理资源命令 1docker system prune 删除 exited 状态容器 1docker rm $(docker ps --all -q -f status=exited) 有待继续补充 参考链接停止、删除所有的docker容器和镜像]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Element-UI Uploader上传达到数量后隐藏上传按钮]]></title>
    <url>%2Felement-ui-uploader-issue%2F</url>
    <content type="text"><![CDATA[在项目中使用到了 Element UI 的 Uploader 组件 . 需求是达到上传文件上限后 , 将组件的添加图片按钮隐藏. 首先给 el-upload 组件增加 class 123&lt;el-upload :class="&#123;hide:hideUpload&#125;" :on-change="handleImgChange"&gt; 然后 data 里面设定一个初始状态值 1hideUpload: false 再在组件中绑定一个 on-change 事件 , handleImgChange 123handleImgChange(file, fileList) &#123; this.hideUpload = this.vouchers.length &gt;= this.limitCount;&#125; css 部分 123.hide .el-upload--picture-card &#123; display: none;&#125; 这样就可以实现上传按钮的显示隐藏了. 注意 , Vue 中需要将 style 中的 scoped去掉方可生效 , 或者增加层级前缀 123/deep/ .hide .el-upload--picture-card &#123; display: none;&#125; 参考链接CSDN:Element UI上传图片到达一定数量后隐藏图片上传按钮]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>ElementUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis-Plus IndexOutOfBoundsException]]></title>
    <url>%2Fmybatis-plus-exception%2F</url>
    <content type="text"><![CDATA[最近在使用 MyBatis-Plus 时遇到了 java.lang.IndexOutOfBoundsExceptin .折腾许久 , 记录于此 初看以为真是数组越界错误 , 但是执行一个普通的 select 语句都会报错 . 最终搜索到了原因 , 主要是因为 lombok 使用不当! 实体类用了 @Builder 注解 , 在使用该注解后 , 我们必须显示地声明构造方法 , 或者使用@AllArgsConstructor 或 @NoArgsConstructor 来声明构造 . 由于 MyBatis 找不到构造方法 , 无法将查询结果绑定到实体对象上 ,导致报错 . 参考链接 mybatis-plus java.lang.IndexOutOfBoundsException: Index: 23, Size: 23 mybatis issue]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>MyBatis-Plus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA项目在maven projects中显示灰色的解决办法]]></title>
    <url>%2Fidea-maven-issue%2F</url>
    <content type="text"><![CDATA[最近在 maven 项目将一个子 module 删除重新创建后 , 有依赖关系的 module 编译就会报错 , 表现则为 maven 模块变为灰色. 以上图来自参考链接 造成这个原因应该是删除 module 后 IDEA 忽略了该 maven 模块 解决办法 在 IDEA 中 maven 的 setting 中找到 ignored files , 看右边的面板中是否将变灰的maven模块忽略了.Settings–&gt;Maven–&gt;Ignored Files 去掉勾选 参考链接 CSDN:idea项目在maven projects中显示灰色的解决办法]]></content>
      <categories>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac设置Office语言]]></title>
    <url>%2Foffice-mac-language%2F</url>
    <content type="text"><![CDATA[最近使用Office的时候发现了一个问题 , 由于电脑系统语言为英文 , Office 也会自动切换为英文 . 想单独设置 Office为中文版 , 搜索了一圈 , 发现网上的方法太多不可用或者要修改系统语言 , 最后找到了相关解决办法. 设置其实很简单 , 打开终端 , 输入命令 defaults write com.microsoft.Word AppleLanguages &#39;(&quot;zh-cn&quot;)&#39; 重启应用即可 附加 如果还有其他 Office 应用需要修改 ,修改命令包名即可 defaults write com.microsoft.Excel AppleLanguages &#39;(&quot;zh-cn&quot;)&#39; 修改成其他语言 修改对应的语言代号即可 , 语言代码与国家地区对照表 参考链接 https://blog.csdn.net/student9128/article/details/80026645 https://www.jianshu.com/p/96f930d2ffca]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins前后端项目参数化自动构建]]></title>
    <url>%2Fjenkins-parameterized-build%2F</url>
    <content type="text"><![CDATA[最近进行了一次开发测试环境迁移 , 顺带连着之前的 Jenkins 也进行了迁移 , 因为对之前的搭建过程没有记录 , 导致这次的迁移过程中遇到了不少阻力 . 现记录主要流程于此 , 方便之后搭建 . 安装首先我们需要安装 Jenkins , 需要装卸方便 , 因此我们选择用 Docker 或 docker-compose 直接安装 Docker 1docker run --name devops-jenkins --user=root -p 8080:8080 -p 50000:50000 -v /mnt/data/jenkins/jenkins_home:/var/jenkins_home -d jenkins/jenkins:lts docker-compose 1234567891011121314151617version: '3'services: jenkins: image: jenkins/jenkins:lts container_name: jenkins user: root ports: - "8080:8080" volumes: - /etc/localtime:/etc/localtime:ro - $PWD/jenkins_home:/var/jenkins_home - /var/run/docker.sock:/var/run/docker.sock - /usr/bin/docker:/usr/bin/docker - /usr/lib64/libltdl.so.7:/usr/lib/x86_64-linux-gnu/libltdl.so.7 - /mnt/data/docker:/data/docker environment: - TZ=Asia/Shanghai 启动后初始化及安装推荐插件 可以通过容器日志查询初始密码 1docker logs xxx(容器ID) 可能部分插件超时安装失败 , 我们需要去网站上下载 hpi 插件文件 , 手动上传安装 本文用到一些重要的插件列举如下: Http Request http请求插件 Publish Over SSH 文件上传部署插件 Docker docker插件 Role-based Authorization Strategy 角色权限插件 Build-user-vars-plugin 构建角色变量插件 Beary Chat 协作工具通知插件(视实际情况进行替换) … 系统配置点击系统管理 -&gt; Global Tool Configuration 找到 JDK 点击新增按钮进行安装 , 此处需要 Oracle 账号请自行注册 然后找到 Maven 点击新增按钮 , 此处我们使用 3.2.5 视具体情况进行替换 , 笔者是因为选择其他版本编译项目会报错 . 点击系统管理 -&gt; 系统设置 配置 SSH (前端nginx服务器) 权限分配选择系统管理 -&gt; Configuration Global Security 启用安全： TCP port for JNLP agents -&gt;禁用，访问控制-安全域-&gt;jenkins专有用户数据库 , 访问控制-授权策略-&gt;Role-Based Strategy 如： 选择系统管理 Manage and Assign Roles -&gt; Manage Roles 此处针对项目配置权限 , 以项目名正则匹配 . 这里提供几个例子 ^((?!other).)*$ 项目名中不带 other 的均符合 [\w\W]*frontend[\w\W] 项目名中间有 frontend 的均符合 [\w\W]* 任意项目名均符合 前端场景说明这里针对 前端 Vue 项目进行构建 . 前端开发人员会本地进行打包 , 得到一个 dist.zip 压缩包 , 此时需要上传到 nginx 服务器上 , 自动解压 . 当然有更好的做法 , 直接在服务器上拉取代码 , 编译 , 部署 , 此处我们只讲解打包后通过 Jenkins 上传的流程 . 123456# 视具体情况进行替换cd /mnt/data/frontend/$MODULEsudo rm -rf latest.zipsudo rm -rf distunzip pack.zipmv pack.zip latest.zip 后端后端是使用 Java Spring Cloud 项目. 开发者在 Jenkins 指定对应环境、参数然后就会开始构建 , 过程大致为 选择参数构建 -&gt; Jenkins 从 Git 上拉取代码 -&gt; Maven构建 -&gt; Docker构建镜像 -&gt; 推送到私有镜像仓库 -&gt; 通知 Rancher 集群更新服务 -&gt; 通知协作工具 / 邮件通知 首先确定构建参数 Execute Shell 12345678910111213docker login --username=仓库USERNAME --password=仓库PASSWORD $DOCKER_REGISTRYcp $WORKSPACE/$MODULE_NAME/target/*.jar $WORKSPACE/$MODULE_NAME/app.jarcd $WORKSPACE/$MODULE_NAMEdocker build -f Dockerfile-$ENV -t $DOCKER_REGISTRY/$DOCKER_NAMESPACE/$MODULE_NAME:latest .docker build -f Dockerfile-$ENV -t $DOCKER_REGISTRY/$DOCKER_NAMESPACE/$MODULE_NAME:$DOCKER_TAG .docker push $DOCKER_REGISTRY/$DOCKER_NAMESPACE/$MODULE_NAME:latestdocker push $DOCKER_REGISTRY/$DOCKER_NAMESPACE/$MODULE_NAME:$DOCKER_TAGdocker rmi $DOCKER_REGISTRY/$DOCKER_NAMESPACE/$MODULE_NAME:latestif [ $&#123;DOCKER_TAG&#125; != "latest" ]; then docker rmi $DOCKER_REGISTRY/$DOCKER_NAMESPACE/$MODULE_NAME:$DOCKER_TAGfi 然后再通过构建后操作使用 Http Request 插件调用接口升级 Rancher 服务 , 具体参考 Rancher通过API升级服务 文章 . 在实际应用中发现 , 此方法升级会覆盖之前的服务主机调度 , 因此对于多机器集群 , 不大适用 参考链接jenkins+docker持续集成]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx出现403 Forbidden报错解决办法]]></title>
    <url>%2Fnginx-403-forbidden%2F</url>
    <content type="text"><![CDATA[之前 AWS EC2 上安装 nginx 时 ,访问一直正常 , 直到在物理机和 GCP 上使用时就会出现 403 Forbidden 的情况 , 查看 nginx 日志 , 默认路径为 /var/log/nginx/error.log , 发现报错内容为 Permission denied . 于是谷歌解决办法 . CSDN 此篇文章分析的比较完整 , 现简单总结如下 . 1. 由于启动用户和 nginx 工作用户不一致所致查看命令 ps aux | grep &quot;nginx: worker process&quot; | awk&#39;{print $1}&#39; 如若不一致 , 则要将 nginx.conf 中的 user 改为和启动用户一致 12345678910user nginx;worker_processes 4;error_log /var/log/nginx/error.log warn;pid /var/run/nginx.pid;events &#123; worker_connections 65535;&#125; 2. 缺少 index.html 或者 index.php 文件1234567891011server &#123; listen 80; server_name localhost; index index.php index.html; root /data/www/; &#125; 如果在 /data/www/ 下没有 index.php 或 index.html 时 就会报 403 forbidden 3. 权限问题 , 若 nginx 没有 web 目录的操作权限 , 也会出现403错误解决办法: 修改 web 目录的读写权限 , 或者是把nginx的启动用户改成目录的所属用户 , 重启 nginx 解决 12chmod -R 777 /datachmod -R 777 /data/www/ 4. SELinux 设置为开启的原因查看当前 selinux 状态 cat /etc/selinux/conf 将状态改为disabled 1SELINUX=disabled 重启 reboot 生效]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL简易备份]]></title>
    <url>%2F48.MySQL%E7%AE%80%E6%98%93%E5%A4%87%E4%BB%BD%2F</url>
    <content type="text"><![CDATA[简易的 MySQL 数据全量日备 备份脚本首先确定下目录 123456## 总目录/mnt/data/backups## 内容- mysql-back.list 指定备份数据库名- mysql_backups.sh 备份脚本- mysqldump.log 备份日志 mysql-back.list 123## 备份数据库名test_dbtest_db2 mysql_backups.sh 备份前推20天内的db数据 12345678910111213141516171819202122#!/bin/bash#This replication for Ali RDSPATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:/usr/local/mysql/binexport PATHDAT=`date +%m%d`HOR=`date +%H`begin=`date +%F" "%T`DIR=/mnt/data/backups/dbif [[ ! -d $DIR/$DAT ]];then mkdir $DIR/$DATfifor i in `cat /mnt/data/backups/mysql-back.list`do /bin/mysqldump -uroot -p密码 $i &gt; $DIR/$DAT/$i-$DAT$HOR.sqldonefind /mnt/data/backups/db/* -mtime +20 -exec rm -rf &#123;&#125; \;end=`date +%F" "%T`echo "$begin dump mysql -------&gt; $end has done" &gt;&gt; /mnt/data/backups/mysqldump.log 脚本执行定时任务vim /etc/crontab 123456789101112131415SHELL=/bin/bashPATH=/sbin:/bin:/usr/sbin:/usr/binMAILTO=root# For details see man 4 crontabs# Example of job definition:# .---------------- minute (0 - 59)# | .------------- hour (0 - 23)# | | .---------- day of month (1 - 31)# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# | | | | |# * * * * * user-name command to be executed01 11 * * * root sh /mnt/data/backups/mysql_backups.sh 手动执行bash /mnt/data/backups/mysql_backups.sh Docker 安装的MySQL修改点mysql-backup.sh 1234567891011121314151617181920#!/bin/bashDAT=`date +%m%d`HOR=`date +%H`begin=`date +%F" "%T`PARENT_DIR=/mnt/data/mysql/backupsDIR=$PARENT_DIR/dbif [[ ! -d $DIR/$DAT ]];then mkdir $DIR/$DATfifor i in `cat $PARENT_DIR/mysql-back.list`do docker exec mysql容器名 mysqldump -uroot -p数据库密码 $i &gt; $DIR/$DAT/$i-$DAT$HOR.sqldonefind $DIR/* -mtime +20 -exec rm -rf &#123;&#125; \;end=`date +%F" "%T`echo "$begin dump mysql -------&gt; $end has done" &gt;&gt; $PARENT_DIR/mysqldump.log /etc/crontab 每天 2:00 备份 10 2 * * * sh /mnt/data/mysql/backups/mysql-backup.sh &gt;&gt;/mnt/data/mysql/backups/checkES.log 2&gt;&amp;1]]></content>
      <categories>
        <category>Script</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker部署区块链节点]]></title>
    <url>%2Fdocker-ethereum-rinkeby%2F</url>
    <content type="text"><![CDATA[EthereumRinkeby1docker run -it -d --name ethereum-node -p 8545:8545 -p 30303:30303 -v /mnt/data/ethereum:/root/.ethereum ethereum/client-go --rinkeby --rpc --rpcaddr "0.0.0.0"]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Ethereum</tag>
        <tag>Bitcoin</tag>
        <tag>Docker</tag>
        <tag>BlockChain</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hystrix Dashboard 断路器监控]]></title>
    <url>%2Fhystrix-dashboard%2F</url>
    <content type="text"><![CDATA[Hystrix Dashboard 是 Hystrix 提供的一个可以查看 Hystrix 监控数据的控制面板 . Hystrix提供了近实时的数据监控 , Hystrix 会实时、累加的记录所有关于 HystrixCommand 的执行信息 , 包括每秒执行多少请求 , 多少成功和多少失败等. 创建 Hystrix Dashboard 工程依赖 pom.xml 123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt; &lt;/dependency&gt; application.yml 123456789server: port: 13000spring: application: name: dashboard cloud: consul: discovery: service-name: $&#123;spring.application.name&#125; 启动类增加注解 12345678910@SpringBootApplication@EnableDiscoveryClient@EnableHystrixDashboardpublic class HystrixDashboardApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(HystrixDashboardApplication.class, args); &#125;&#125; @EnableHystrixDashboard：启动Hystrix Dashboard断路器看板相关配置 启动应用 , 打开浏览器 http://localhost:13000/hystrix 以上便配置好了 Dashboard . 通过主页的文字 , 我们可以知道 Hystrix Dashboard 支持三种不同的监控方式 . 默认的集群监控. 通过 http://turbine-hostname:port/turbine.stream 开启 , 实现对默认集群的监控 指定的集群监控. 通过 http://turbine-hostname:port/turbine.stream?cluster=[clusterName] 开启 , 实现对 clusterName 集群的监控 单体应用的监控 . 实现对具体某个服务实例的监控 . 通过 http://hystrix-app:port/actuator/hystrix.stream Actuator 2.x 以后 endpoints 全部在 /actuator 下 ,可以通过 management.endpoints.web.base-path 修改 被监控服务配置pom.xml 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 为启动类添加 @EnableCircuitBreaker 或@EnableHystrix 注解 , 开启断路器功能 配置文件 application.yml 中添加 12345management: endpoints: web: exposure: include: hystrix.stream management.endpoints.web.exposure.include 这个事用来暴露 endpoints 的 . 由于 endpoints 中会包含很多敏感信息 , 除了 health 和 info 两个支持 web 访问外 , 其他的默认不支持 web 访问 . 详情请参考 50.Endpoints 使用在 Dashboard 主界面输入对应的地址 , 然后点击 Monitor Stream 按钮进入页面 . 然后请求对应服务 , 会出现以下界面 如果在该界面出现报错 Unable to connect to Command Metric Stream. , 可以参考这个 Issue 界面解读 以上图来说明其中各元素的具体含义: 实心圆：它有颜色和大小之分 , 分别代表实例的监控程度和流量大小 . 如上图所示 , 它的健康度从绿色、黄色、橙色、红色递减 . 通过该实心圆的展示 , 我们就可以在大量的实例中快速的发现故障实例和高压力实例 . 曲线：用来记录 2 分钟内流量的相对变化 , 我们可以通过它来观察到流量的上升和下降趋势 . 其他一些数量指标如下图所示 参考链接 Spring Cloud（五）：Hystrix 监控面板【Finchley 版】 CSDN: hystrix-dashboard]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Hystrix</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL连接超时设置]]></title>
    <url>%2Fmysql-settings%2F</url>
    <content type="text"><![CDATA[首先登录数据库 查看连接数show processlist; 可以发现有很多连接处于 Sleep 状态 , 这些连接其实暂时是没有用的 , 可以 kill 掉 查看最大连接数show variables like &quot;max_connections&quot;; 安装 MySQL 8.0 默认值是 151 个, 可以适当进行调整 设置最大连接数set GLOBAL max_connections=1000; 修改最大连接数 , 但是这不是一劳永逸的方法 , 应该要让 MySQL 自动杀死 Sleep 的连接 查看非交互连接超时show global variables like &#39;wait_timeout&#39;; 这个数值指的是 MySQL 在关闭一个非交互的连接之前要等待的描述 , 默认是 28800 s . 修改非交互连接超时set global wait_timeout=300; 笔者尝试将其改为 300 s ,在生产上就会遇到服务突然连接不到数据库的情况 , 报错 Communications link failure... 因此又改回了默认值 . 修改交互连接超时set global interactive_timeout=500; 修改这个数值 , 表示 MySQL 在关闭一个链接之前要等待的秒数 , 至此可以让 MySQL 自动关闭哪些没用的连接 , 但是要注意的是 , 正在使用的连接到了时间也会被关闭 , 因此数值要合适 . 批量Kill连接首先查出来所用 Sleep 连接 id select concat(&#39;KILL &#39;,id,&#39;;&#39;) from information_schema.processlist where user=&#39;root&#39;; copy 出来后替换后复制回终端运行 .再进行查看 参考链接简书]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ERC20批量转账空投智能合约兼容问题]]></title>
    <url>%2Ferc20-smartcontract-compatibility%2F</url>
    <content type="text"><![CDATA[区块链系列许久没有更新了 , 这里更新一篇关于 ERC20 智能合约批量转账(空投)的文章 . 在以太坊开发中 , 免不了会有批量转账(空投)的需求 . 因为 nonce 机制的问题 , 转账的形式明显不智 , 此时我们需要通过智能合约实现 . 通常空投合约我们是在网上找一份 , 然后 Tether USDT 首当其冲成为我们的测试 Token . 在两者合约部署后 , 测试时很可能发现无法空投成功 , 得到 Gas estimation failed...gas required exceeds allowance... 的错误(当然有先 approve 成功) . 于是乎我们去空投合约各种定位问题 , 最终可能也很难发现问题 . 其实这里并不是空投合约自身产生了问题 , 而是一个 Token 合约兼容性的问题 . 接下来我们进入分析 . 过程分析首先是先 copy 一份 Tether USDT 的合约源码进行部署 , 这里我们选择 Rinkeby 测试网络 , 过程略过 . 然后我们再部署空投合约 . 笔者最初是在以下空投合约基础上选择后进行了修改 , 然后部署 . multisender Token-BulkSender 两者均有演示网站 , 最后笔者选择了 multisender multisender 合约有两个空投方法 multisendEther(address[] _contributors, uint256[] _balances) 空投 ETH multisendToken(address token, address[] _contributors, uint256[] _balances) 空投 ERC20 Token 而在测试中发现 , 空投 Token 的方法无法成功 , 报 `Gas estimation failed...gas required exceeds allowance... 出现这个错误的原因较大的可能是合约中 require() 断言条件 , 或者直接触发了其他失败的断言 . 12345678910111213141516function multisendToken(address token, address[] _contributors, uint256[] _balances) public hasFee payable &#123; if (token == 0x000000000000000000000000000000000000bEEF)&#123; multisendEther(_contributors, _balances); &#125; else &#123; uint256 total = 0; require(_contributors.length &lt;= arrayLimit()); ERC20 erc20token = ERC20(token); uint8 i = 0; for (i; i &lt; _contributors.length; i++) &#123; erc20token.transferFrom(msg.sender, _contributors[i], _balances[i]); total += _balances[i]; &#125; setTxCount(msg.sender, txCount(msg.sender).add(1)); emit Multisended(total, token); &#125;&#125; 这里贴一下合约此函数的完整实现 , 测试中基本上显式断言都是满足的 , 这里就只可能是 erc20token.transferFrom(...) 触发了失败 . 经过一番定位发现 , 根本原因是 Tether USDT 未严格遵循 ERC20 标准 , transferFrom 方法未返回 bool 值 , 而 solidity 编译器在 0.4.22 版本之后对于这种情况会发生 revert. 而对于 0.4.22 之前的版本 , 当外部合约调用没有返回值的 transfer 和 transferFrom , 外部合约还是会在内存中查询函数的返回值 . 由于没有真正的返回值 , 外部调用合约返回值本应在内存中存储对应的位置查找 , 将查到的数据作为返回值 . 实际上 , 查询到的返回值并不是函数的返回值 , 通常是一个大于 0 的值 , 外部调用合约将其视为 true . 因为根据 EVM 的内存布局, 函数调用数据（call data）与函数返回数据（return data）是共同使用一块内存区域, 如果 transfer() 函数没有调用 RETURN 指令返回任何值, 那么如果调用者去用 RETURNDATACOPY 来取返回值的时候, 会将内存中的脏数据取回. 脏数据的值很大概率会为 非零值, 这在EVM里面代表 “true”. 但是这里请注意, 脏数据也很有可能是 零, 代表 “false”. 这就意味着: 即使token合约正常完成了转账, 但是却返回 “false”, 导致外部的 DAPP 误认为转账没有成功, 进而可能引发安全漏洞. 这里建议查看 数千份以太坊 Token 合约不兼容问题浮出水面, 严重影响 DAPP 生态 , 文章有详细的说明 . 解决方案对于这种不兼容 , 我们该如何应对 ? Token 方重新发布合约 DAPP 开发者需要同一个安全的调用代码来访问各种不兼容的 ERC20 Token 合约 以太坊硬分叉升级 虽然我们认为第一种方案是能彻底解决这一部兼容性问题带来的安全风险 , 但是可行性不高 .第三种近期难以得到妥善解决 . 最终只能从方案二开始着手 , 我们需要采用下面的代码片段作为调用 transfer 或tranferFrom 等的中间层代码 : 12345678910111213141516171819202122232425262728library ERC20AsmTransfer &#123; function asmTransfer(address _erc20Addr, address _to, uint256 _value) internal returns (bool result) &#123;​ // Must be a contract addr first! assembly &#123; if iszero(extcodesize(_erc20Addr)) &#123; revert(0, 0) &#125; &#125; // call return false when something wrong require(_erc20Addr.call(bytes4(keccak256(&quot;transfer(address,uint256)&quot;)), _to, _value)); // handle returndata assembly &#123; switch returndatasize() case 0 &#123; // not a std erc20 result := not(0) &#125; case 32 &#123; // std erc20 returndatacopy(0, 0, 32) result := mload(0) &#125; default &#123; // anything else, should revert for safety revert(0, 0) &#125; &#125; return result; &#125;&#125; 这段代码使用 call 方法手动直接调用 transfer()函数, 并使用内联 assembly code 手动获取 returndatasize() 进行判断. 如果为 0, 则表明被调用 ERC20 合约正常执行完毕, 但没有返回值, 即转账成功；如果为 32, 则表明ERC20合约符合标准, 直接进行 returndatacopy() 操作, 调用 mload() 拿到返回值进行判断即可；如果为其他值则 revert. 封装成函数替代 transfer 使用. 完整的中间层代码可以参考 SECBIT 实验室的仓库 badERC20Fix 另外这里附上修改后的 multisender 源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476pragma solidity ^0.4.24;library ERC20AsmFn &#123; function isContract(address addr) internal view &#123; assembly &#123; if iszero(extcodesize(addr)) &#123; revert(0, 0) &#125; &#125; &#125; function handleReturnData() internal pure returns (bool result) &#123; assembly &#123; switch returndatasize() case 0 &#123; // not a std erc20 result := 1 &#125; case 32 &#123; // std erc20 returndatacopy(0, 0, 32) result := mload(0) &#125; default &#123; // anything else, should revert for safety revert(0, 0) &#125; &#125; &#125; function asmTransfer(address _erc20Addr, address _to, uint256 _value) internal returns (bool result) &#123; // Must be a contract addr first! isContract(_erc20Addr); // call return false when something wrong require(_erc20Addr.call(bytes4(keccak256(&quot;transfer(address,uint256)&quot;)), _to, _value)); // handle returndata return handleReturnData(); &#125; function asmTransferFrom(address _erc20Addr, address _from, address _to, uint256 _value) internal returns (bool result) &#123; // Must be a contract addr first! isContract(_erc20Addr); // call return false when something wrong require(_erc20Addr.call(bytes4(keccak256(&quot;transferFrom(address,address,uint256)&quot;)), _from, _to, _value)); // handle returndata return handleReturnData(); &#125; function asmApprove(address _erc20Addr, address _spender, uint256 _value) internal returns (bool result) &#123; // Must be a contract addr first! isContract(_erc20Addr); // call return false when something wrong require(_erc20Addr.call(bytes4(keccak256(&quot;approve(address,uint256)&quot;)), _spender, _value)); // handle returndata return handleReturnData(); &#125;&#125;interface ERC20 &#123; function balanceOf(address who) external view returns (uint256); function transfer(address _to, uint256 _value) external returns (bool success); function transferFrom(address _from, address _to, uint256 _value) external returns (bool success); function approve(address _spender, uint256 _value) external returns (bool success);&#125;contract TestERC20AsmTransfer &#123; using ERC20AsmFn for ERC20; function dexTestTransfer(address _token, address _to, uint256 _value) public &#123; require(ERC20(_token).asmTransfer(_to, _value)); &#125; function dexTestTransferFrom(address _token, address _from, address _to, uint256 _value) public &#123; require(ERC20(_token).asmTransferFrom(_from, _to, _value)); &#125; function dexTestApprove(address _token, address _spender, uint256 _value) public &#123; require(ERC20(_token).asmApprove(_spender, _value)); &#125;&#125;// File: contracts/EternalStorage.sol// Roman Storm Multi Sender// To Use this Dapp: https://rstormsf.github.io/multisenderpragma solidity 0.4.24;/** * @title EternalStorage * @dev This contract holds all the necessary state variables to carry out the storage of any contract. */contract EternalStorage &#123; mapping(bytes32 =&gt; uint256) internal uintStorage; mapping(bytes32 =&gt; string) internal stringStorage; mapping(bytes32 =&gt; address) internal addressStorage; mapping(bytes32 =&gt; bytes) internal bytesStorage; mapping(bytes32 =&gt; bool) internal boolStorage; mapping(bytes32 =&gt; int256) internal intStorage;&#125;// File: contracts/UpgradeabilityOwnerStorage.sol// Roman Storm Multi Sender// To Use this Dapp: https://rstormsf.github.io/multisenderpragma solidity 0.4.24;/** * @title UpgradeabilityOwnerStorage * @dev This contract keeps track of the upgradeability owner */contract UpgradeabilityOwnerStorage &#123; // Owner of the contract address private _upgradeabilityOwner; /** * @dev Tells the address of the owner * @return the address of the owner */ function upgradeabilityOwner() public view returns (address) &#123; return _upgradeabilityOwner; &#125; /** * @dev Sets the address of the owner */ function setUpgradeabilityOwner(address newUpgradeabilityOwner) internal &#123; _upgradeabilityOwner = newUpgradeabilityOwner; &#125;&#125;// File: contracts/UpgradeabilityStorage.sol// Roman Storm Multi Sender// To Use this Dapp: https://rstormsf.github.io/multisenderpragma solidity 0.4.24;/** * @title UpgradeabilityStorage * @dev This contract holds all the necessary state variables to support the upgrade functionality */contract UpgradeabilityStorage &#123; // Version name of the current implementation string internal _version; // Address of the current implementation address internal _implementation; /** * @dev Tells the version name of the current implementation * @return string representing the name of the current version */ function version() public view returns (string) &#123; return _version; &#125; /** * @dev Tells the address of the current implementation * @return address of the current implementation */ function implementation() public view returns (address) &#123; return _implementation; &#125;&#125;// File: contracts/OwnedUpgradeabilityStorage.sol// Roman Storm Multi Sender// To Use this Dapp: https://rstormsf.github.io/multisenderpragma solidity &gt;=0.4.24;/** * @title OwnedUpgradeabilityStorage * @dev This is the storage necessary to perform upgradeable contracts. * This means, required state variables for upgradeability purpose and eternal storage per se. */contract OwnedUpgradeabilityStorage is UpgradeabilityOwnerStorage, UpgradeabilityStorage, EternalStorage &#123;&#125;// File: contracts/SafeMath.sol// Roman Storm Multi Sender// To Use this Dapp: https://rstormsf.github.io/multisenderpragma solidity 0.4.24;/** * @title SafeMath * @dev Math operations with safety checks that throw on error */library SafeMath &#123; /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) &#123; if (a == 0) &#123; return 0; &#125; uint256 c = a * b; assert(c / a == b); return c; &#125; /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) &#123; // assert(b &gt; 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn&apos;t hold return c; &#125; /** * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) &#123; assert(b &lt;= a); return a - b; &#125; /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) &#123; uint256 c = a + b; assert(c &gt;= a); return c; &#125;&#125;// File: contracts/multisender/Ownable.sol// Roman Storm Multi Sender// To Use this Dapp: https://rstormsf.github.io/multisenderpragma solidity 0.4.24;/** * @title Ownable * @dev This contract has an owner address providing basic authorization control */contract Ownable is EternalStorage &#123; /** * @dev Event to show ownership has been transferred * @param previousOwner representing the address of the previous owner * @param newOwner representing the address of the new owner */ event OwnershipTransferred(address previousOwner, address newOwner); /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() &#123; require(msg.sender == owner()); _; &#125; /** * @dev Tells the address of the owner * @return the address of the owner */ function owner() public view returns (address) &#123; return addressStorage[keccak256(&quot;owner&quot;)]; &#125; /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner the address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner &#123; require(newOwner != address(0)); setOwner(newOwner); &#125; /** * @dev Sets a new owner address */ function setOwner(address newOwner) internal &#123; emit OwnershipTransferred(owner(), newOwner); addressStorage[keccak256(&quot;owner&quot;)] = newOwner; &#125;&#125;// File: contracts/multisender/Claimable.sol// Roman Storm Multi Sender// To Use this Dapp: https://rstormsf.github.io/multisenderpragma solidity 0.4.24;/** * @title Claimable * @dev Extension for the Ownable contract, where the ownership needs to be claimed. * This allows the new owner to accept the transfer. */contract Claimable is EternalStorage, Ownable &#123; function pendingOwner() public view returns (address) &#123; return addressStorage[keccak256(&quot;pendingOwner&quot;)]; &#125; /** * @dev Modifier throws if called by any account other than the pendingOwner. */ modifier onlyPendingOwner() &#123; require(msg.sender == pendingOwner()); _; &#125; /** * @dev Allows the current owner to set the pendingOwner address. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner &#123; require(newOwner != address(0)); addressStorage[keccak256(&quot;pendingOwner&quot;)] = newOwner; &#125; /** * @dev Allows the pendingOwner address to finalize the transfer. */ function claimOwnership() public onlyPendingOwner &#123; emit OwnershipTransferred(owner(), pendingOwner()); addressStorage[keccak256(&quot;owner&quot;)] = addressStorage[keccak256(&quot;pendingOwner&quot;)]; addressStorage[keccak256(&quot;pendingOwner&quot;)] = address(0); &#125;&#125;// File: contracts/multisender/UpgradebleStormSender.sol// Roman Storm Multi Sender// To Use this Dapp: https://rstormsf.github.io/multisenderpragma solidity 0.4.24;contract UpgradebleStormSender is OwnedUpgradeabilityStorage, Claimable &#123; using SafeMath for uint256; using ERC20AsmFn for ERC20; event Multisended(uint256 total, address tokenAddress); event ClaimedTokens(address token, address owner, uint256 balance); modifier hasFee() &#123; if (currentFee(msg.sender) &gt; 0) &#123; require(msg.value &gt;= currentFee(msg.sender)); &#125; _; &#125; function() public payable &#123;&#125; function initialize(address _owner) public &#123; require(!initialized()); setOwner(_owner); setArrayLimit(200); setDiscountStep(0.00005 ether); setFee(0.05 ether); boolStorage[keccak256(&quot;rs_multisender_initialized&quot;)] = true; &#125; function initialized() public view returns (bool) &#123; return boolStorage[keccak256(&quot;rs_multisender_initialized&quot;)]; &#125; function txCount(address customer) public view returns(uint256) &#123; return uintStorage[keccak256(&quot;txCount&quot;, customer)]; &#125; function arrayLimit() public view returns(uint256) &#123; return uintStorage[keccak256(&quot;arrayLimit&quot;)]; &#125; function setArrayLimit(uint256 _newLimit) public onlyOwner &#123; require(_newLimit != 0); uintStorage[keccak256(&quot;arrayLimit&quot;)] = _newLimit; &#125; function discountStep() public view returns(uint256) &#123; return uintStorage[keccak256(&quot;discountStep&quot;)]; &#125; function setDiscountStep(uint256 _newStep) public onlyOwner &#123; require(_newStep != 0); uintStorage[keccak256(&quot;discountStep&quot;)] = _newStep; &#125; function fee() public view returns(uint256) &#123; return uintStorage[keccak256(&quot;fee&quot;)]; &#125; function currentFee(address _customer) public view returns(uint256) &#123; if (fee() &gt; discountRate(msg.sender)) &#123; return fee().sub(discountRate(_customer)); &#125; else &#123; return 0; &#125; &#125; function setFee(uint256 _newStep) public onlyOwner &#123; require(_newStep != 0); uintStorage[keccak256(&quot;fee&quot;)] = _newStep; &#125; function discountRate(address _customer) public view returns(uint256) &#123; uint256 count = txCount(_customer); return count.mul(discountStep()); &#125; function multisendToken(address token, address[] _contributors, uint256[] _balances) public hasFee payable &#123; if (token == 0x000000000000000000000000000000000000bEEF)&#123; multisendEther(_contributors, _balances); &#125; else &#123; uint256 total = 0; require(_contributors.length &lt;= arrayLimit()); ERC20 erc20token = ERC20(token); uint8 i = 0; for (i; i &lt; _contributors.length; i++) &#123; require(erc20token.asmTransferFrom(msg.sender,_contributors[i],_balances[i])); total += _balances[i]; &#125; setTxCount(msg.sender, txCount(msg.sender).add(1)); emit Multisended(total, token); &#125; &#125; function multisendEther(address[] _contributors, uint256[] _balances) public payable &#123; uint256 total = msg.value; uint256 current = currentFee(msg.sender); require(total &gt;= current); require(_contributors.length &lt;= arrayLimit()); total = total.sub(current); uint256 i = 0; for (i; i &lt; _contributors.length; i++) &#123; require(total &gt;= _balances[i]); total = total.sub(_balances[i]); _contributors[i].transfer(_balances[i]); &#125; setTxCount(msg.sender, txCount(msg.sender).add(1)); emit Multisended(msg.value, 0x000000000000000000000000000000000000bEEF); &#125; function claimTokens(address _token) public onlyOwner &#123; if (_token == 0x0) &#123; owner().transfer(address(this).balance); return; &#125; ERC20 erc20token = ERC20(_token); uint256 balance = erc20token.balanceOf(this); require(erc20token.asmTransfer(owner(), balance)); emit ClaimedTokens(_token, owner(), balance); &#125; function setTxCount(address customer, uint256 _txCount) private &#123; uintStorage[keccak256(&quot;txCount&quot;, customer)] = _txCount; &#125;&#125; 参考链接 数千份以太坊 Token 合约不兼容问题浮出水面, 严重影响 DAPP 生态 简书:大坑！以太坊 USDT 没有完全遵循 ERC20 标准 区块链 Dapp 合约调用遇到的问题)]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>Solidity</tag>
        <tag>Smart Contract</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Closure Table-多级关系设计]]></title>
    <url>%2Fmysql-closuretable%2F</url>
    <content type="text"><![CDATA[在系统设计中 , 总会碰到上下级的概念 . 不同场景中 , 层级关系可能会比较复杂 , 这个时候 , 如何设计就非常重要了 场景介绍很多系统都会给用户设计一个层级的关系 , 邀请或者代理即可享受下级带来的红利 , 以达到运营产生裂变的效果 . 这里简单说下常用的数据库设计 方案一: 直接记录父级 id name parent 1 Arthas 0 2 Bill 1 3 Catherine 2 4 Damon 3 5 Finn 3 6 Grabby 3 优点 : 可以很方便地找到用户的上级 可以很方便地找到用户的一层下级 缺点: 查找多层上下级很难处理 方案二: 记录路径 id name Path 1 Arthas 0 2 Bill 0-1 3 Catherine 0-1-2 4 Damon 0-1-2-3 5 Finn 0-1-2-3 6 Grabby 0-1-2-3 总结: 这种设计比较常用 , 但在查询多层时还是比较麻烦 方案三: CLOSURE TABLE常规的用户表 id name parent 1 Arthas 0 2 Bill 1 3 Catherine 2 4 Damon 3 5 Finn 3 6 Grabby 3 关系表 category_tree ancestor descendant distance 1 1 0 1 2 1 2 2 0 1 3 2 2 3 1 3 3 0 1 4 3 2 4 2 3 4 1 4 4 0 1 5 3 2 5 2 3 5 1 5 5 0 1 6 3 2 6 2 3 6 1 6 6 0 ancestor 祖先: 上级的id descendant 子代: 下级的id distance 距离: 子代到祖先中间隔了几级 这三个字段的组合是唯一的 . 因为在树中 , 一条路径可以标识一个节点 , 所以可以直接把它们组合作为主键 . 以表为例 ,节点 6 到它的上级节点 3 的距离为1 在数据库中存储为 ancestor=3,descentant=6,distance=1 到上两级的节点 2 的距离为 2 于是有 ancestor=2,descentant=6,distance=2 . 对于这样的树结构常用的查询都能够很方便的处理 . 相关用法1. 子节点查询12345# 查询id为5的节点的直属子节点：SELECT descendant FROM category_tree WHERE ancestor=5 AND distance=1# 查询所有子节点：SELECT descendant FROM category_tree WHERE ancestor=5 AND distance&gt;0 查询某个上级节点的子节点，换句话说就是查询具有指定上级节点的节点，也就是ancestor字段等于上级节点id即可，第二个距离distance决定了查询的对象是由上级往下那一层的，等于1就是往下一层（直属子节点），大于0就是所有子节点。这两个查询都是一句完成。 2. 路径查询1234567# 查询由根节点到id为10的节点之间的所有节点，按照层级由小到大排序SELECT ancestor FROM category_tree WHERE descendant=10 ORDER BY distance DESC# 查询id为10的节点（含）到id为3的节点（不含）之间的所有节点，按照层级由小到大排序SELECT ancestor FROM category_tree WHERE descendant=10 AND distance&lt;(SELECT distance FROM category_tree WHERE descendant=10 AND ancestor=3) ORDER BY distance DESC 查询路径，只需要知道descendant即可，因为descendant字段所在的行就是记录这个节点与其上级节点的关系。如果要过滤掉一些则可以限制distance的值。 3. 查询节点所在的层级(深度)12345# 查询id为5的节点是第几级的SELECT distance FROM category_tree WHERE descendant=5 AND ancestor=0# 查询id为5的节点是id为10的节点往下第几级SELECT distance FROM category_tree WHERE descendant=5 AND ancestor=10 查询层级（深度）非常简单，因为distance字段就是。直接以上下级的节点id为条件，查询距离即可。 4. 查询某一层所有节点12# 查询所有第三层的节点SELECT descendant FROM category_tree WHERE ancestor=0 AND distance=3 5. 插入插入和移动就不是那么方便了，当一个节点插入到某个父节点下方时，它将具有与父节点相似的路径，然后再加上一个自身连接即可。 所以插入操作需要两条语句，第一条复制父节点的所有记录，并把这些记录的distance加一，因为子节点到每个上级节点的距离都比它的父节点多一。当然descendant也要改成自己的。 12345# 例如把id为10的节点插入到id为5的节点下方（这里用了Mysql的方言）INSERT INTO category_tree(ancestor,descendant,distance) (SELECT ancestor,10,distance+1 FROM category_tree WHERE descendant=5)# 然后就是加入自身连接的记录。INSERT INTO category_tree(ancestor,descendant,distance) VALUES(10,10,0) 6. 删除12# 删除DELETE FROM category_tree WHERE descendant = 6 AND distance != 0 参考链接 基于Closure Table实现分类目录树存储 ClosureTable - 无限极分类解决方案)]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rancher通过API升级服务]]></title>
    <url>%2Francher-upgrade-service%2F</url>
    <content type="text"><![CDATA[最近的项目基本采用容器化部署, 由 Rancher 统一编排 . 在持续过程建设中 , 由于我们代码是托管在 腾讯开发者平台 不在 Rancher 默认支持范围内 , 在持续构建过程中 , 最后一步更新服务始终只能手动去 Rancher UI 点击升级 , 甚是繁琐 . 本篇将讲述如何通过API升级服务 如若环境支持 , 使用 Rancher 自身的流水线部署其实是很方便的 , 默认支持以下几种托管仓库 . 持续构建流程首先说一下项目目前持续集成的整体流程 1. Jenkins 参数选择构建 然后 Jenkins 会去仓库拉取代码 , 编译 , 打包镜像然后上传到私有镜像仓库 2. 更新Rancher服务 目前是在 Jenkins 构建后手动去 Rancher UI 上点击升级服务 , 比较繁琐 , 因此要将此步骤自动化 , 通过调用 Rancher API 实现. Rancher 4个主要 API 分别是 12345678# 1.获取一个服务的详细信息GET https://&lt;rancher_server&gt;/v3/project/&lt;project_id&gt;/workloads/deployment:&lt;rancher_namespace&gt;:&lt;rancher_service&gt; # 2.获取服务的所有容器信息GET https://&lt;rancher_server&gt;/v3/project/&lt;project_id&gt;/pods/?workloadId=deployment:&lt;rancher_namespace&gt;:&lt;rancher_service&gt; # 3.根据容器名删除容器DELETE https://&lt;rancher_server&gt;/v3/project/&lt;project_id&gt;/pods/&lt;rancher_namespace&gt;:&lt;container_name&gt; # 4.更新服务PUT https://&lt;rancher_server&gt;/v3/project/&lt;project_id&gt;/workloads/deployment:&lt;rancher_namespace&gt;:&lt;rancher_service&gt; 我们这里用到的是 1 和 4 变量参数通过 Rancher 中查询获得 , 在实践中发现, 直接拿到获取的服务信息调用 4 更新服务的接口 , 偶尔服务不会更新 , 后面发现需要将参数中的时间戳进行自增 , 方可达到立即升级的效果 . 参考链接Docker+Jenkins+Pipline实现持续集成]]></content>
      <categories>
        <category>Rancher</category>
      </categories>
      <tags>
        <tag>Rancher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大前端常用按钮限流防抖总结]]></title>
    <url>%2Ffrontend-throttling%2F</url>
    <content type="text"><![CDATA[在实际前端项目中, 会有一些场景 , 在用户点击按钮时 ,因手抖等各种原因多次点击 , 重复提交请求 . 因此 , 通常情况下,会要求前后端均做一些限流/防手抖策略 . 这里简单说一下各前端如何去实施的. 防抖和限流是我们再开发过程中常用的优化性能的方式 通常 , 我们会给重要请求的按钮设置限制 , 比如 500ms 只能提交一次 Android (Java)Android 中我们使用 RxBinding 来实现 . 添加依赖 build.gradle 12// 查找对应版本填入implementation "com.jakewharton.rxbinding2:rxbinding:$&#123;version&#125;" RxBind.java 1234567891011121314151617181920public class RxBind &#123; // 默认按钮防手抖时间(ms) public static final long THROTTLE_FIRST = 500; public static Disposable click(View view, Consumer&lt;View&gt; action) &#123; return click(view,action,THROTTLE_FIRST); &#125; public static Disposable click(View view, Consumer&lt;View&gt; action, long delay)&#123; return clicks(view) .throttleFirst(delay, TimeUnit.MILLISECONDS) .subscribe(action); &#125; private static Flowable&lt;View&gt; clicks(@NonNull View view)&#123; return Flowable.create(new ViewClickOnSubscribe(view), BackpressureStrategy.ERROR); &#125;&#125; 调用 1RxBind.click(button, view -&gt; doSomething()); 这里是使用到了 RxJava 中的 throttleFirst 操作符 , 意为事件流的触发距第一次触发需要间隔500ms才能生效. iOS (Swift)iOS (Swift) 中我们通过 RxSwift 来实现 Podfile 1234# 查找对应版本填入pod &apos;RxSwift&apos;, &apos;~&gt; $&#123;version&#125;&apos;# 看需求是否要引用此行pod &apos;RxCocoa&apos;, &apos;~&gt; $&#123;version&#125;&apos; UIButtonExtension.swift 12345678extension UIButton &#123; /// 防重复提交 var click: Observable&lt;Void&gt;&#123; return self.rx.tap .throttle(Config.clickDelay, scheduler: MainScheduler.instance) &#125;&#125; 调用 123456button .click .subscribe(onNext: &#123; [weak self] in self?.doSomething() &#125;) .disposed(by: dispose) 前端(Javascript)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 函数防抖 (只执行最后一次点击) * @param fn * @param delay * @returns &#123;Function&#125; * @constructor */export const Debounce = (fn, t) =&gt; &#123; let delay = t || 500; let timer; console.log(fn) console.log(typeof fn) return function () &#123; let args = arguments; if(timer)&#123; clearTimeout(timer); &#125; timer = setTimeout(() =&gt; &#123; timer = null; fn.apply(this, args); &#125;, delay); &#125;&#125;; /** * 函数节流 * @param fn * @param interval * @returns &#123;Function&#125; * @constructor */export const Throttle = (fn, t) =&gt; &#123; let last; let timer; let interval = t || 500; return function () &#123; let args = arguments; let now = +new Date(); if (last &amp;&amp; now - last &lt; interval) &#123; clearTimeout(timer); timer = setTimeout(() =&gt; &#123; last = now; //fn.apply(this, args); &#125;, interval); &#125; else &#123; last = now; fn.apply(this, args); &#125; &#125;&#125;; 使用: 123456 methods:&#123; getAliyunData:Throttle(function()&#123; ... &#125;,1000),&#125; 在Vue中使用首先定义公共js 1234567891011121314151617181920212223242526272829303132333435363738// 防抖export function _debounce(fn, delay) &#123; var delay = delay || 500; var timer; return function () &#123; var th = this; var args = arguments; if (timer) &#123; clearTimeout(timer); &#125; timer = setTimeout(function () &#123; timer = null; fn.apply(th, args); &#125;, delay); &#125;;&#125;// 节流export function _throttle(fn, interval) &#123; var last; var timer; var interval = interval || 500; return function () &#123; var th = this; var args = arguments; var now = +new Date(); if (last &amp;&amp; now - last &lt; interval) &#123; clearTimeout(timer); timer = setTimeout(function () &#123; last = now; //fn.apply(th, args); &#125;, interval); &#125; else &#123; last = now; fn.apply(th, args); &#125; &#125;&#125; 引用 1import &#123; _debounce &#125; from "@/utils/public"; 调用 123456methods: &#123; // 改变场数 changefield: _debounce(function(_type, index, item) &#123; // do something ... &#125;, 500)&#125; Flutterpubspec.yaml 1rxdart: ^0.22.2 调用示例 123456789101112131415161718import 'package:rxdart/rxdart.dart'; final _counterSubject = BehaviorSubject&lt;int&gt;(); @override void initState() &#123; super.initState(); _counterSubject.throttleTime(Duration(milliseconds: 500)).listen((int i) &#123; print(i); &#125;); &#125;RaisedButton( onPressed: () &#123; _counterSubject.add(1); &#125;, child: Text('Test'),) 参考链接 vue 中使用防抖和节流，防止重复点击或重复上拉加载 Flutter: debounce 避免高频率事件]]></content>
      <categories>
        <category>Android</category>
        <category>iOS</category>
        <category>Javascript</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Throttling</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rancher使用遇到相关问题]]></title>
    <url>%2Francher-issues%2F</url>
    <content type="text"><![CDATA[Rancher 是一个开源的企业级全栈化容器部署及管理平台 Rancher为容器提供一揽子基础架构服务: CNI 兼容的网络服务、存储服务、主机管理、负载均衡、防护墙…… Rancher让上述服务跨越公有云、私有云、虚拟机、物理机环境运行 , 真正实现一键式应用部署和管理 . 在实际部署中使用Rancher2.x , 陆续遇到了不少问题 , 现记录于此. Rancher2.x中文文档 搭建环境有阻碍参考以上官方文档 . 最好Rancher单独一台机器, 独立于Master/ETCD/Worker节点. 清理节点后,再次编辑集群成功不了此时在Rancher上的表现一般是主机显示注册中,有报红错误. 流程上卡住在这里了. 问题起因通常是节点未清理干净 , 需要严格按照 清理节点 步骤清理 . 若仍不行 , 也可将 docker 下目录删除 部署服务后容器间网络无法互通需要检查防火墙或者安全组. 容器无法解析外网域名该情况表现为宿主机器可以ping通外网域名及IP, 而在容器内无法Ping通 , 解析外部域名失败 ,部署的Java服务会报Unknown Host 错误. 此时需要在部署的服务网络选项中加入DNS地址,即可解决]]></content>
      <categories>
        <category>Rancher</category>
      </categories>
      <tags>
        <tag>Rancher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录一次生产请求504排查]]></title>
    <url>%2Fnginx-504onprod%2F</url>
    <content type="text"><![CDATA[最近生产环境上使用公司系统时偶报504超时 , 并且使用起来越来越卡顿 . 于是将排查问题过程记录于此 Linux &amp; NginxLinux查看 Nginx 错误日志 , 发现报错 worker_connections exceed open file resource limit: 1024 此警告的问题是受限于 Linux 的最大文件数限制 环境: CenterOS7.4 + , Amazon Linux 查看进程打开的最大文件数 ulimit -n , 显示1024 修改进程最大可打开文件数 , 打开 /etc/security/limits.conf 文件,在下面添加 1234* soft noproc 65535* hard noproc 65535* soft nofile 65535* hard nofile 65535 这里将最大线程数和文件数限制提到了 65535 想要即时生效 , 需要再输入命令 ulimit -n 65535 NginxLinux 限制修改后, 还需要去调整 Nginx 进程最大可打开文件数 (worker_processes 和 worker_connections) worker_processes : 操作系统启动多少个工作进程运行 Nginx . 通常是 1个 master process 和 n 个 worker process . ps -elf | grep nginx eg: 123456789[root@localhost nginx]# ps -elf | grep nginx4 S root 2203 2031 0 80 0 - 46881 wait 22:18 pts/0 00:00:00 su nginx4 S nginx 2204 2203 0 80 0 - 28877 wait 22:18 pts/0 00:00:00 bash5 S root 2252 1 0 80 0 - 11390 sigsus 22:20 ? 00:00:00 nginx: master process /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf5 S nobody 2291 2252 0 80 0 - 11498 ep_pol 22:23 ? 00:00:00 nginx: worker process5 S nobody 2292 2252 0 80 0 - 11498 ep_pol 22:23 ? 00:00:00 nginx: worker process5 S nobody 2293 2252 0 80 0 - 11498 ep_pol 22:23 ? 00:00:00 nginx: worker process5 S nobody 2294 2252 0 80 0 - 11498 ep_pol 22:23 ? 00:00:00 nginx: worker process0 R root 2312 2299 0 80 0 - 28166 - 22:24 pts/0 00:00:00 grep --color=auto nginx 上图所示即 1个 nginx 主进程 (master process) , 4个 nginx 工作进程 (worker process) . 主进程负责监控端口 , 协调工作进程的工作状态 , 分配工作任务 , 工作进程负责进行任务处理. 一般这个参数要和操作系统的 CPU 内核数成倍数 . worker_connections : 这个属性是指单个工作进程可以允许同时建立外部连接的数量. 无论这个连接是外部主动建立的 , 还是内部建立的. 这里需要注意的是 , 一个工作进程建立一个连接后 , 进程将打开一个文件副本 . 所以这个数量还受操作系统设定的进程最大可打开文件数有关. 修改 nginx 软件级别进程最大可打开文件数 12345678user root root; worker_processes 4; worker_rlimit_nofile 65535;events &#123; use epoll; worker_connections 65535; &#125; nginx -s reload 重启生效 验证是否生效首先使用 ulimit -n 查看系统参数是否已经改变 接下来验证 nginx 是否修改生效 . 在 Linux 系统中 , 所有进程都会有一个临时的核心配置文件描述 , 存放路径在/pro/进程号/limit 首先查看进程 123456789[root@localhost nginx]# ps -elf | grep nginx4 S root 2203 2031 0 80 0 - 46881 wait 22:18 pts/0 00:00:00 su nginx4 S nginx 2204 2203 0 80 0 - 28877 wait 22:18 pts/0 00:00:00 bash5 S root 2252 1 0 80 0 - 11390 sigsus 22:20 ? 00:00:00 nginx: master process /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf5 S nobody 2291 2252 0 80 0 - 11498 ep_pol 22:23 ? 00:00:00 nginx: worker process5 S nobody 2292 2252 0 80 0 - 11498 ep_pol 22:23 ? 00:00:00 nginx: worker process5 S nobody 2293 2252 0 80 0 - 11498 ep_pol 22:23 ? 00:00:00 nginx: worker process5 S nobody 2294 2252 0 80 0 - 11498 ep_pol 22:23 ? 00:00:00 nginx: worker process0 R root 2318 2299 0 80 0 - 28166 - 22:42 pts/0 00:00:00 grep --color=auto nginx 可以看到 nginx 工作进程的进程号分别是 2291 , 2293 , 2293 , 2294 . 我们选择一个进程查看核心配置信息 123456789101112131415161718[root@localhost conf]# cat /proc/2351/limitsLimit Soft Limit Hard Limit UnitsMax cpu time unlimited unlimited secondsMax file size unlimited unlimited bytesMax data size unlimited unlimited bytesMax stack size 8388608 unlimited bytesMax core file size 0 unlimited bytesMax resident set unlimited unlimited bytesMax processes 3829 3829 processesMax open files 65535 65535 filesMax locked memory 65536 65536 bytesMax address space unlimited unlimited bytesMax file locks unlimited unlimited locksMax pending signals 3829 3829 signalsMax msgqueue size 819200 819200 bytesMax nice priority 0 0Max realtime priority 0 0Max realtime timeout unlimited unlimited us 参考链接 修改 Nginx 进程最大可打开文件数 Nginx:worker_connections exceed open file resource limit排错 应用层排查在以上修改后 , 发现使用卡顿的情况明显减少 , 可是504超时问题还是会复现 . 此时基本已确认是前端项目的请求在 nginx 转发到后端服务器时发生的超时 , 后来发现超时只出现在 nginx 转发请求到其中一个网关的过程中 , 因此直接在另外的服务器部署了新网关进行替换 , 暂时未出现过超时了 . 后续持续跟踪…]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无法链接到由docker-compose启动的正在运行的容器问题解决]]></title>
    <url>%2Fdocker-networklink-issue%2F</url>
    <content type="text"><![CDATA[在一次环境部署中 ,发现无法 link 到 已运行的通过 docker-compose 部署的 mongo . 报错 docker: Error response from daemon: Cannot link to /mongo, as it does not belong to the default network 现记录解决方案. 首先通过命令列出所有 docker 网络 . 1docker network ls docker-compose 在运行时会创建一个新的网络 . 例如在我遇到的情况中,是已有一个由 docker-compose 运行的 docker_appnet 的网络 , 后面想通过 docker run xxx 命令链接上 docker_appnet 网络 . 原本我的运行命令是 1234567docker run -d \ --name yapi \ --link mongo:mongo \ --workdir /api/vendors \ -p 3000:3000 \ registry.cn-hangzhou.aliyuncs.com/anoy/yapi \ server/app.js 此时无法正常运行 , 报出文章开头的错误 . 正确的运行命令应该是 12345678docker run -d \ --name yapi \ --link mongo:mongo \ --net docker_appnet \ --workdir /api/vendors \ -p 3000:3000 \ registry.cn-hangzhou.aliyuncs.com/anoy/yapi \ server/app.js 参考链接 无法链接到由docker-compose启动的正在运行的容器]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决Docker容器和宿主机器时间不一致的问题]]></title>
    <url>%2Fdocker-date-with-host%2F</url>
    <content type="text"><![CDATA[之前在 AWS EC2 上部署 docker Java 应用时 , 发现 Java log4j 的打印日志时间和宿主时间不一致 . 应用和宿主均是 CST 时间, 而容器还是 UTC 时区. 网上翻阅了不少解决办法, 现记录于此 . 容器与宿主时间不一致通过 date 命令查看时间 查看主机时间 1date 查看容器时间 1docker exec -it &#123;容器id&#125; date 可以发现 , 时间差了 8 个小时. CST (China Shanghai Time , 东八区时间) UTC (Coordinated Universal Time , 标准时间) 解决方案共享主机的 localtime创建容器的时候指定启动参数 , 挂载 localtime 文件到容器内 (只读) , 保证两者所采用的时区是一致的. 1docker run --name &lt;name&gt; -v /etc/localtime:/etc/localtime:ro 复制主机的 localtime1docker cp /etc/localtime:【容器ID或者NAME】/etc/localtime 创建自定义的 dockerfile创建 dockerfile 文件 , 自定义该镜像的时间格式及时区 123456FROM redisFROM tomcatENV CATALINA_HOME /usr/local/tomcat#设置时区RUN /bin/cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \ &amp;&amp; echo 'Asia/Shanghai' &gt;/etc/timezone \ 生成镜像即可 Issue!!! 然而发现如此操作后 , Java log4j 的时间仍是 UTC 时间 . 网上太多回复止于上面的方法 . log4j 主要是使用 springboot 内嵌的 tomcat 的时间 , 因此需要在制作镜像时进行指定 -Duser.timezone=GMT+8 12345FROM openjdk:8-jdk-alpineVOLUME /tmpARG JAR_FILECOPY $&#123;JAR_FILE&#125; app.jarENTRYPOINT ["java","-jar","-Duser.timezone=GMT+8","/app.jar","--spring.profiles.active=dev"] Ok , 搞定 . 参考链接 关于docker下容器和宿主机器时间不一致的问题]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Date</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决docker alpine缺少字体的问题]]></title>
    <url>%2Falpine-font-issue%2F</url>
    <content type="text"><![CDATA[最近一个项目是用 Rancher 统一部署 , 所有程序均在 Docker 环境下运行 . 其中 Java 底包用的 Alpine , 但是 Alpine 没有自带默认字体 , 造成了一些问题 , 现记录解决方案. Issue遇到的问题是在后台管理系统中导出 Excel 时报空指针 java.lang.NullPointerException at sun.awt.FontConfiguration.getVersion(FontConfiguration.java:1264) 循着调用栈追踪问题 ,发现问题出在 Excel 组件上. Excel 组件试图根据字体大小自动调整单元格宽度 , 当寻找 fontconfig 时找不到, 返回 null . 复制以上报错谷歌 , 可以看到很多 Issue , 可以发现是 Alpine环境缺少对应的包 , 此问题影响所有官方 Alpine 的Java环境. 解决方案1.在项目的 Dockerfile 中进行修改 , 增加以下内容 1ENV LANG en_US.UTF-8RUN apk add --update ttf-dejavu fontconfig &amp;&amp; rm -rf /var/cache/apk/* 通过添加 fontconfig 和一款字体 dejavu , 可以完美解决问题 . 缺点是每次打包都要安装 ttf-dejavu 比较慢 , 因此该方法不推荐 . 2.最好的方法是直接使用打包好的镜像 1FROM frolvlad/alpine-java:jdk8-slim 参考链接 解决docker alpine缺少字体的问题)]]></content>
      <categories>
        <category>JRE</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Alpine</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Amazon Linux 搭建开发环境及常用软件]]></title>
    <url>%2Famazon-linux-build-env%2F</url>
    <content type="text"><![CDATA[本篇记录 AWS EC2 的环境搭建内容 EBS磁盘挂载和卸载参考链接AWS Doc 添加用户参考链接 AWS Doc: 如何将具有 SSH 访问权限的新用户添加到 Amazon EC2 Linux Amazon EC2 密钥对和 Windows 实例 简书: 免密码使用 sudo 和 su CenterOS 7 创建新用户和ssh安全登录配置 chmod u+w /etc/sudoers 先要给予权限才可修改 CenterOS 添加新用户后,若需要 SSH 登录就需要去修改 /etc/ssh/sshd_config 在AllowUsers 后添加用户名, 然后 service sshd restart 重启生效 检索 pem 文件 1ssh-keygen -y -f XX.pem 同步时区123456# 查看时区timedatectl# 设置当前系统为Asia/Shanghai上海时区timedatectl set-timezone Asia/Shanghai# 设置完时区后，强制同步下系统时钟chronyc -a makestep 参考链接 AWS Doc: 为 Linux 实例设置时间 K8S学习笔记之CentOS7集群使用Chrony实现时间同步 JDK1yum list java* 1yum install java-1.8.0-openjdk.x86_64 SSLAWS Doc: 在 Amazon Linux 2 上配置SSL Nginx1. 添加下载源在 /etc/yum.repos.d/ 目录下新建一个 nginx.repo 文件 12345[nginx]name=nginx repobaseurl=http://nginx.org/packages/centos/7/x86_64/gpgcheck=0enabled=1 保存 2. 下载1yum install nginx 3. 启动12345678# 设置开机启动sudo systemctl enable nginx# 启动服务sudo systemctl start nginx# 重启服务sudo systemctl restart nginx# 重新加载，因为一般重新配置之后，不希望重启服务，这时可以使用重新加载sudo systemctl reload nginx 参考链接 Amazon Linux 2 AMI 下 yum 安装 Nginx CentOS 7 下 yum 安装和配置 Nginx Redis1. 安装默认 AWS EC2 上 是没有 redis 源的 , 需要下载 Fedora 的 epel 仓库 1yum install epel-release 若找不到则需要手动安装 rpm -ivh http://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm 此时会提示需要通过另外的命令安装,输入安装即可 1sudo amazon-linux-extras install epel 然后再安装redis 1yum install redis 2. 启动12345678# 启动redisservice redis start# 停止redisservice redis stop# 查看redis运行状态service redis status# 查看redis进程ps -ef | grep redis 开启自启动 1chkconfig redis on 3. 配置Redis 默认配置文件为 /etc/redis.conf , 通常对其进行配置修改 1234567891011121314151617181920# 指定 Redis 端口port 6379# 绑定主机 IP , 通常修改为 0.0.0.0 或内网地址方便远程访问bind 127.0.0.1# 设置数据库数量databases 16# 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合# save &lt;seconds&gt; &lt;changes&gt; # Redis 默认配置文件中提供了三个条件save 900 1save 300 10save 60 10000# 指定本地数据库文件名,默认如下dbfilename dump.rdb# 指定本地数据库存放目录 , 若自定义目录,需要赋予权限 chown -R redis:redis &#123;自定义目录&#125;dir /var/lib/redis # 指定是否激活重置哈希，默认为开启activerehashing yes# 设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH &lt;password&gt;命令提供密码，默认关闭requirepass foobared 更多的配置,可直接查看配置文件的注释或者查看 详细文档 4. 常用操作1. 连接 Redis123redis-cli -h [ip] -p [端口]#例redis-cli -h 127.0.0.1 -p 6379 若设置了密码 , 则需要输入密码 1auth 445813 #445813为密码，输入密码前要密码前面加 auth和空格 2. 键值操作12345678910111213141516171819202122232425#添加set key value#例set webname django.cnset usrname "My namne is XXX" #中间有空格的要用引号#通过KEY查询127.0.0.1:6379&gt; get webname"django.cn"#删除keydel webname#设置过期时间(单位为秒)expire key timeout#也可以在设置值的时候，一同指定过期时间set key value EX timeout#例子set name django.cn EX 20 #设置20秒过期#查看过期时间ttl key#如ttl name#查看当前redis中所有Keykeys * Redis支持五种数据类型: string（字符串),hash（哈希）, list（列表）,set（集合）及zset(sorted set: 有序集合).更多关于不同数据类型操作方法, 可查看官方文档: https://redis.io/commands（英文）, 这里还有一个中文的, 可以去看看 http://redisdoc.com/index.html docker-compose 安装 Redis直接通过 Rancher 或者 docker-compose 安装 ,方便追踪 首先在对应目录下创建 redis.conf , 关于端口 , 目录等基本不要改 , 就改动访问密码等平台相关的信息即可 12345678910111213version: '3'services: redis: image: redis container_name: redis restart: always ports: - 16379:6379 volumes: - $PWD:/data - /etc/localtime:/etc/localtime:ro - $PWD/conf/redis.conf:/etc/redis/redis.conf command: redis-server /etc/redis/redis.conf 参考链接 django中文网: centos和ubuntu下redis的安装与使用 Docker安装Redis MySQL1. 卸载自带的 mariadb-lib 及 mysql首先查看已安装的 mariadb 和 mysql 然后一一卸载 1234# 查看rpm -qa|grep mariadb# 卸载rpm -e --nodeps mariadb-libs-xxx mysql 同理 2. 下载 MySQL 的 Yum Repository查看系统发行版本 1cat /etc/os-release 123456789NAME=&quot;Amazon Linux&quot;VERSION=&quot;2&quot;ID=&quot;amzn&quot;ID_LIKE=&quot;centos rhel fedora&quot; # 留意这里, 对应可选下载版本VERSION_ID=&quot;2&quot;PRETTY_NAME=&quot;Amazon Linux 2&quot;ANSI_COLOR=&quot;0;33&quot;CPE_NAME=&quot;cpe:2.3:o:amazon:amazon_linux:2&quot;HOME_URL=&quot;https://amazonlinux.com/&quot; 然后进入 MySQL 官网 Yum Repository 下载区 选择对应版本复制链接, 下载 1wget https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpm 安装 repo 1yum localinstall ./mysql80-community-release-el7-3.noarch.rpm 检查是否安装成功 1yum repolist enabled | grep &quot;mysql.*-community.*&quot; 3. 安装 MySQL1yum install mysql-community-server 4. 配置修改 MySQL 的配置文件 /etc/my.cnf , 这里笔者将 mysql 配置目录集中配置在了 /mnt/efs/mysql 下 12345678910basedir=/mnt/efs/mysql # 新增datadir=/mnt/efs/mysql/data # 修改socket=/mnt/efs/mysql/mysql.sock # 修改character_set_server = utf8 # 新增pid-file=/mnt/efs/mysql/mysqld/mysqld.pid # 修改log-error=/mnt/efs/mysql/log/mysqld.log # 修改[client] # 新增socket=/mnt/efs/mysql/mysql.sock# 新增 然后需要给予自定义目录权限 这里需要注意, 在给权限之前需要创建一些子目录, 否则后面启动 mysql 时会报&quot;SERVER_BOOTING&quot; Permission denied 类似的错误 , 需要查看错误日志了解详情 . 这里罗列下要创建的子目录 undefined 再给予权限 1chown -R mysql:mysql /mnt/efs/mysql 初始化 1mysqld --initialize --user=mysql 管理 SELinux 1setenforce 0 设置开机启动 1systemctl enable mysqld 启动 1systemctl start mysqld 查询是否启动成功 1systemctl status mysqld 5. 登录验证1grep &quot;temporary password&quot; /mnt/efs/mysql/log/mysqld.log 得到临时密码 , 然后登录数据库 1mysql -uroot -p # 输入得到的临时密码 再修改密码 1ALTER USER &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;xxxxxx&apos;; 如果是 mysql8.0 需要使用以下命令 , 否则用 Navicat 等客户端登录时会报 Authentication plugin &#39;caching_sha2_password&#39; cannot be loaded 12ALTER USER &apos;root&apos;@&apos;%&apos; IDENTIFIED WITH mysql_native_password BY &apos;xxx&apos;;FLUSH PRIVILEGES; 若这里的 % 填写的是localhost 后面登录时会报 Host &#39;x.x.x.x&#39; is not allowed to connect to this MySQL server . 其中 x.x.x.x 是登录的本地 IP . 最好不要改root的登录host , 创建新用户并修改host . 6. 创建用户及权限控制创建 123456789# root登录,然后创建用户 use mysql;# 创建用户create user &apos;dev&apos;@&apos;%&apos;;# 查询用户select user,host from user;# mysql_native_password 是使用旧版本密码插件,使本地 navicat 方便登录ALTER USER &apos;dev&apos;@&apos;%&apos; IDENTIFIED WITH mysql_native_password BY &apos;xxx&apos;;FLUSH PRIVILEGES; 授权 1234567# 给予 dev my_db 数据库下的所有表的所有权限grant all privileges on my_db.* to &apos;dev&apos;@&apos;%&apos;;# 给予 dev testDB 数据库下的所有查询和更新语句权限grant select,update on testDB.* to &apos;dev&apos;@&apos;%&apos;;# 给予 dev 所有数据库的某些权限grant select,delete,update,create,drop on *.* to &apos;dev&apos;@&apos;%&apos;;FLUSH PRIVILEGES; 7. docker-compose 安装 MySQL直接通过 Rancher 或者 Docker 安装 MySQL 首先创建 conf/my.cnf 文件 12345678910[mysqld]default-authentication-plugin=mysql_native_passwordbind-address = 0.0.0.0character_set_server = utf8skip-name-resolvemax_connections = 1000[client] docker-compose.yml 配置 123456789101112131415version: '3'services: mysql: image: mysql:8.0 restart: always ports: - 13306:3306 volumes: - /etc/localtime:/etc/localtime:ro - $PWD/conf:/etc/mysql/conf.d - $PWD/logs:/logs - $PWD/data:/var/lib/mysql privileged: true environment: - MYSQL_ROOT_PASSWORD=yourpassword 8. 数据库日备这里我们对 docker 安装的 MySQL 进行数据库结构+数据的每日全量备份 首先 docker ps 查看 MySQL 容器的 container ID 或者 Name 然后编写脚本 , 首先在当前目录下创建好 db 目录 , 用于存放备份好的文件 12345678910111213141516171819#!/bin/bashDAT=`date +%m%d`HOR=`date +%H`begin=`date +%F" "%T`DIR=$PWD/dbif [[ ! -d $DIR/$DAT ]];then mkdir $DIR/$DATfifor i in `cat $PWD/mysql-back.list`do docker exec -it CONTAINER_NAME mysqldump -uroot -pPASSWORD $i &gt; $DIR/$DAT/$i-$DAT$HOR.sqldonefind $DIR/* -mtime +20 -exec rm -rf &#123;&#125; \;end=`date +%F" "%T`echo "$begin dump mysql -------&gt; $end has done" &gt;&gt; $PWD/mysqldump.log 然后在当前目录创建 mysql-back.list 文件 , 填入要备份的数据库名 替换以上脚本中的 CONTAINER_NAME 和 PASSWORD 然后设置脚本运行时间 vim /etc/crontab 在最下方加入行 , sh 文件路径替换为自己存放的 10 2 * * * root sh /mnt/data/mysql/backups/mysql-backup.sh 这样每天凌晨2点就会执行全量数据备份 参考链接 Centos7，redhat安装Mysql CentOS7安装MySQL8.0图文教程 MySQL 8.0报错：ERROR 2059 (HY000): Authentication plugin ‘caching_sha2_password’ cannot be loaded 查看Linux发行版名称及版本号 CenterOS7-Docker-安装MySQL8 Docker1. 安装依赖包首先移除旧的 docker 及其 依赖 12345678sudo yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-engine 然后安装 docker 依赖包 1sudo yum install -y yum-utils device-mapper-persistent-data lvm2 2. 添加 Docker-ce 镜像 国外源 1yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 国内阿里云源 1yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 远程的包信息缓存到本机 1yum makecache fast 3. 安装 Docker最新版安装 1yum -y install docker-ce 在生产环境中, 通常需要使用统一的稳定版 ,而不是最新版 . 此时我们需要查看并安装指定版本 指定版本安装 12345678910111213141516yum list docker-ce --showduplicates | sort -rLoaded plugins: extras_suggestions, langpacks, priorities, update-motddocker-ce.x86_64 3:18.09.6-3.el7 docker-ce-stabledocker-ce.x86_64 3:18.09.5-3.el7 docker-ce-stabledocker-ce.x86_64 3:18.09.4-3.el7 docker-ce-stabledocker-ce.x86_64 3:18.09.3-3.el7 docker-ce-stabledocker-ce.x86_64 3:18.09.2-3.el7 docker-ce-stabledocker-ce.x86_64 3:18.09.1-3.el7 docker-ce-stabledocker-ce.x86_64 3:18.09.0-3.el7 docker-ce-stabledocker-ce.x86_64 18.06.3.ce-3.el7 docker-ce-stabledocker-ce.x86_64 18.06.2.ce-3.el7 docker-ce-stabledocker-ce.x86_64 18.06.1.ce-3.el7 docker-ce-stabledocker-ce.x86_64 18.06.0.ce-3.el7 docker-ce-stabledocker-ce.x86_64 18.03.1.ce-1.el7.centos docker-ce-stable... 然后安装对应版本 1sudo yum install docker-ce-18.09.5 docker-ce-cli-18.09.5 containerd.io-1.2.5 Issue此时可能出现 Requires: container-selinux &gt;= 2.9 的报错 1234Error: Package: 3:docker-ce-18.09.6-3.el7.x86_64 (docker-ce-stable) Requires: container-selinux &gt;= 2.9 You could try using --skip-broken to work around the problem You could try running: rpm -Va --nofiles --nodigest 此时需要去 http://rpm.pbone.net/index.php3/stat/4/idpl/40704222/dir/centos_7/com/container-selinux-2.9-4.el7.noarch.rpm.html 或 https://pkgs.org/download/container-selinux 下载 container-selinux2.9.4 1wget ftp://bo.mirror.garr.it/1/slc/centos/7.1.1503/extras/x86_64/Packages/container-selinux-2.9-4.el7.noarch.rpm 接着执行 1rpm -ivh container-selinux-2.9-4.el7.noarch.rpm 过程中可能又报错 , 若无报错则可跳过 12error: Failed dependencies: policycoreutils-python is needed by container-selinux-2:2.9-4.el7.noarch 直接 yum install 缺失的包即可 1yum -y install policycoreutils-python 至此,缺失的依赖包已补全 , 再按照上述安装 Docker 4. 配置 Docker重载 systemctl 并启动和开机自启动 docker 1234systemctl daemon-reloadsystemctl start dockersystemctl enable dockerdocker --version 5. 安装 Docker-compose12345sudo curl -L "https://github.com/docker/compose/releases/download/1.24.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-composesudo chmod +x /usr/local/bin/docker-composedocker-compose --version 6. 改变 Docker 默认存储路径安装完后不要启动,或者先停掉服务 移动现有文件 1mv /var/lib/docker/* /mnt/efs/docker 删除原来的目录 1rm -rf /var/lib/docker 建立软连接 1ln -s /mnt/efs/docker/ /var/lib/docker 进入 /var/lib 下用命令查看软连接结果 123 ls -la docker# 显示结果如下表示成功docker -&gt; /mnt/efs/docker/ 启动服务 , 用 docker info 查看是否成功 7. 卸载 Docker1. 搜索已安装的 docker 包 并删除 123yum list installed|grep dockeryum –y remove &#123;以上所列的包&#125; 2. 删除 docker 镜像 1rm -rf /var/lib/docker ## 若有自定义目录,需删除自定义目录 也可在卸载前删除容器及镜像 123# 停止所有容器并删除docker stop $(docker ps -a -q)docker rm $(docker ps -a -q) Docker制作 Java 服务镜像并推送到私有镜像库首先将 Java 工程改造成docker工程 . 在 pom.xml 中加入 123456789101112131415161718192021222324&lt;properties&gt; &lt;docker.image.prefix&gt;hc&lt;/docker.image.prefix&gt;&lt;/properties&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.6&lt;/version&gt; &lt;configuration&gt; &lt;repository&gt;$&#123;docker.image.prefix&#125;/$&#123;project.artifactId&#125;&lt;/repository&gt; &lt;buildArgs&gt; &lt;JAR_FILE&gt;target/$&#123;project.build.finalName&#125;.jar&lt;/JAR_FILE&gt; &lt;/buildArgs&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 然后本地安装 Docker , 此处不清楚的可自行 Google . 然后命令打包 1mvn clean package dockerfile:build -Dmaven.test.skip=true 123456# 登录私有镜像库,然后输入密码sudo docker login --username=用户名 registry.cn-shenzhen.aliyuncs.com# 通过 docker images 查看imageId 填入下方指令中sudo docker tag [ImageId] registry.cn-shenzhen.aliyuncs.com/命名空间/仓库:[镜像版本号]# 推送sudo docker push registry.cn-shenzhen.aliyuncs.com/命名空间/仓库:[镜像版本号] 此时注意下,如果是在 Mac 端输入 sudo xxx 命令,第一个输入的密码其实是本地电脑密码, 通过后才是输入镜像库密码, 别搞错了😂 CenterOS 补充后面使用了几台 CenterOS , 安装过程中依赖环境相对于 AWS Linux 还是全一些 . 卸载 device-mapper-* 安装高版本即可安装成功 12345678910# 查看安装的 device* 包rpm -qa | grep device# rpm -e xxx(以上查找出来的包) --nodeps# 下载依赖wget ftp://ftp.pbone.net/mirror/ftp.scientificlinux.org/linux/scientific/7.4/x86_64/os/Packages/device-mapper-1.02.140-8.el7.x86_64.rpmwget ftp://ftp.pbone.net/mirror/ftp.scientificlinux.org/linux/scientific/7.4/x86_64/os/Packages/device-mapper-libs-1.02.140-8.el7.x86_64.rpm# 安装 rpm -ivh xxx(以上两个包) --nodeps NPM Repo 12# 删除所有无用镜像docker image prune -a Issue若 docker info 查看有 WARNING: bridge-nf-call-iptables is disabled 的警告显示 . 解决办法 : 1vim /etc/sysctl.conf 添加以下内容 12net.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1 再执行 1sysctl -p 再执行 docker info 就不会报错了. 参考链接 Requires: container-selinux &gt;= 2.9报错 官网: Get Docker CE for CenterOS 官网: Install Docker Compose 修改 docker 默认的存储位置 WARNING:bridge-nf-call-iptables is disabled解决 SS参考链接Amazon EC2 Linux实例上安装Shadowsocks服务器 GitLab1. Docker及docker-compose参考本文 Docker部分 2. GitLabIssue 阿里云企业邮箱 smtp OpenTimeout: execution expired 通常是因为阿里云服务器 25 端口未开放, 换成 465 即可. 已经通过 docker-compose 部署的 GitLab 需要修改GitLab自身的配置文件gitlab.rb 首先修改自定义目录下的 {docker-compose文件中的自定义路径}/config/gitlab.rb 并保存 123456789gitlab_rails[&apos;smtp_enable&apos;] = truegitlab_rails[&apos;smtp_address&apos;] = &quot;smtp.mxhichina.com&quot;gitlab_rails[&apos;smtp_port&apos;] = 465gitlab_rails[&apos;smtp_user_name&apos;] = &quot;&#123;account&#125;@&#123;domain&#125;&quot;gitlab_rails[&apos;smtp_password&apos;] = &quot;有授权码填授权码,没有填密码&quot;gitlab_rails[&apos;smtp_domain&apos;] = &quot;&#123;domain&#125;&quot;gitlab_rails[&apos;smtp_authentication&apos;] = &quot;login&quot;gitlab_rails[&apos;smtp_enable_starttls_auto&apos;] = truegitlab_rails[&apos;smtp_tls&apos;] = true 然后进入容器 bash 1docker exec -it gitlab bash 重新读取配置 12gitlab-ctl reconfiguregitlab-ctl restart 然后进入 gitlab 控制台 1gitlab-rails console 检查邮件配置 检查邮件发送协议 1ActionMailer::Base.delivery_method 显示=&gt; :smtp 查看当前的发送邮件配置 1ActionMailer::Base.smtp_settings 查看配置是否与修改后的一致 然后发送测试邮件 1Notify.test_email(&apos;xxx@yyy.com&apos;,&apos;测试标题&apos;,&apos;测试内容&apos;).deliver_now 建议不要使用163邮箱, 可能因为内容导致邮件发送失败报554 参考链接Docker-compose一键部署gitlab中文版 Yapi参考链接顶尖API文档管理工具Yapi 爱发布 APP 托管fabu.love 常用的APP托管平台 蒲公英 , fir 审核越来越严格,时不时还会突然下架. 最好自己部署平台 物理机环境补充物理机初始化缺少很多云主机装好的环境 12345678910## vimyum -y install vim*## wget yum -y install wget## yum-utilsyum -y install yum-utils## telnetyum list telnet* 列出telnet相关的安装包yum install telnet-server 安装telnet服务yum install telnet.* 安装telnet客户端]]></content>
      <categories>
        <category>AWS</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Nginx</tag>
        <tag>MySQL</tag>
        <tag>GitLab</tag>
        <tag>Docker-Compose</tag>
        <tag>Redis</tag>
        <tag>JDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx启用Let's Encrypt SSL证书]]></title>
    <url>%2Fnginx-letsencrypt-ssl%2F</url>
    <content type="text"><![CDATA[Let’ s Encrypt 是一个免费的 SSL/TLS 证书发行机构, 证书有效期为90天, 到期前30内可续期，因此不需要担心费用问题。本篇将讲述启用证书的主要过程: 客户端安装、获取证书、配置Nginx、证书自动续期等。 服务器环境: nginx-1.10.1 php-7.0.4 mariadb-10.1.13 启用证书的主要过程包括：客户端安装、获取证书、配置Nginx、证书自动续期等几个方面。 客户端下载 Let’ s Encrypt客户端现已更名为certbot，客户端的地址为 GitHub 。 12345678#下载wget https://github.com/certbot/certbot/archive/v0.22.2.tar.gz#解压tar xzvf v0.22.2.tar.gz#进入目录cd certbot-0.22.2 运行一次客户端，进行检查升级： 12345#进入目录cd ~/certbot#执行检查./certbot-auto --help 如果没什么问题的话，会显示帮助文档。 获取证书 申请过程中要验证绑定的域名是否属于申请人, 其原理就是申请人在域名所在的服务器上申请证书, 然后 Let’ s Encrypt 会访问绑定的域名与客户端通信成功即可通过。 验证的方式有两种，一种是停止当前的 web server 服务, 让出 80 端口, 由客户端内置的 web server 启动与 Let’ s Encrypt 通信；一种是在域名根目录下创建一个临时目录, 并要保证外网通用域名可以访问这个目录，这种方式不需要停止当前的 web server 服务。 1. 通过访问80端口方式验证 12345678#停止nginxsystemctl stop nginx#获取证书, --standalone 参数:使用内置web server. --email 参数:管理员邮箱,证书到期前会发邮件到此邮箱提醒. -d 参数:要绑定的域名,同一域的不同子域都要输入../certbot-auto certonly --standalone --email admin@4spaces.org -d 4spaces.org -d www.4spaces.org#启动nginxsystemctl start nginx 2. 通过临时目录验证 12#--webroot 参数:指定使用临时目录的方式. -w 参数:指定后面-d 域名所在的根目录, 如果一次申请多个域的, 可以附加更多 -w...-d... 这段../certbot-auto certonly --webroot --email admin@4spaces.org -w /usr/share/nginx/html -d 4spaces.org -d www.4spaces.org 完成上面的操作即可获得 SSL 证书, 保存在 “/etc/letsencrypt/live/根域名/” 目录下, 会产生 4 个文件, 其中3个证书文件, 1个私钥文件. 不要移动证书的位置, 以免续期时出现错误。关于Letsencrypt使用的更多命令参见「这里」。 配置Nginx启用https 上面你的Nginx配置并没有启用ssl，下面我们需要开始配置nginx，让其支持https。进行这一步的前提是你前面已经成功生成证书。 编辑文件/etc/nginx/conf.d/default.conf(我是通过yum的方式安装的nginx，配置目录在这里，你根据自己的情况来)，进行如下配置（这个是我的完整配置）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#设置非安全连接永久跳转到安全连接server&#123; listen 80; server_name 4spaces.org www.4spaces.org; #告诉浏览器有效期内只准用 https 访问 add_header Strict-Transport-Security max-age=15768000; #永久重定向到 https 站点 return 301 https://$server_name$request_uri;&#125;server &#123; #启用 https, 使用 http/2 协议, nginx 1.9.11 启用 http/2 会有bug, 已在 1.9.12 版本中修复. listen 443 ssl http2; server_name 4spaces.org www.4spaces.org; #首页 index index.php index.html index.htm; #网站根目录 root /usr/share/nginx/4spaces; #告诉浏览器当前页面禁止被frame add_header X-Frame-Options DENY; #告诉浏览器不要猜测mime类型 add_header X-Content-Type-Options nosniff; #证书路径 ssl_certificate /etc/letsencrypt/live/4spaces.org/fullchain.pem; #私钥路径 ssl_certificate_key /etc/letsencrypt/live/4spaces.org/privkey.pem; #安全链接可选的加密协议 ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #可选的加密算法,顺序很重要,越靠前的优先级越高. ssl_ciphers EECDH+CHACHA20:EECDH+CHACHA20-draft:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5; #在 SSLv3 或 TLSv1 握手过程一般使用客户端的首选算法,如果启用下面的配置,则会使用服务器端的首选算法. ssl_prefer_server_ciphers on; #储存SSL会话的缓存类型和大小 ssl_session_cache shared:SSL:10m; #缓存有效期 ssl_session_timeout 60m; location / &#123; try_files $uri $uri/ /index.php?$args; #修改内容 &#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #修改此处内容支持php location ~ \.php$ &#123; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root/$fastcgi_script_name; include fastcgi_params; &#125;&#125; 证书续期 前面说了，证书的有效期是3个月，你可以在证书过期前的30天内，进行续期，也可以进行脚本自动续期。 方式1 进入你在下载的certbot客户端目录，执行证书续期的脚本命令如下： 1./certbot-auto renew renew 参数是官方推荐的续期方式, 使用这个参数会遍历 /etc/letsencrypt/live 下所有的证书, 如果证书在可续期的时间范围内(过期前30天内), 就会申请新的证书并替换原有证书, 否则跳过。 方式2 如果要指定更新某个域名的证书, 则要使用 certonly 参数, 其实和新申请证书时的命令差不多. 1./certbot-auto certonly --webroot --renew-by-default --email admin@4spaces.org -w /usr/share/nginx/html -d 4spaces.org -d www.4spaces.org 方式3 上面两种方式，都是手动去执行的，我们可以将上面两种方式跟linux的定时任务进行结合，最终脚本如下： 1) 通过端口验证的脚本 12345678910#!/bin/sh#停止 nginx 服务,使用 --standalone 独立服务器验证需要停止当前 web server.systemctl stop nginxif ! /path/to/certbot-auto renew -nvv --standalone &gt; /var/log/letsencrypt/renew.log 2&gt;&amp;1 ; then echo Automated renewal failed: cat /var/log/letsencrypt/renew.log exit 1fi#启动 nginxsystemctl start nginx 2) 通过临时目录的脚本 1234567891011#!/bin/sh# This script renews all the Let's Encrypt certificates with a validity &lt; 30 daysif ! /path/to/certbot-auto renew &gt; /var/log/letsencrypt/renew.log 2&gt;&amp;1 ; then echo Automated renewal failed: cat /var/log/letsencrypt/renew.log exit 1fi# 需要重启nginx证书才能生效systemctl reload nginx 上面两个脚本中的/path/to/certbot-auto代表你下载客户端解压后的目录，其中目录下有个certbot-auto。 选取一种方式，将对应的脚本保存为 certbotrenew.sh。 添加可执行权限 1chmod +x certbotrenew.sh 编辑 crontab 配置文件或执行 crontab -e 添加 cron 任务 12#编辑定时任务sudo crontab -e 我这里设置为每月28号23点执行此脚本: 10 23 28 * * /bin/sh /home/michael/certbot/certbotrenew.sh 保存退出即可。]]></content>
      <categories>
        <category>SSL</category>
      </categories>
      <tags>
        <tag>SSL</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaFx向TableViewColumn添加Image]]></title>
    <url>%2Fjavafx-customize-table-cell%2F</url>
    <content type="text"><![CDATA[JavaFX 的表格控件使用稍微不同于 Android 和 iOS 中的表格 . 流程上是向 TableView 中 添加列 TableColumn 然后再给列绑定数据 , 再设置 TableView 的数据 , 刷新即可得到可视结果 . 其中需要自定义 CellFactory 1. 加载图片 1234567891011121314151617KiwiId.setCellFactory(new Callback&lt;TableColumn&lt;NewBeautifulKiwi, Integer&gt;, TableCell&lt;NewBeautifulKiwi, Integer&gt;&gt;() &#123; @Override public TableCell&lt;NewBeautifulKiwi, Integer&gt; call(TableColumn&lt;NewBeautifulKiwi, Integer&gt; param) &#123; ... TableCell&lt;NewBeautifulKiwi, Integer&gt; cell = new TableCell&lt;NewBeautifulKiwi, Integer&gt;() &#123; public void updateItem(Integer item, boolean empty) &#123; if (item != null) &#123; imageview.setImage(new Image("arrow.png")); &#125; &#125; &#125;; // Attach the imageview to the cell cell.setGraphic(imageview); return cell; &#125; &#125;); KiwiId.setCellValueFactory(new PropertyValueFactory&lt;NewBeautifulKiwi, Integer&gt;("KiwiId")); 2. 从数据类 NewBeautifulKiwi 中属性加载图片 123456789101112131415161718192021222324252627282930313233@Entity(name = "KIWI_TABLE")public class NewBeautifulKiwi implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) private int KiwiId; private String Kiwi; private Image kiwiImage; public int getKiwiId() &#123; return KiwiId; &#125; public void setKiwiId(int KiwiId) &#123; this.KiwiId = KiwiId; &#125; public String getKiwi() &#123; return Kiwi; &#125; public void setKiwi(String Kiwi) &#123; this.Kiwi = Kiwi; &#125; public Image getKiwiImage() &#123; return kiwiImage; &#125; public void setKiwiImage(Image kiwiImage) &#123; this.kiwiImage = kiwiImage; &#125;&#125; 3. 在 table 中给 tableColumn绑定属性 1234567891011121314151617181920212223242526...@FXMLprivate TableColumn&lt;NewBeautifulKiwi, Image&gt; KiwiImageCol;...@Overridepublic void initialize(URL url, ResourceBundle rb) &#123; KiwiImageCol.setCellFactory(param -&gt; &#123; //Set up the ImageView final ImageView imageview = new ImageView(); imageview.setFitHeight(50); imageview.setFitWidth(50); //Set up the Table TableCell&lt;NewBeautifulKiwi, Image&gt; cell = new TableCell&lt;NewBeautifulKiwi, Image&gt;() &#123; public void updateItem(Image item, boolean empty) &#123; if (item != null) &#123; imageview.setImage(item); &#125; &#125; &#125;; // Attach the imageview to the cell cell.setGraphic(imageview); return cell; &#125;); KiwiImageCol.setCellValueFactory(new PropertyValueFactory&lt;NewBeautifulKiwi, Image&gt;("kiwiImage"));&#125; 参考资料: stackoverflow]]></content>
      <categories>
        <category>JavaFX</category>
      </categories>
      <tags>
        <tag>JavaFX</tag>
        <tag>TableView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaFX Maven项目打包exe]]></title>
    <url>%2Fjavafx-project-artifacts%2F</url>
    <content type="text"><![CDATA[最近帮朋友写了一个 UI 小工具 . 起初是用 Javascript 写的, 但是需要对结果进行文件归类 , 而 Javascript 没有权限创建文件夹 , 因此只好换 JavaFX 来写 . 在程序写完打包时遇到一些问题 , 记录在此 , 方便后续查阅 . 常规 JavaFX 项目打包这个直接利用 IDEA 的 Build artifacts , 步骤比较常规 , 此处不做展开 . 传送门 Maven JavaFX 项目打包maven 项目如果直接用以上的方法打包, 会发现客户端无法打开 , 可以直接使用 java -jar xxx.jar 部署查看具体原因 , 通常是因为项目通过 maven 引入的类及资源未打进 jar 包里 . 因此这里我们需要借助打包插件 . javafx-maven-plugin 引入插件包 , 并修改 vendor 和 mainClass 123456789&lt;plugin&gt; &lt;groupId&gt;com.zenjava&lt;/groupId&gt; &lt;artifactId&gt;javafx-maven-plugin&lt;/artifactId&gt; &lt;version&gt;8.8.3&lt;/version&gt; &lt;configuration&gt; &lt;vendor&gt;YourCompany&lt;/vendor&gt; &lt;mainClass&gt;your.package.with.Launcher&lt;/mainClass&gt; &lt;/configuration&gt;&lt;/plugin&gt; 然后打包 mvn jfx:jar , 打包完成的目录在 target/jfx/app]]></content>
      <categories>
        <category>JavaFX</category>
      </categories>
      <tags>
        <tag>JavaFX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转-CenterOS7安装和配置SSH]]></title>
    <url>%2Fcenteros-ssh-configuration%2F</url>
    <content type="text"><![CDATA[本文转自 CenterOS 7安装和配置SSH 1. 安装 openssh-server1yum install -y openssl openssh-server 2. 修改配置文件用 vim 打开配置文件 /etc/ssh/sshd_config 将上图中的 PermitRootLogin , RSAAuthentication , PubkeyAuthentication 的设置打开. 启动SSH的服务: 1systemctl start sshd.service 设置开机自动启动SSH服务 1systemctl enable sshd.service 设置文件夹 ~/.ssh的访问权限 12345678910$ cd ~$ chmod 700 .ssh $ chmod 600 .ssh/* $ ls -la .ssh total 16drwx------. 2 root root 58 May 15 00:23 .dr-xr-x---. 8 root root 4096 May 15 00:26 ..-rw-------. 1 root root 403 May 15 00:22 authorized_keys-rw-------. 1 root root 1766 May 15 00:21 id_rsa-rw-------. 1 root root 403 May 15 00:21 id_rsa.pub authorized_keys 文件存储的是客户端的公共密钥 . 将自己的公钥拷贝进文件即可]]></content>
      <categories>
        <category>CenterOS</category>
      </categories>
      <tags>
        <tag>CenterOS</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转-CenterOS7安装ss]]></title>
    <url>%2Fcenteros-install-ss%2F</url>
    <content type="text"><![CDATA[本文转自徒弟的有道笔记 Ubuntu安装Shadowsocks 1234567891011121314151617# 1. 下载包：wget https://storage.googleapis.com/golang/go1.9.1.linux-amd64.tar.gz# 2. 解压到/usr/local/gotar -C /usr/local -xzf go1.9.1.linux-amd64.tar.gz# 3. 导入到系统环境变量 (临时导入,可用其他方式)export PATH=$PATH:/usr/local/go/bin# 下载 sswget --no-check-certificate https://raw.githubusercontent.com/iMeiji/shadowsocks_install/master/shadowsocks-go.sh# 给予权限chmod +x shadowsocks-go.sh# 运行./shadowsocks-go.sh 2&gt;&amp;1 | tee shadowsocks-go.log# 开发端口, CenterOS 与 Ubuntu 略有不同.iptables -I INPUT -p tcp --dport 8989 -j ACCEPT 另转 Outline搭建VPN 也不错!]]></content>
      <categories>
        <category>CenterOS</category>
      </categories>
      <tags>
        <tag>CenterOS</tag>
        <tag>ss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift发布库到CocoaPod]]></title>
    <url>%2Fswift-publish-cocoapod%2F</url>
    <content type="text"><![CDATA[本文转自 Swift发布库到CocoaPod 建立工程 , 编写类库 新建一个iOS或其他platform的demo工程,通常Single View App即可 在demo工程新建target, file -&gt; new -&gt; target,选择创建Cocoa Touch Framework,该target用于包含你所要开源的所有库,假设取名为framework 在framework的target文件夹里面添加自己的开源代码,注意想要暴露出来的类、方法、属性均需要使用public或者open等修饰 现在,在demo中可以通过import framework来引用库,测试已写好的功能,测试完成后,就可以准备发布到CocoaPod了 发布到 CocoaPod 将代码提交到GitHub,并打上tag即release版本,该tag必须和pod配置文件的tag一致,否则push到pod会报错 创建配置文件xxx.podspec,xxx为发布到pod的名称,取名时先到pod搜索下是否已存在相同的库名,因为是唯一的,如果已存在则需要定义其他名称,命令如下： 1pod spec create xxx 修改配置文件,可以在GitHub上参考其他项目是怎么写的 123456789101112131415Pod::Spec.new do |s| s.name = &quot;KJTouchIdManager&quot; s.module_name = &quot;TouchIdManager&quot; s.version = &quot;0.0.1&quot; s.summary = &quot;TouchId/FaceId manager on iOS 8 or later.&quot; s.description = &quot;An easy way to use TouchId or FaceId, support iOS 8 or later&quot; s.homepage = &quot;https://github.com/Smiacter/TouchIdManager&quot; s.license = &quot;MIT&quot; s.author = &#123; &quot;Smiacter&quot; =&gt; &quot;Smiacter@gmail.com&quot; &#125; s.platform = :ios s.platform = :ios, &quot;8.0&quot; s.swift_version = &quot;4.1&quot; s.source = &#123; :git =&gt; &quot;https://github.com/Smiacter/TouchIdManager.git&quot;, :tag =&gt; &quot;#&#123;s.version&#125;&quot; &#125; s.source_files = &quot;TouchIdManager/*.swift&quot;end 12345678910111213- name -&gt; pod库的名称- mudule_name -&gt; 引用的module名称即工程创建的target名,如果和上述的name不一致的话需要指定,如果一样可以省略- version -&gt; 版本,和GitHub代码的tag一致- summary -&gt; pod库的简单介绍- description -&gt; pod库的详细描述,它的长度一定要比summary长,不要会有警告- homepage -&gt; GitHub访问路径- license -&gt; 遵循的授权版本- author -&gt; 作者,一般是自动生成- platform -&gt; 操作系统及最低支持版本,可指iOS/tvOS/watchOS/tvOS- swift_version -&gt; 如果用的是Swift,指定你使用的版本,因为pod在进行代码检查时的版本可能与你的不一致- source -&gt; GitHub代码仓库地址,请copy使用HTTPS的那个git地址,使用SSL的需要依赖环境,校验无法通过- source_files -&gt; 库的有用文件,它会告诉pod需要克隆哪些文件,*代表任意文件- 其他,生成的.podspec文件包含了很多其他参数,可以根据自己的需求打开某些注释,打造属于你自己的podspec 注册trunk,pod是通过trunk来发布的 1pod trunk register &quot;email address&quot; &quot;user name&quot; --description = &quot;optional&quot; 验证库代码和podspec的有效性,查看代码、配置文件是否有误 1pod spec lint xxx.podspec 如果出现错误,根据相关提示进行修改后再验证,提示一般都比较易懂,如果实在看不懂就自行搜索进行修改.当出现xxx.podspec passed validation.则说明验证通过. 真正发布（push）到pod仓库, allow-warnings 是可选的 1pod trunk push xxx.podspec --allow-warnings 发布成功]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Cocoapod</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转-Gradle下载的依赖包位置]]></title>
    <url>%2Fgradle-dependency-dir%2F</url>
    <content type="text"><![CDATA[Mac系统默认下载到 : /Users/(用户名)/.gradle/caches/modules-2/files-2.1或~/.gradle/caches/modules-2/files-2.1 打开Finder, Shift+command+G 这3个组合键后,输入以上路径 Windows系统默认下载到 : C:\Users\(用户名)\.gradle\caches\modules-2\files-2.1]]></content>
      <categories>
        <category>Gradle</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转-H5端页面可见监听]]></title>
    <url>%2Fh5-visibility-listen%2F</url>
    <content type="text"><![CDATA[Android , iOS 均有提供页面可见/不可见的回调方法,通常在其中订阅和取消订阅. 本文将说明如何在H5中监听页面可见状态. 转载原文 一、简介背景: 一般我们在进行前端页面开发时,对于用户正在离开页面.常用的方法是监听下面三个事件. pagehide beforeunload unload 但是，这些事件在手机上可能不会触发，页面就直接关闭了。因为手机系统可以将一个进程直接转入后台，然后杀死。 用户点击了一条系统通知，切换到另一个 App。 用户进入任务切换窗口，切换到另一个 App。 用户点击了 Home 按钮，切换回主屏幕。 操作系统自动切换到另一个 App（比如，收到一个电话) 上面这些情况，都会导致手机将浏览器进程切换到后台，然后为了节省资源，可能就会杀死浏览器进程。 以前，页面被系统切换，以及系统清除浏览器进程，是无法监听到的。开发者想要指定，任何一种页面卸载情况下都会执行的代码，也是无法做到的。为了解决这个问题，就诞生了 Page Visibility API。不管手机或桌面电脑，所有情况下，这个 API 都会监听到页面的可见性发生变化。 意义： 这个新的 API 的意义在于，通过监听网页的可见性，可以预判网页的卸载，还可以用来节省资源，减缓电能的消耗。比如，一旦用户不看网页，下面这些网页行为都是可以暂停的。 对服务器的轮询 网页动画 正在播放的音频或视频 官方有个在线的例子大伙可以看一下：http://daniemon.com/tech/webapps/page-visibility/ 二、document.visibilityState这个 API 主要在document对象上，新增了一个document.visibilityState属性。该属性返回一个字符串，表示页面当前的可见性状态，共有三个可能的值。 hidden：页面彻底不可见。 visible：页面至少一部分可见。 prerender：页面即将或正在渲染，处于不可见状态。 unloaded : 页面正在从内存中卸载。 注释：浏览器支持是可选的。 其中，hidden状态和visible状态是所有浏览器都必须支持的。prerender状态只在支持”预渲染”的浏览器上才会出现，比如 Chrome 浏览器就有预渲染功能，可以在用户不可见的状态下，预先把页面渲染出来，等到用户要浏览的时候，直接展示渲染好的网页。 只要页面可见，哪怕只露出一个角，document.visibilityState属性就返回visible。只有以下四种情况，才会返回hidden。 浏览器最小化。 浏览器没有最小化，但是当前页面切换成了背景页。 浏览器将要卸载（unload）页面。 操作系统触发锁屏屏幕。 可以看到，上面四种场景涵盖了页面可能被卸载的所有情况。也就是说，页面卸载之前，document.visibilityState属性一定会变成hidden。事实上，这也是设计这个 API 的主要目的。 另外，早期版本的 API，这个属性还有第四个值unloaded，表示页面即将卸载，现在已经被废弃了。 注意，document.visibilityState属性只针对顶层窗口，内嵌的页面的document.visibilityState属性由顶层窗口决定。使用 CSS 属性隐藏页面（比如display: none;），并不会影响内嵌页面的可见性。 三、document.hidden由于历史原因，这个 API 还定义了document.hidden属性。该属性只读，返回一个布尔值，表示当前页面是否可见。 当document.visibilityState属性返回visible时，document.hidden属性返回false；其他情况下，都返回true。 该属性只是出于历史原因而保留的，只要有可能，都应该使用document.visibilityState属性，而不是使用这个属性。 四、visibilitychange 事件的基本应用只要document.visibilityState属性发生变化，就会触发visibilitychange事件。因此，可以通过监听这个事件（通过document.addEventListener()方法或document.onvisibilitychange属性），跟踪页面可见性的变化。 12345678910document.addEventListener('visibilitychange', function () &#123; // 用户离开了当前页面 if (document.visibilityState === 'hidden') &#123; document.title = '页面不可见'; &#125; // 用户打开或回到页面 if (document.visibilityState === 'visible') &#123; document.title = '页面可见'; &#125;&#125;); 上面代码是 Page Visibility API 的最基本用法，可以监听可见性变化。 下面是另一个例子，一旦页面不可见，就暂停视频播放。 123456789var vidElem = document.getElementById('video-demo');document.addEventListener('visibilitychange', startStopVideo);function startStopVideo() &#123; if (document.visibilityState === 'hidden') &#123; vidElem.pause(); &#125; else if (document.visibilityState === 'visible') &#123; vidElem.play(); &#125;&#125; 五、页面卸载监听下面专门讨论一下，如何正确监听页面卸载。 页面卸载可以分成三种情况。 页面可见时，用户关闭 Tab 页或浏览器窗口。 页面可见时，用户在当前窗口前往另一个页面。 页面不可见时，用户或系统关闭浏览器窗口。这三种情况，都会触发visibilitychange事件。前两种情况，该事件在用户离开页面时触发；最后一种情况，该事件在页面从可见状态变为不可见状态时触发。 由此可见，visibilitychange事件比pagehide、beforeunload、unload事件更可靠，所有情况下都会触发（从visible变为hidden）。因此，可以只监听这个事件，运行页面卸载时需要运行的代码，不用监听后面那三个事件。 甚至可以这样说，unload事件在任何情况下都不必监听，beforeunload事件只有一种适用场景，就是用户修改了表单，没有提交就离开当前页面。另一方面，指定了这两个事件的监听函数，浏览器就不会缓存当前页面。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>H5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7使用Docker部署Springboot项目]]></title>
    <url>%2Fcenteros7-docker-springboot%2F</url>
    <content type="text"><![CDATA[Docker要求64位的系统且内核版本至少为3.10 安装 Docker1. 添加 yum 源123# yum install epel-release –y# yum clean all# yum list 2. 安装并运行 Docker12# yum install docker-io –y# systemctl start docker 检查安装结果 1# docker info Docker 基本用法12345678910111213141516# 运行Docker守护进程systemctl start docker # 停止Docker守护进程systemctl stop docker# 重启Docker守护进程systemctl restart docker # 查看已有Docker镜像docker images # 进入镜像terminaldocker exec -it [镜像id] bash# 退出镜像exit# 查看正在运行的容器docker ps# 删除镜像docker rmi -f [镜像id] 部署准备部署之前准备一些前提条件 可以运行 jar 包的环境 机器上安装了 docker 准备部署的 springboot 的jar包 Dockerfile 文件 准备好了然后创建 Dockfile 文件: 1234FROM java:8 VOLUME /tmp ADD walletdemo_raw.jar /walletdemo.jarENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd=file:/dev/./urandom&quot;,&quot;-jar&quot;,&quot;/walletdemo.jar&quot;] 解释一下需要注意的地方 java:8 是使用jdk的版本 walletdemo_raw.jar 是使用jar包的名称 ADD ... 是拷贝jar包到容器 ENTRYPOINT 执行jar文件 将 Dockerfile 和 jar 放在一个文件夹 , 使用下面命令生成镜像 , 注意最后的 . ,表示当前目录 1docker build -t walletdemo . walletdemo 是生成的镜像名称 更多的 docker build 命令可以查看 菜鸟教程 可以用 docker images 查看一下 docker 镜像 运行 Docker 容器1docker run -d -p 8090:8090 walletdemo 解释一下需要注意的地方 -d后台运行 -p 8090:8090 将 docker 容器的 8090 端口映射到服务器的 8090 端口 到这里就配置完成了 , 访问服务器 8090 端口就能访问 springboot 项目了. 参考链接: ECS上搭建Docker(CentOS7) https://www.imooc.com/article/44582]]></content>
      <categories>
        <category>CenterOS</category>
      </categories>
      <tags>
        <tag>CenterOS</tag>
        <tag>Docker</tag>
        <tag>Springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转-CentOS7使用firewalld打开关闭防火墙与端口]]></title>
    <url>%2Fcenteros7-firewall%2F</url>
    <content type="text"><![CDATA[本篇转自: CentOS7使用firewalld打开关闭防火墙与端口 1. firewalld的基本使用 12345- 启动： systemctl start firewalld- 关闭： systemctl stop firewalld- 查看状态： systemctl status firewalld - 开机禁用 ： systemctl disable firewalld- 开机启用 ： systemctl enable firewalld 2. systemctl是CentOS7的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体。 123456789- 启动一个服务：systemctl start firewalld.service- 关闭一个服务：systemctl stop firewalld.service- 重启一个服务：systemctl restart firewalld.service- 显示一个服务的状态：systemctl status firewalld.service- 在开机时启用一个服务：systemctl enable firewalld.service- 在开机时禁用一个服务：systemctl disable firewalld.service- 查看服务是否开机启动：systemctl is-enabled firewalld.service- 查看已启动的服务列表：systemctl list-unit-files|grep enabled- 查看启动失败的服务列表：systemctl --failed 3. 配置firewalld-cmd 12345678910- 查看版本： firewall-cmd --version- 查看帮助： firewall-cmd --help- 显示状态： firewall-cmd --state- 查看所有打开的端口： firewall-cmd --zone=public --list-ports- 更新防火墙规则： firewall-cmd --reload- 查看区域信息: firewall-cmd --get-active-zones- 查看指定接口所属区域： firewall-cmd --get-zone-of-interface=eth0- 拒绝所有包：firewall-cmd --panic-on- 取消拒绝状态： firewall-cmd --panic-off- 查看是否拒绝： firewall-cmd --query-panic 4. 配置端口 12345678- 添加firewall-cmd --zone=public --add-port=80/tcp --permanent （--permanent永久生效，没有此参数重启后失效）- 重新载入firewall-cmd --reload- 查看firewall-cmd --zone= public --query-port=80/tcp- 删除firewall-cmd --zone= public --remove-port=80/tcp --permanent]]></content>
      <categories>
        <category>CenterOS</category>
      </categories>
      <tags>
        <tag>CenterOS</tag>
        <tag>firewall</tag>
        <tag>port</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转-Mac终端连接ss代理]]></title>
    <url>%2Futility-mac-ss-proxy%2F</url>
    <content type="text"><![CDATA[近日上传 library 至 jcenter一直网络超时 , 需要终端科学上网 . 由于本机是公司配的 mac , 并未做设置 , 现将老友提供的配置文章转至本站 ,方便后续配置 . 转载自: 老友的为知笔记 mac 终端连接ss代理 如果已经启用 ss 本地地址为 socks5://127.0.0.1:1080 在终端下使用 export ALL_PROXY=socks5://127.0.0.1:1080 清除科学上网 unset ALL_PROXY 为了方便呢 , 可以在 .bash_profile 中加上这个 12345678function setproxy() &#123; # export &#123;HTTP,HTTPS,FTP&#125;_PROXY=&quot;http://127.0.0.1:3128&quot; 也可以设置http代理 export ALL_PROXY=socks5://127.0.0.1:1080&#125;function unsetproxy() &#123; # unset &#123;HTTP,HTTPS,FTP&#125;_PROXY unset ALL_PROXY&#125; 需要使用科学上网的时候$ setproxy，不用了就$ unsetproxy就可以很方便的在shell环境下切换设置代理了。为了测试是否成功可以curl -i http://ip.cn 查看ip。]]></content>
      <categories>
        <category>Utility</category>
      </categories>
      <tags>
        <tag>proxy</tag>
        <tag>mac</tag>
        <tag>ss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区块链-Linux下USDT测试节点搭建]]></title>
    <url>%2Fblockchain-usdt-node%2F</url>
    <content type="text"><![CDATA[本篇将说明在 Linux 下搭建USDT测试节点. 为了更好的阅读体验 , 请点击阅读原文 Tether Limited 公司基于 Omni Layer 这层协议(Omni Layer protocol)发行tetherUSD . Omni Layer 是基于比特币区块链的通信协议 , 它实现了智能合约的特性 , 也就是说 tetherUSD是 Omni Layer的一个智能合约 . 而实现 Omni Layer protocol 的开源软件项目是 Omni Core . 搭建环境服务器配置 硬盘: 500G 内存: 16G CPU: 4核 带宽: 一般 系统: CenterOS 7 节点搭建1. 进入 Omni Layer Download 下载对应包 2. 上传服务器并解压 这里笔者使用的路径统一为 /opt/usdt/... 12cd /opt/usdttar -xzvf omnicore-0.3.1-x86_64-linux-gnu.tar 4. bitcoin 配置 bitcoin的默认配置文件目录为 ~/.bitcoin/bitcoin.conf , 若没有指定, 默认则会在该目录下创建个新的. 同步数据比较占硬盘空间,建议自定义存储路径,避免后期空间不足的尴尬. 此处笔者在 /opt/usdt/data/ 下新建了 bitcoin.conf 文件 bitcoin.conf : 12345678910111213141516171819# 数据存储目录datadir=/opt/usdt/data# 使用测试网络testnet=1# 告知 Bitcoin-Qt 和 bitcoind 接受JSON-RPC命令server=1# 后台执行daemon=1# 设置 gen=1 以尝试比特币挖矿gen=1# 启用交易索引txindex=1# 监听 RPC,正式默认端口8333 测试默认18333#rpcport=18333#rpcuser=123456#rpcpassword=abcdef#rpcallowip=0.0.0.0/0#rpcconnect=127.0.0.1 这里和比特币节点的配置文件类似 , 更多的配置请参考 Bitcoin Core配置文件解读 如若机器已经启用了比特币节点 , 此处需要修改端口等配置 配置设置好 , 开始同步 12cd /opt/usdt/omnicored-0.3.1nohup ./omnicored --datadir=/opt/usdt/data/ &amp; 1234567891011Initializing Omni Core v0.3.1 [regtest]2018-07-20 05:34:34 Loading trades database: OK2018-07-20 05:34:34 Loading send-to-owners database: OK2018-07-20 05:34:34 Loading tx meta-info database: OK2018-07-20 05:34:34 Loading smart property database: OK2018-07-20 05:34:34 Loading master transactions database: OK2018-07-20 05:34:34 Loading fee cache database: OK2018-07-20 05:34:34 Loading fee history database: OK2018-07-20 05:34:34 Loading persistent state: NONE (no usable previous state found)2018-07-20 05:34:34 Exodus balance: 0.00000000 OMNI2018-07-20 05:34:34 Omni Core initialization completed 如无意外 , 同步则开始 . 同步的进度可以在 testnet3 目录下的 debug.log 中看同步进度. USDT 节点的数据同步相对 Bitcoin 的会慢很多,笔者的服务器花了两天半左右的时间 . 一定要等数据同步完成之后再进行后续操作 , 否则不能成功 . 相关命令ominicored启动 ominicore (自己视实际情况修改) 12cd /opt/usdt/omnicored-0.3.1/binnohup ./omnicored --datadir=/opt/usdt/data/ &amp; 命令中用 bitcoin.conf 文件包裹了一系列配置,如果不用此文件则需要指明各个参数.比如 ./omnicored -datadir=xxx -rpcuser=xxx ..... 如若不确定 omnicore 是否已经启用过 , 可先用命令查询 netstat --ip -lpan | grep omnicore 12# 帮助./omnicored -h 更多 bitcoind 命令 omnicore-cli关闭 omnicore 1./omnicore-cli -conf=/opt/usdt/data/bitcoin.conf stop 更多 bitcoin-cli 命令 bitcoin-cli RPC 命令总结 bitcoin-api 更多 omnicore-cli 命令 API 官方文档 比较好用的中文API文档 交易测试创建账户及地址1./omnicore-cli -conf=/opt/usdt/data/bitcoin.conf &quot;getnewaddress&quot; pluto pluto 是账户名 , 需要唯一. 返回的 n1FuLiRf7fHDVL2wKy9ibVan2iQK3s2UZV 是地址 getnewaddress 是比特币的命令 , 可以了解更多 比特币命令 获取测试币为了在 testnet 上收到 OMNI 和 TOMNI , 需要给 moneyqMan7uh8FqdCA2BV5yZ8qVrc9ikLP 发送 TBTC(测试网络比特币), 一个 TBTC 可以收到 100 个 OMNI 和 100 个 TOMNI . 首先去申请一些测试比特币 在以下测试币水龙头网页中申请测试比特币 , 注意科学上网 . http://bitcoinfaucet.uo1.net/send.php https://coinfaucet.eu/en/btc-testnet/ 等待确认 , 然后查询余额 . 1./omnicore-cli -conf=/opt/usdt/data/bitcoin.conf listaddressgroupings 2. 然后是获取 Omni 币 转测试比特币给 moneyqMan7uh8FqdCA2BV5yZ8qVrc9ikLP 多账户的情况下建议不要用 sendtoaddress 命令 , 用 sendfrom 指定账户转账比较好 sendfrom命令说明 1./omnicore-cli -conf=/opt/usdt/data/bitcoin.conf sendfrom &quot;pluto&quot; &quot;moneyqMan7uh8FqdCA2BV5yZ8qVrc9ikLP&quot; 0.0015 返回的是一串字符串 txhash , 可以去比特币浏览器 上查找 等待交易确认后 , 可以通过命令查询 Omni 币余额 这里有个问题 , 得到的 Omni 全打到钱包下另一个地址myVftRaBb8Vy3upWaL8TueAhDE2QAsQy1h了. 1./omnicore-cli -conf=/opt/usdt/data/bitcoin.conf &quot;omni_getbalance&quot; &quot;myVftRaBb8Vy3upWaL8TueAhDE2QAsQy1h&quot; 1 这里的 1 是 propertyid 即 资产标识ID , 在 OMNI 钱包中 , 不同资产都有一个唯一的 ID 来标识 . 常见的 1 代表 OMNI , 2 代表 TOMNI , 31 代表 USDT . 其他资产ID查询 测试网络中 , 通常直接用 OMNI 作为 USDT 进行研发 . 切换到生产网络时注意变更ID 交易再转账. 从 myVftRaBb8Vy3upWaL8TueAhDE2QAsQy1h 转 1 个 OMNI 到 n1FuLiRf7fHDVL2wKy9ibVan2iQK3s2UZV 1./omnicore-cli -conf=/opt/usdt/data/bitcoin.conf &quot;omni_send&quot; &quot;myVftRaBb8Vy3upWaL8TueAhDE2QAsQy1h&quot; &quot;n1FuLiRf7fHDVL2wKy9ibVan2iQK3s2UZV&quot; 1 &quot;1.0&quot; 查询 n1FuLiRf7fHDVL2wKy9ibVan2iQK3s2UZV 余额 附Linux 常用命令: 1234567891011121314# 查看磁盘空间df -hl# 递归删除rm -rf [目录]# 查看所有网络端口netstat -an# 查看端口具体被哪个进程占用lsof -i :[端口号]# 查看进程详细信息ps -aux | grep [进程号]# 杀掉进程kill -9 [进程号]# 查看关键字进程netstat --ip -lpan | grep [关键字] 参考资料: https://www.cnblogs.com/yanglang/p/9618075.html https://www.jianshu.com/p/417c280b8f9f https://www.jianshu.com/p/4a8054146ef1]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
        <tag>Linux</tag>
        <tag>USDT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区块链-Linux下Bitcoin测试节点搭建]]></title>
    <url>%2Fblockchain-bitcoin-node%2F</url>
    <content type="text"><![CDATA[在近期的研发中 , 需要用到比特币测试节点 . 本来想找个类似以太坊 infura 这样的三方节点 , 最终只找到 BLOCKCYPHER . 其提供了 testnet 和 mainnet 的环境 , 不过 API 是包装过一层的 , 出于严谨 , 还是决定自行搭建节点. 本篇将说明在 Linux 下搭建 Bitcoin 测试节点. 为了良好的阅读体验 , 请点击阅读原文 搭建环境选型比特币节点有很多实现 bitcoin core : 官方节点 , c/c++ 实现, 正式网络大多数是用这个运行全节点 btcd : golang的实现版本 , 如果用golang来写一些功能 ,可以参考这个代码 libbitcoin : c/c++实现 , 特点是它有较好的工具链 parity-bitcoin : rust实现 , 是以太坊创始人之一Gavin Wood的新公司Parity Technologies下的一个产品 ,它同样也实现了以太坊rust版本 还有很多其他实现 , 如java版本和js版本 . 若用作商业用途 , 那bitcoin core必然是最稳妥的选择. 服务器配置 硬盘: 500G . 内存: 16G . 一般来说4G就够 , 但如果要查历史记录 ,需要加载完整的交易索引表-tindex , 这就需要8G+的内存 CPU: 4核 带宽: 一般 系统: CenterOS 7 节点搭建1. 进入 bitcoin 选择 Choose your wallet 2. 选择 Bitcoin Core for Linux 下载 bitcoin-0.17.0.1-x86_64-linux-gnu.tar.gz 3. 上传服务器,解压 这里笔者使用的路径统一为 /opt/btc/... 解压 12cd /opt/btctar -xzvf bitcoin-0.17.0.1-x86_64-linux-gnu.tar.gz 4. bitcoin 配置 bitcoin的默认配置文件目录为 ~/.bitcoin/bitcoin.conf , 若没有指定, 默认则会在该目录下创建个新的. 同步数据比较占硬盘空间,建议自定义存储路径,避免后期空间不足的尴尬. 此处笔者在 /opt/btc/bitcoin-data/ 下新建了 bitcoin.conf 文件 bitcoin.conf : 12345678910111213141516# 数据存储目录datadir=/opt/btc/bitcoin-data# 使用测试网络testnet=1# 告知 Bitcoin-Qt 和 bitcoind 接受JSON-RPC命令server=1# 设置 gen=1 以尝试比特币挖矿gen=1# 后台执行daemon=1# 监听 RPC 链接,正式默认端口8333 测试默认18333#rpcport=18333#rpcuser=123456#rpcpassword=abcdef#rpcallowip=0.0.0.0/0#rpcconnect=127.0.0.1 这里只做一些简单的配置 , 更多的配置请参考 Bitcoin Core配置文件解读 配置设置好 , 开始同步 12cd /opt/btc/bitcoin-0.17.0/bin./bitcoind -conf=/opt/btc/bitcoin-data/bitcoin.conf 如无意外 , 同步则开始 . 测试网络节点数据大概几十G , 耐心等待即可 . 笔者大概花了1~2个小时 以上这个 progress 代表同步进度 , 1.0 则为 100% . 相关命令bitcoind启动 bitcoin (自己视实际情况修改) 12cd /opt/btc/bitcoin-0.17.0/bin./bitcoind -conf=/opt/btc/bitcoin-data/bitcoin.conf 命令中用 bitcoin.conf 文件包裹了一系列配置,如果不用此文件则需要指明各个参数.比如 ./bitcoind -datadir=xxx -rpcuser=xxx ..... 如若不确定 bitcoin 是否已经启用过 , 可先用命令查询 netstat --ip -lpan | grep bitcoin 12# 帮助./bitcoind -h 更多 bitcoind 命令 bitcoin-cli关闭 bitcoin 1./bitcoin-cli stop 其他命令 12345678# 查看网络状态：bitcoin-cli getnetworkinfo# 查看网络节点：bitcoin-cli getpeerinfo# 查看区块链信息：如同步进度、bitcoin-cli getblockchaininfo# 查看所有命令bitcoin-cli help 更多 bitcoin-cli 命令 bitcoin-cli RPC 命令总结 Bitcoin API 12345&gt; ./bitcoin-cli -conf=/opt/btc/bitcoin-data/bitcoin.conf listaccounts&gt; error code: -32&gt; error message:&gt; listaccounts is deprecated and will be removed in V0.18. To use this command, start bitcoind with -deprecatedrpc=accounts.&gt; &gt; 有些命令即将过期 , 会报错 . 此时最好用 bitcoin-cli help 查询下替换的命令 交易测试创建账户及地址1./bitcoin-cli -conf=/opt/btc/bitcoin-data/bitcoin.conf getnewaddress &quot;halcyon&quot; 此处 “halcyon” 为自定义账户名 , 默认创建的地址类型是隔离见证的 , 即在测试网络下是 2 开头的. 获取测试币在以下测试币水龙头网页中申请测试比特币 , 注意科学上网 . http://bitcoinfaucet.uo1.net/send.php https://coinfaucet.eu/en/btc-testnet/ 然后查询余额 . 123./bitcoin-cli -conf=/opt/btc/bitcoin-data/bitcoin.conf getbalance或者./bitcoin-cli -conf=/opt/btc/bitcoin-data/bitcoin.conf listaddressgroupings 然后转账给 myVftRaBb8Vy3upWaL8TueAhDE2QAsQy1h 1./bitcoin-cli -conf=/opt/btc/bitcoin-data/bitcoin.conf sendtoaddress &quot;myVftRaBb8Vy3upWaL8TueAhDE2QAsQy1h&quot; 0.001 返回的是一串字符串 txhash , 可以去比特币浏览器 上查找 附Linux 常用命令: 1234567891011121314# 查看磁盘空间df -hl# 递归删除rm -rf [目录]# 查看所有网络端口netstat -an# 查看端口具体被哪个进程占用lsof -i :[端口号]# 查看进程详细信息ps -aux | grep [进程号]# 杀掉进程kill -9 [进程号]# 查看关键字进程netstat --ip -lpan | grep [关键字] 参考资料: https://blog.csdn.net/littlesmallless/article/details/83825784 https://www.jianshu.com/p/1891a083e4fe]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
        <tag>Bitcoin</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter实战-以太坊钱包]]></title>
    <url>%2Fblockchain-flutter-app%2F</url>
    <content type="text"><![CDATA[之前由于工作重心偏移到了去中心化交易所 Loois 的开发中,对 Flutter 的学习暂停了. 现在计划重新开始,发现已经有许多不错的学习资源,比如 Flutter中文网 , Flutter掘金社区 等等.因此若我们仍按 原专栏计划 从基础一篇篇讲起,难免有些重复.不如直接进入实战,开发一款 Flutter以太坊钱包 .笔者会在开发学习过程中,将与原计划中的学习内容有交集的部分进行教程说明. 产品原型我们将参考 imToken , Loois 钱包产品设计.后面将会补充 墨刀 的原型. imToken下载地址 , Loois下载地址 这里有些区别的是, imToken 目前对接的是 0x 和 Kyber 协议 , Loois 目前对接的是 Loopring 协议 . 后面在做市场交易时,我们具体进行说明. 资源支持这里我们将用到 Material Design Icons , FontAwesome Icons , Loois相应图片,以及反编译imToken获取的图片. 环境准备环境安装等请参考 Flutter基础-(1)环境搭建及demo运行 知识储备Flutter 基本了解请参考 Flutter基础-(2)基本概念及首个应用 涉及到以太坊钱包相关的内容,可以参考其它几篇文章. 以太坊创建钱包 以太坊解锁钱包 以太坊转账离线签名 以上几篇文章是 Java 版本,我们将实现 Dart 版本]]></content>
      <categories>
        <category>Blockchain</category>
        <category>Android</category>
        <category>iOS</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Blockchain</tag>
        <tag>Ethereum</tag>
        <tag>Android</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区块链-以太坊转账离线签名]]></title>
    <url>%2Fblockchain-eth-transaction-sign%2F</url>
    <content type="text"><![CDATA[前两篇文章中,我们讲到如何创建和解锁以太坊钱包.本章我们将讲解转账相关的内容. 为了良好的阅读体验, 请阅读原文 我们先说明下整体的流程. 首先是钱包本地将转账信息进行离线签名,然后通过以太坊JSON-RPC方法发送到以太坊节点,其中以太坊和其他ERC20代币的签名是不同的. 转账ETH转账签名1234567891011121314151617181920212223242526272829303132/** * ETH 转账离线签名 * @param to 转入的钱包地址 * @param nonce 以太坊nonce * @param gasPrice gasPrice * @param gasLimit gasLimit * @param amount 转账的eth数量 * @param wallet 钱包对象 * @param password 密码 * @return 签名data */public String signedEthTransactionData(String to, BigInteger nonce, BigInteger gasPrice, BigInteger gasLimit, BigDecimal amount, HLWallet wallet, String password) throws Exception &#123; // 把十进制的转换成ETH的Wei, 1ETH = 10^18 Wei BigDecimal amountInWei = Convert.toWei(amount.toString(), Convert.Unit.ETHER); RawTransaction rawTransaction = RawTransaction.createEtherTransaction(nonce, gasPrice, gasLimit, to, amountInWei.toBigInteger()); return signData(rawTransaction,wallet,password);&#125;private String signData(RawTransaction rawTransaction, HLWallet wallet, String password) throws Exception &#123; Credentials credentials = Credentials.create(LWallet.decrypt(password, wallet.walletFile)); byte[] signMessage = TransactionEncoder.signMessage(rawTransaction, ChainId.MAINNET, credentials); return Numeric.toHexString(signMessage);&#125; nonce 为了防止交易的重播攻击，每笔交易必须有一个nonce随机数，针对每一个账户nonce都是从0开始，当nonce为0的交易处理完之后，才会处理nonce为1的交易，并依次加1的交易才会被处理.以下是nonce使用的几条规则： 当nonce太小，交易会被直接拒绝。 当nonce太大，交易会一直处于队列之中，这也就是导致我们上面描述的问题的原因； 当发送一个比较大的nonce值，然后补齐开始nonce到那个值之间的nonce，那么交易依旧可以被执行。 当交易处于queue中时停止geth客户端，那么交易queue中的交易会被清除掉。 我们可通过以太坊JSON-RPC方法eth_gettransactioncount 获取nonce ERC-20代币转账签名ERC-20代币与以太坊转账是不同的,需要走智能合约. 以下是手动拼接的方式 123456789101112131415161718192021222324public String signedContractTransactionData(String contractAddress, String to, BigInteger nonce, BigInteger gasPrice, BigInteger gasLimit, BigDecimal amount, BigDecimal decimal, HLWallet wallet, String password) throws Exception &#123; //因为每个代币可以规定自己的小数位, 所以实际的转账值=数值 * 10^小数位 BigDecimal realValue = amount.multiply(decimal); //0xa9059cbb代表某个代币的转账方法hex(transfer) + 对方的转账地址hex + 转账的值的hex String data = Params.Abi.transfer + // 0xa9059cbb Numeric.toHexStringNoPrefixZeroPadded(Numeric.toBigInt(to), 64) + Numeric.toHexStringNoPrefixZeroPadded(realValue.toBigInteger(), 64); RawTransaction rawTransaction = RawTransaction.createTransaction( nonce, gasPrice, gasLimit, contractAddress, data); return signData(rawTransaction, wallet, password);&#125; 此时我们需要将转账的指令信息通过签名时的data发送出去.代币转账的data组成部分有三个. 首先是固定头0xa9059cbb 然后是转入钱包地址 再是转账的数量,以wei作为单位 这里我们说明下,为什么固定头是0xa9059cbb.是因为它是函数原型transfer(address,uint256)的MethodId,相当于以太坊用来分辨指令的标识,具体转换方法为 1234567// transfer -&gt; 0xa9059cbb String transfer = "transfer(address,uint256)"; byte[] bytes = transfer.getBytes(); byte[] bytes1 = org.web3j.crypto.Hash.sha3(bytes); String hex = Numeric.toHexString(bytes1, 0, 4, true); ShadowLog.i("transfer", hex); 然后对于转入地址及转账数量,我们是将其转化为16进制,然后左边补0至64位.三个参数字符串拼接在一起即为最后签名时用到的data. 那么可能有人会问,是不是其他指令参数都是这么拼接? 当然不是,这里涉及到以太坊合约ABI,有兴趣的童鞋可以看看.这里因为转入地址的类型address和转账数量的类型uint256都是静态的,因此是上述的拼接方式,如果是动态的则不一样了,具体可以参考ABI文档. 这里我们提供另外一种web3j既有的封装实现,不用关心内部参数是如何拼接的.(推荐) 12345678910111213141516171819202122public String signContractTransaction(String contractAddress, String to, BigInteger nonce, BigInteger gasPrice, BigInteger gasLimit, BigDecimal amount, BigDecimal decimal, HLWallet wallet, String password) throws IOException, CipherException &#123; BigDecimal realValue = amount.multiply(decimal); Function function = new Function("transfer", Arrays.asList(new Address(to), new Uint256(realValue.toBigInteger())), Collections.emptyList()); String data = FunctionEncoder.encode(function); RawTransaction rawTransaction = RawTransaction.createTransaction( nonce, gasPrice, gasLimit, contractAddress, data); return signData(rawTransaction, wallet, password);&#125; 发送请求签名完后,通过以太坊的JSON-RPC发送出去.eth_sendrawtransaction ETH转账最终在以太坊浏览器上的转账结果 link ,可在页面最下方查看Input Data 10x3078 代币转账最终在以太坊浏览器上的转账结果 link,Input Data为 12345Function: transfer(address _to, uint256 _value)MethodID: 0xa9059cbb[0]: 000000000000000000000000b7bb6c45800f4531cc1581637868373a06367b48[1]: 000000000000000000000000000000000000000000000002d1a51c7e00500000 FAQQ: 为什么调用sendRawTransaction接口后,转账记录在以太坊浏览器或者其他钱包查询不到? A: 接口调用后会返回一个字符串hash,我们通常称为txHash.此时是不知道结果的,因为拥堵或者其他原因以太坊不一定确认,因此查不到是正常的.在app中,一种做法是在发送请求后,主动通知自己的中继relay,在中继relay中维护这个txHash状态,以处理中的状态呈现给用户. Q:sendRawTransaction后接口报错’invalid sender’ A: 这个报错是以太坊环境错误导致的,代码上表现为chainId没对应. 123456789private String signData(byte chainId, RawTransaction rawTransaction, HDWallet wallet, String password) throws Exception &#123; Credentials credentials; credentials = Credentials.create(Wallet.decrypt(password, wallet.getWalletFile())); byte[] signMessage = TransactionEncoder.signMessage(rawTransaction, chainId, credentials); return Numeric.toHexString(signMessage); &#125; 签名需要制定环境chainId,若使用不带chainId的方法,则默认是主网. 友链: https://www.i7play.com/ 参考: https://blog.csdn.net/wo541075754/article/details/77975335]]></content>
      <categories>
        <category>Blockchain</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
        <tag>Ethereum</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区块链-ETH解锁钱包]]></title>
    <url>%2Fblockchain-eth-unlock-android%2F</url>
    <content type="text"><![CDATA[本篇文章承接区块链-ETH创建钱包 , 基本概念在上篇文章中已经做了概要 , 现在我们开始说明分别通过助记词,私钥,Keystore来解锁钱包. 为了良好的阅读体验, 请阅读原文 环境依赖环境还是BIP全家桶 1234implementation 'io.github.novacrypto:BIP44:0.0.3' // implementation 'io.github.novacrypto:BIP32:0.0.9' //存在少许问题implementation 'com.lhalcyon:bip32:1.0.0' // 上面的BIP32有少许问题,笔者做了一些修改,已经上传libimplementation 'io.github.novacrypto:BIP39:0.1.9' 助记词解锁钱包校验助记词对用户输入的助记词需要进行校验 123456789101112// validate mnemonictry &#123; MnemonicValidator.ofWordList(English.INSTANCE).validate(mnemonics);&#125; catch (InvalidChecksumException e) &#123; e.printStackTrace();&#125; catch (InvalidWordCountException e) &#123; e.printStackTrace();&#125; catch (WordNotFoundException e) &#123; e.printStackTrace();&#125; catch (UnexpectedWhiteSpaceException e) &#123; e.printStackTrace();&#125; 解锁钱包助记词解锁其实与创建钱包过程一致,只是增加了校验重复钱包的逻辑 1234567891011121314151617public Flowable&lt;HLWallet&gt; importMnemonic(Context context, String password, String mnemonics) &#123; Flowable&lt;String&gt; flowable = Flowable.just(mnemonics); return flowable .flatMap(s -&gt; &#123; ECKeyPair keyPair = generateKeyPair(s); WalletFile walletFile = Wallet.createLight(password, keyPair); HLWallet hlWallet = new HLWallet(walletFile); if (WalletManager.shared().isWalletExist(hlWallet.getAddress())) &#123; return Flowable.error(new HLError(ReplyCode.walletExisted, new Throwable("Wallet existed!"))); &#125; WalletManager.shared().saveWallet(context, hlWallet); return Flowable.just(hlWallet); &#125;);&#125; 私钥解锁钱包私钥解锁/导入钱包的过程也与创建时大体一致 12345678910111213141516171819public Flowable&lt;HLWallet&gt; importPrivateKey(Context context, String privateKey, String password) &#123; if (privateKey.startsWith(Constant.PREFIX_16)) &#123; privateKey = privateKey.substring(Constant.PREFIX_16.length()); &#125; Flowable&lt;String&gt; flowable = Flowable.just(privateKey); return flowable.flatMap(s -&gt; &#123; byte[] privateBytes = Hex.decode(s); ECKeyPair ecKeyPair = ECKeyPair.create(privateBytes); WalletFile walletFile = Wallet.createLight(password, ecKeyPair); HLWallet hlWallet = new HLWallet(walletFile); if (WalletManager.shared().isWalletExist(hlWallet.getAddress())) &#123; return Flowable.error(new HLError(ReplyCode.walletExisted, new Throwable("Wallet existed!"))); &#125; WalletManager.shared().saveWallet(context, hlWallet); return Flowable.just(hlWallet); &#125;);&#125; Keystore解锁钱包Keystore解锁钱包需要重点来讲 直接先上代码 12345678910111213141516171819202122public Flowable&lt;HLWallet&gt; importKeystoreViaWeb3j(Context context, String keystore, String password) &#123; return Flowable.just(keystore) .flatMap(s -&gt; &#123; ObjectMapper objectMapper = new ObjectMapper(); WalletFile walletFile = objectMapper.readValue(keystore, WalletFile.class); ECKeyPair keyPair = Wallet.decrypt(password, walletFile); HLWallet hlWallet = new HLWallet(walletFile); WalletFile generateWalletFile = Wallet.createLight(password, keyPair); if (!generateWalletFile.getAddress().equalsIgnoreCase(walletFile.getAddress())) &#123; return Flowable.error(new HLError(ReplyCode.failure, new Throwable("address doesn't match private key"))); &#125; if (WalletManager.shared().isWalletExist(hlWallet.getAddress())) &#123; return Flowable.error(new HLError(ReplyCode.walletExisted, new Throwable("Wallet existed!"))); &#125; WalletManager.shared().saveWallet(context, hlWallet); return Flowable.just(hlWallet); &#125;);&#125; 其过程主要是通过 WalletFile / Keystore + Password 得到 EcKeyPair 接着得到其他信息,主要API为 1ECKeyPair keyPair = Wallet.decrypt(password, walletFile); 增加了校验钱包是否已存在,以及Keystore是否与私钥匹配的逻辑 看似过程那么完美,其实当真正运用中就会发现程序走到这里经常OOM! 报错信息截取如下: 12345at org.spongycastle.crypto.generators.SCrypt.SMix(SCrypt.java:143)at org.spongycastle.crypto.generators.SCrypt.MFcrypt(SCrypt.java:87)at org.spongycastle.crypto.generators.SCrypt.generate(SCrypt.java:66)at org.web3j.crypto.Wallet.generateDerivedScryptKey(Wallet.java:136)at org.web3j.crypto.Wallet.decrypt(Wallet.java:214) 进一步调试发现,是因为当N过大时, org.spongycastle.crypto.generators.SCrypt.SMix(..)方法里的 124 行左右 12345for (int i = 0; i &lt; N; ++i)&#123; V[i] = Arrays.clone(X); ...&#125; 这里不停地clone,导致了内存溢出Crash . 说到这里,不得不说一下创建钱包时,我们的选择 1Wallet.createLight(password, keyPair) 这里使用的是创建轻量级钱包,其原始调用为 1public static WalletFile create(String password, ECKeyPair ecKeyPair, int n, int p) 这里的N ,P 是可以自定义赋值的,其意义可自行google下.简单地来说,N越大,钱包加密程度越高. 当我们创建钱包是调用的createLight(...) , 而从 imToken 创建的钱包是采用的自定义大于我们’轻量’的标准的,因此从 imToken中创建的钱包导出Keystore,再在我们的钱包中导入,调用上述web3j的 Wallet.decrypt(...) 基本会OOM Crash. 可以在 web3j Issues 中搜到大量相关的问题 , 解答基本是说依赖库不兼容Android导致的 . 这里就减少道友们绕圈子的时间了,直接提供个可行的解决方案. Link: Out Of Memory exception when using web3j in Android 就是我们需要修改部分方法. OOM优化这里需要依赖 1implementation 'com.lambdaworks:scrypt:1.4.0' 然后修改解密方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public static ECKeyPair decrypt(String password, WalletFile walletFile) throws CipherException &#123; validate(walletFile); WalletFile.Crypto crypto = walletFile.getCrypto(); byte[] mac = Numeric.hexStringToByteArray(crypto.getMac()); byte[] iv = Numeric.hexStringToByteArray(crypto.getCipherparams().getIv()); byte[] cipherText = Numeric.hexStringToByteArray(crypto.getCiphertext()); byte[] derivedKey; if (crypto.getKdfparams() instanceof WalletFile.ScryptKdfParams) &#123; WalletFile.ScryptKdfParams scryptKdfParams = (WalletFile.ScryptKdfParams) crypto.getKdfparams(); int dklen = scryptKdfParams.getDklen(); int n = scryptKdfParams.getN(); int p = scryptKdfParams.getP(); int r = scryptKdfParams.getR(); byte[] salt = Numeric.hexStringToByteArray(scryptKdfParams.getSalt());// derivedKey = generateDerivedScryptKey(password.getBytes(Charset.forName("UTF-8")), salt, n, r, p, dklen); derivedKey = com.lambdaworks.crypto.SCrypt.scryptN(password.getBytes(Charset.forName("UTF-8")), salt, n, r, p, dklen); &#125; else if (crypto.getKdfparams() instanceof WalletFile.Aes128CtrKdfParams) &#123; WalletFile.Aes128CtrKdfParams aes128CtrKdfParams = (WalletFile.Aes128CtrKdfParams) crypto.getKdfparams(); int c = aes128CtrKdfParams.getC(); String prf = aes128CtrKdfParams.getPrf(); byte[] salt = Numeric.hexStringToByteArray(aes128CtrKdfParams.getSalt()); derivedKey = generateAes128CtrDerivedKey( password.getBytes(Charset.forName("UTF-8")), salt, c, prf); &#125; else &#123; throw new CipherException("Unable to deserialize params: " + crypto.getKdf()); &#125; byte[] derivedMac = generateMac(derivedKey, cipherText); if (!Arrays.equals(derivedMac, mac)) &#123; throw new CipherException("Invalid password provided"); &#125; byte[] encryptKey = Arrays.copyOfRange(derivedKey, 0, 16); byte[] privateKey = performCipherOperation(Cipher.DECRYPT_MODE, iv, encryptKey, cipherText); return ECKeyPair.create(privateKey); &#125; 注释的代码行为 web3j 中的内容 ,到了这里我们还需要导入相应的so库,我们在src/main下创建jniLibs,接着放入对应平台so 全部so笔者已上传到 Android scrypt so 现在调用的是修改后的方法 LWallet.decrypt(...) 1234567891011121314151617181920public Flowable&lt;HLWallet&gt; importKeystore(Context context, String keystore, String password) &#123; return Flowable.just(keystore) .flatMap(s -&gt; &#123; ObjectMapper objectMapper = new ObjectMapper(); WalletFile walletFile = objectMapper.readValue(keystore, WalletFile.class); ECKeyPair keyPair = LWallet.decrypt(password, walletFile); HLWallet hlWallet = new HLWallet(walletFile); WalletFile generateWalletFile = Wallet.createLight(password, keyPair); if (!generateWalletFile.getAddress().equalsIgnoreCase(walletFile.getAddress())) &#123; return Flowable.error(new HLError(ReplyCode.failure, new Throwable("address doesn't match private key"))); &#125; if (WalletManager.shared().isWalletExist(hlWallet.getAddress())) &#123; return Flowable.error(new HLError(ReplyCode.walletExisted, new Throwable("Wallet existed!"))); &#125; WalletManager.shared().saveWallet(context, hlWallet); return Flowable.just(hlWallet); &#125;);&#125; Other FAQ在开发中, 总是会有这样那样的疑问,这里做一个简单的答疑 Q. 怎么导出助记词啊 , imToken 有导出/备份助记词的功能 . A. 很好的问题. 其实就是创建/用助记词解锁钱包时,app本地保存了助记词.导出只是将存储数据读取出来而已.可以尝试在imToken上通过导入Keystore或者私钥解锁钱包,就会发现没有备份助记词的入口. Q. app本地需要保存钱包什么信息 A. 理论上说只需要保存钱包的Keystore.助记词,私钥最好别存,因为app一旦被破解,用户的钱包就能被直接获取到.如若有出于用户体验等原因保存这些敏感信息,最好结合用户输入的密码做对称加密保存. … 以上即为以太坊解锁钱包的主要内容,过程中的坑基本有显式指明. GitHub 系列教程代码已上传,如果对你有所帮助,请不吝点个star :)]]></content>
      <categories>
        <category>Blockchain</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
        <tag>Ethereum</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区块链-ETH创建钱包]]></title>
    <url>%2Fblockchain-eth-wallet-android%2F</url>
    <content type="text"><![CDATA[离上篇文章更新已经接近两个月了,主要由于工作重心转移到了区块链DApp.从无到有去完成一款钱包+去中心化交易所 DApp 目前这款 app Android和iOS 处于公测中, 待上线后会将代码进行开源.笔者计划是对以太坊钱包的创建,导入,智能合约调用等进行系列教程,本文先对区块链的基本概念及以太坊钱包创建等进行说明. 为了良好的阅读体验, 请点击阅读原文 基本概念所有问题大体可以分为三类:区块链基本概念,钱包安全知识以及钱包转账交易 区块链的基本特性去中心化 因为整个网络没有中心统治者。系统依靠的是网络上多个参与者的公平约束，所以任意每几个节点的权利和义务都是均等的，而且每一个节点都会储存这个区块链上所有数据。即使该节点被损坏或遭受攻击，仍然不会对账簿造成任何威胁。 不可逆 区块链上的信息必须不可撤销，不能随意销毁。系统是开源的，整个系统都必须是公开透明的，因此某笔交易被全网广播以后，达到 6 个确认以上就成功记录在案了，且不可逆转不可撤销。注: imToken 是 12 个区块确认。 不可篡改 确保信息或合约无法伪造。账簿在某个人或某几人手上，造假的可能性就非常高，但每个人手里都有一本账簿，除非整个游戏里超过51%的人都更改某一笔账目，否则任何的篡改都是无效的，这也是集体维护和监督的优越性。 匿名性 各区块节点的身份信息不需要公告或验证, 信息传递可以匿名进行。举个简单的例子, 就是你在区块链上向一个钱包地址发起交易, 但是却无法知道这个地址背后确切对应的是那一个人, 或者你的私钥被某一个黑客盗窃了, 无法从一个钱包地址中得知黑客是谁。 以太坊基本概念钱包地址 以0x开头的42位的哈希值 (16进制) 字符串 keystore 明文私钥通过加密算法加密过后的 JSON 格式的字符串, 一般以文件形式存储 助记词 12 (或者 15、18、21) 单词构成, 用户可以通过助记词导入钱包, 但反过来讲, 如果他人得到了你的助记词, 不需要任何密码就可以轻而易举的转移你的资产, 所以要妥善保管自己的助记词 明文私钥 64位的16进制哈希值字符串, 用一句话阐述明文私钥的重要性 “谁掌握了私钥, 谁就掌握了该钱包的使用权!” 同样, 如果他人得到了你的明文私钥, 不需要任何密码就可以轻而易举的转移你的资产 通俗地去解释,以银行账户为类比,这些名词分别对应内容如下: 钱包地址 = 银行卡号 密码 = 银行卡密码 私钥 = 银行卡号 + 银行卡密码 助记词 = 银行卡号 + 银行卡密码 Keystore+ 密码 = 银行卡号 + 银行卡密码 Keystore ≠ 银行卡号 Note: 此小节大部分内容摘自 imToken 测评通关攻略 BIP32,BIP39,BIP44在创建钱包前,得先说下BIP32,BIP39,BIP44 BIP 全名是 Bitcoin Improvement Proposals，是提出 Bitcoin 的新功能或改进措施的文件。可由任何人提出，经过审核后公布在 bitcoin/bips 上。BIP 和 Bitcoin 的关系，就像是 RFC 之于 Internet。 而其中的 BIP32, BIP39, BIP44 共同定义了目前被广泛使用的 HD Wallet，包含其设计动机和理念、实作方式、实例等。 BIP32 定义 Hierarchical Deterministic wallet (简称 “HD Wallet”)，是一个系统可以从单一个 seed 产生一树状结构储存多组 keypairs（私钥和公钥）。好处是可以方便的备份、转移到其他相容装置（因为都只需要 seed），以及分层的权限控制等 BIP39 将 seed 用方便记忆和书写的单字表示。一般由 12 个单字组成，称为 mnemonic code(phrase)，中文称为助记词或助记码。例如 1rose rocket invest real refuse margin festival danger anger border idle brown BIP44 基于 BIP32 的系统，赋予树状结构中的各层特殊的意义。让同一个 seed 可以支援多币种、多帐户等。各层定义如下: 1m / purpose&apos; / coin_type&apos; / account&apos; / change / address_index 其中的 purporse&#39; 固定是 44&#39;，代表使用 BIP44。而 coin_type&#39; 用来表示不同币种，例如 Bitcoin 就是 0&#39;，Ethereum 是 60&#39; Ethereum HD Wallet Ethereum 的钱包目前均采用以上 Bitcoin HD Wallet 的架构，并订 coin_type&#39; 为 60&#39;，可以在 ethereum/EIPs/issues 中看到相关的讨论。举例来说，在一个 Ethereum HD Wallet 中，第一个帐户（这里的帐户指 BIP44 中定义的 account&#39;）的第一组 keypair，其路径会是 m/44&#39;/60&#39;/0&#39;/0/0 创建钱包在了解BIP 后,我们开始以太坊钱包开发,创建的钱包的流程为: 随机生成一组助记词 生成 seed 生成 master key 生成 child key 我们取第一组child key即m/44&#39;/60&#39;/0&#39;/0/0 得到私钥,keystore及地址 bitcoinj这里我们需要配置开发环境,通常Android 开发以太坊钱包,会依赖两个库 bitcoinj , web3j bitcoinj 主要用来实现BIP32和BIP44 , web3j 实现BIP39和钱包功能 . 12implementation 'org.web3j:core:3.3.1-android'implementation 'org.bitcoinj:bitcoinj-core:0.14.7' 不过web3j在生成助记词中需要使用到MnemonicUtils,但是有坑,加载助记词列表文件的方式在Android上不行,会导致Crash 123456789private static List&lt;String&gt; populateWordList() &#123; URL url = Thread.currentThread().getContextClassLoader() .getResource("en-mnemonic-word-list.txt"); try &#123; return readAllLines(url.toURI().getSchemeSpecificPart()); &#125; catch (Exception e) &#123; return Collections.emptyList(); &#125; &#125; 这是Java的加载方式,Android上需要做平台适配,需要将en-mnemonic-word-list.txt文件放到assets目录下加载. 以下笔者则使用了另一个BIP39的依赖库 1implementation 'io.github.novacrypto:BIP39:0.1.9' 本篇在使用中还用到了RxJava2 1 1234567891011private Flowable&lt;String&gt; mnemonics() &#123; // 1. 生成一组随机的助记词 StringBuilder sb = new StringBuilder(); byte[] entropy = new byte[Words.TWELVE.byteLength()]; new SecureRandom().nextBytes(entropy); new MnemonicGenerator(English.INSTANCE) .createMnemonic(entropy, sb::append); String mnemonics = sb.toString(); Logger.w("助记词:" + mnemonics); return Flowable.just(mnemonics);&#125; 2~5 123456789101112131415161718192021222324252627282930313233public Flowable&lt;HLWallet&gt; generateWallet(Context context, String walletName, String password) &#123; Flowable&lt;String&gt; flowable = mnemonics(); return flowable .map(mnemonics -&gt; &#123; // 2. 由助记词得到种子 byte[] seed = new SeedCalculator().calculateSeed(mnemonics, ""); NetworkParameters params = MainNetParams.get(); // 3. 生成根私钥 root private key DeterministicKey rootPrivateKey = HDKeyDerivation.createMasterPrivateKey(seed); // 4. 根私钥进行 priB58编码,得到测试网站上显示的数据 String priv = rootPrivateKey.serializePrivB58(params); Logger.i("BIP32 Extended Private Key:" + priv); // 5. 生成 HD 钱包 , 由根私钥 DeterministicHierarchy dh = new DeterministicHierarchy(rootPrivateKey); // 6. 定义父路径 List&lt;ChildNumber&gt; parentPath = HDUtil.parsePath(); // 7. 由父路径,派生出第一个子私钥 "new ChildNumber(0)" 表示第一个 DeterministicKey child = dh.deriveChild(parentPath, true, true, new ChildNumber(0)); Logger.w(" BIP32 Extended private Key:" + child.serializePrivB58(params)); String childPrivateKey = child.getPrivateKeyAsHex(); String childPublicKey = child.getPublicKeyAsHex(); ECKeyPair childEcKeyPair = ECKeyPair.create(child.getPrivKeyBytes()); String childAddress = Keys.getAddress(childEcKeyPair); String fullAddress = Constant.PREFIX_16 + childAddress; Logger.w("child privateKey:" + childPrivateKey + "\n" + "child publicKey:" + childPublicKey + "\n" + "address:" + fullAddress); WalletFile walletFile = org.web3j.crypto.Wallet.createLight(password, childEcKeyPair); String keystore = Singleton.get().gson.toJson(walletFile); Logger.w("keystore:\n" + keystore); WalletManager.shared().saveWallet(context, walletName, walletFile, mnemonics); return new HLWallet(mnemonics, walletName, childAddress); &#125;);&#125; Note: 这里有个注意点,byte[] seed = new SeedCalculator().calculateSeed(mnemonics, &quot;&quot;)这里的””是BIP39的密码.少数平台生成钱包使用用户输入的密码作为其密码,这将使得钱包不能通用.目前大多平台生成钱包时对其设置均为空字符串. 关于bitcoinj的使用比较不做赘述了.以上已经贴了主要的代码,下面我们主要讲解一下其他实现 novacrypto这里使用novacrypto作者的BIP全家桶,我们重点讲解下这种实现 1234implementation 'io.github.novacrypto:BIP39:0.1.9'implementation 'io.github.novacrypto:BIP44:0.0.3'//implementation 'io.github.novacrypto:BIP32:0.0.9' // 有少许问题implementation 'com.lhalcyon:bip32:1.0.0' // 上面的BIP32有少许问题,笔者做了一些修改,已经上传lib 其中作者的BIP32库还有些许问题, 大家可以使用文末 demo 中的 BIP32 lib,笔者对其做了部分修改. 1 . 随机生成一组助记词,这里我们使用的是12个英文单词 12345678public String generateMnemonics() &#123; StringBuilder sb = new StringBuilder(); byte[] entropy = new byte[Words.TWELVE.byteLength()]; new SecureRandom().nextBytes(entropy); new MnemonicGenerator(English.INSTANCE) .createMnemonic(entropy, sb::append); return sb.toString();&#125; 2 . 使用助记词计算出Seed,得到master key ,根据BIP44派生地址,获取KeyPair 1234567891011121314151617181920212223242526272829303132333435public ECKeyPair generateKeyPair(String mnemonics)&#123; // 1. we just need eth wallet for now AddressIndex addressIndex = BIP44 .m() .purpose44() .coinType(60) .account(0) .external() .address(0); // 2. calculate seed from mnemonics , then get master/root key ; Note that the bip39 passphrase we set "" for common ExtendedPrivateKey rootKey = ExtendedPrivateKey.fromSeed(new SeedCalculator().calculateSeed(mnemonics, ""), Bitcoin.MAIN_NET); Logger.i("mnemonics:" + mnemonics); String extendedBase58 = rootKey.extendedBase58(); Logger.i("extendedBase58:" + extendedBase58); // 3. get child private key deriving from master/root key ExtendedPrivateKey childPrivateKey = rootKey.derive(addressIndex, AddressIndex.DERIVATION); String childExtendedBase58 = childPrivateKey.extendedBase58(); Logger.i("childExtendedBase58:" + childExtendedBase58); // 4. get key pair byte[] privateKeyBytes = childPrivateKey.getKey(); ECKeyPair keyPair = ECKeyPair.create(privateKeyBytes); // we 've gotten what we need String privateKey = childPrivateKey.getPrivateKey(); String publicKey = childPrivateKey.neuter().getPublicKey(); String address = Keys.getAddress(keyPair); Logger.i("privateKey:"+privateKey); Logger.i("publicKey:"+publicKey); Logger.i("address:"+ Constant.PREFIX_16+address); return keyPair;&#125; 这里可以清晰看出,我们已经可以得到私钥,公钥,地址. 当前的钱包app基本上都用所有币种公用一套助记词, 然后可以分别生成不同的钱包地址, 如果需要测试助记词, 和校验助记词生成的地址, 那么可以访问这个网站 : https://iancoleman.io/bip39/ 我们需要校验的值主要为以上代码实例中打印日志的值. 3 . 通过keypair创建钱包 1234567891011121314public Flowable&lt;HLWallet&gt; generateWallet(Context context, String password, String mnemonics) &#123; Flowable&lt;String&gt; flowable = Flowable.just(mnemonics); return flowable .map(s -&gt; &#123; ECKeyPair keyPair = generateKeyPair(s); WalletFile walletFile = Wallet.createLight(password, keyPair); HLWallet hlWallet = new HLWallet(walletFile); WalletManager.shared().saveWallet(context,hlWallet); return hlWallet; &#125;);&#125; 完整调用 123456789101112131415Flowable .just(password) // 用户输入的密码 .filter(o -&gt; validateInput(password,repassword)) // 校验密码 .map(s -&gt; InitWalletManager.shared().generateMnemonics())// 生成随机助记词 .flatMap(s -&gt; InitWalletManager.shared().generateWallet(mContext,password,s))//创建钱包 .compose(ScheduleCompat.apply()) // 线程切换 .subscribe(new HLSubscriber&lt;HLWallet&gt;(mContext,true) &#123; @Override protected void success(HLWallet data) &#123; &#125; @Override protected void failure(HLError error) &#123; &#125; &#125;); 以上即为以太坊创建钱包的主要内容.主要先理解概念,然后着手coding,事半功倍. GitHub 系列教程代码已上传,如果对你有所帮助,请不吝点个star!]]></content>
      <categories>
        <category>Blockchain</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
        <tag>Ethereum</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter基础-(5)布局之单子widget]]></title>
    <url>%2Fflutter-layout-single%2F</url>
    <content type="text"><![CDATA[Flutter 有着丰富的布局控件库 . Flutter 中的布局整体分为 Single-child layout widget (单子布局部件) Multi-child layout widget (多子布局部件) 本篇我们将开始学习单子布局部件 . 类似于 Android 学习中有五大布局, 可是到实际开发中 , 用到的最多的只有线性布局、相对布局、帧布局. Flutter 布局单子部件官网学习文档列就有 18 种 , 在实际开发中未必能全用到 . 为了节省学习成本 , 各位童鞋可先重点掌握一二 , 其余浅尝辄止即可 . 先有个简单的了解认识 , 待后期有适合的应用场景时再深入挖掘 😐 为了更好的阅读体验 , 请点击 阅读原文 :) Container(重点)Container Widget 即容器 , 是一个常用的部件 . 官方对其定义如下 : 一个方便的小部件 , 它结合了常见的对小部件的绘制、定位和确定大小 一个 Container 首先有padding围绕着子部件 (图中深绿色部分) , 将宽高作为约束 . 然后 container 被额外的空白控件围绕, 叫做 margin. 其绘制顺序大致为: 先应用给定的变换 transform 然后绘制 decoration 再绘制子部件 child 最后绘制 foregroundDecoration transform 是指对widget在原有基础上做一些类似旋转、平移之类的变换 . decoration 以及 foregroundDecoration 是部件的 背景/前景 ‘装饰’ , 比如绘制部件的边框,背景图片等都是 decoration 和 foregroundDecoration中设置的 .下面我们用一段代码来说明: 123456789101112131415161718192021222324252627282930class DemoContainer extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; var imgUrl = "https://ws1.sinaimg.cn/large/006tNc79gy1fpa5bvsqskj3044048mx5.jpg"; return new Container( padding: const EdgeInsets.all(16.0), // 内边距 color: new Color(0xFFF2F2F2), // 背景色 alignment: Alignment.center, //子部件对齐方式 child: new Container( // 子部件 width: 400.0, //宽 height: 400.0, //高 // color 与 decoration 互斥 .如需设置decoration 和 color , 可在decoration中设置color // color: Colors.blueGrey, padding: const EdgeInsets.all(16.0), alignment: Alignment.center, decoration: new BoxDecoration( color: Colors.blueGrey, border: new Border.all( color: Colors.blue, width: 8.0, ), image: new DecorationImage(image: new NetworkImage(imgUrl)) ), child: new Text('Halcyon',style: const TextStyle(color: Colors.blue,fontSize: 24.0),), ) ); &#125;&#125; 效果图 : 首先导航栏下面整个是一个内边距padding 16 的灰色(#F2F2F2)背景的Container , 其唯一子部件是居中对齐的 . 然后我们主要说明的就是这个子部件 , 同样是个Container . 这个子 Container 宽高均为400 , 也设置了内边距 padding 16 (不过图中没有表现出来) .其 decoration 设置为拥有四周宽度为8的蓝色边框 . 并且有一个表情包图片作为容器背景 , 由于没指定图片拉伸方式 , 此时图片以原始大小居中显示 . 同时这个容器拥有一个内容为 ‘Halcyon’ 的文本子控件居中 . 由于以上提及的 Container 绘制顺序 , Container是先绘制 decoration , 再child ,再绘制 foregroundDecoration , 如若我们将代码中的 decoration 换成 foregroundDecoration , ‘Halcyon’ Text文本就会被 ‘前景装饰’ 中设置的图片覆盖了, 不可见. 布局行为 布局行为这个类似 Android 里View的 MeasureSpec 问题 . 可以先简单过一遍 , 等真正使用时, 结合实际例子进行理解. Container 布局行为顺序: 遵从 aligment 根据 子部件 child 确认自身大小 遵从 width , height , constraints 扩展以填充父部件 尽可能的小 没有子部件的 Container 会尽可能的大 , 除非传入的约束是无界的 , 这种情况它会尽可能的小 . 有子部件的 Container 根据子部件来确定大小 , 通过构造函数传入的 width , height 还有约束会将其覆盖 . 当然这段话理解起来有点模糊 . 我们来说的具体点 . 以下为 Container 各种情况下的大小 1. 若其无子部件 , 无宽高 , 没有约束 . 父部件提供了无界的约束 . Container将尽可能的小 . eg: 12345678@overrideWidget build(BuildContext context) &#123; return new UnconstrainedBox( child: new Container( color: Colors.blue, ) );&#125; 此时 Container将小到不可见 2. 若其无子部件 , 无排列 , 但是有宽高或者约束 , Container 将会在给定约束及父部件的约束结合下尽可能的小. eg: 1234567891011@overrideWidget build(BuildContext context) &#123; return new ConstrainedBox( constraints: new BoxConstraints(maxHeight: 50.0,minWidth: 200.0), child: new Container( width: 100.0, height: 100.0, color: Colors.blue, ) );&#125; 此时 Container宽50高200 3. 若其无子部件 , 无宽高 , 没有约束 , 没有排列 , 但是父部件提供了有界约束 . Container将会扩展至适应父部件提供的约束. eg: 123456789@overrideWidget build(BuildContext context) &#123; return new ConstrainedBox( constraints: new BoxConstraints(maxHeight: 50.0,maxWidth: 50.0), child: new Container( color: Colors.blue, ) );&#125; 此时 Container宽高50 4. 若其有 alignment , 还有父部件提供的无界约束 . Container会确认自身大小与子部件接近 eg: 12345678910111213@overrideWidget build(BuildContext context) &#123; return new UnconstrainedBox( child: new Container( color: Colors.blue, alignment: Alignment.center, child: new Container( width: 50.0, height: 50.0, ) ) );&#125; 此时 Container 与子Container同大小. 5. 若其有 alignment , 还有父部件提供的有界约束 . Container会尝试去扩展以适应父部件 , 然后按照对齐方式放置子部件. 6. 若其有子部件 , 但是无宽高 ,约束 以及对齐方式 , 那么 Container 将约束从父部件传递给子部件,并将自身大小与子部件匹配 Padding可给子部件内嵌边距padding的部件 与 Container 容器设置 padding 属性无太大差别. eg: 123456789101112@overrideWidget build(BuildContext context) &#123; return new Container( color: Colors.blueGrey, child: new Padding( padding: new EdgeInsets.all(16.0), child: const Card(color: Colors.white, child: const Text('halcyon'), ), ), );&#125; Center置子部件居中的部件 eg: 123456789101112131415161718@overrideWidget build(BuildContext context) &#123; return new Container( width: 300.0, height: 300.0, color: Colors.grey, child: new Center( widthFactor: 1.0, // 设置Center Widget 的宽为child widget的宽度倍数 . eg: 1.0 代表同子控件大小 heightFactor: 1.0, // 同上 , 作用于高 child: new Container( child: const Text('Center Words'), color: Colors.lightBlue, ), ), );&#125; Align在内部对齐子部件的部件, 根据子部件大小决定自身大小 123456789@overrideWidget build(BuildContext context) &#123; return new Center( child: new Align( alignment: Alignment.centerRight, child: const Text('Halcyon',style: const TextStyle(color: Colors.blue ,fontSize: 24.0),), ), );&#125; ‘Halcyon’文本位于父部件中右方 FittedBox根据 BoxFit 对子部件拉伸及定位 BoxFit.none 对齐目标盒子中的元素 (默认居中) , 然后丢弃盒外的元素. 图片元素不会被拉伸. BoxFit.contain 尽可能地大,同时包含完整的目标盒子 BoxFit.cover 尽可能地小,但仍覆盖目标盒子 BoxFit.fill 比例拉伸以填充目标盒子 BoxFit.fitHeight 确保显示目标的全部高度,忽视横向是否显示完整 BoxFit.fitWidth 确保显示目标的全部宽度,忽视纵向是否显示完整 scaleDown 对其目标(默认居中),如果需要,则会缩放目标使其在盒子内 AspectRatio(重点) 尝试给子部件指定比例确认大小. eg: 123456789101112@overrideWidget build(BuildContext context) &#123; return new Container( color: Colors.blueGrey, alignment: Alignment.center, child: new AspectRatio( aspectRatio: 3.0 / 1.0, // ratio = 宽 / 高 , child: new Container( color: Colors.purple, ),) );&#125; 代码中所示为 Container1 &gt; AspectRatio &gt; Container2 的布局层次 , AspectRatio布局指定了子布局宽高比属性 aspectRatio 为 3.0 / 1.0 , 又因为未指定部件大小 , 部件默认填充父部件 , 因此 Container2 宽为屏幕宽度 , 高为宽的 1/3 . ConstraintedBox(重点)用以给子部件添加额外约束. 比如可以给子部件添加一个最低高度50像素 eg: 123456789101112@overrideWidget build(BuildContext context) &#123; return new Container( color: Colors.blueGrey, alignment: Alignment.center, child: new ConstrainedBox( constraints: new BoxConstraints(minHeight: 100.0,maxHeight: 300.0,minWidth: 100.0,maxWidth: 300.0), child: const Card(child: const Text('Halcyon Days', style: const TextStyle(color: Colors.teal, fontSize: 24.0)),), ), );&#125; 代码示例中 , 我们给予 Card部件添加了一个最小宽/高度100.0 , 最大宽/高度300.0 . 当 ‘ Halcyon Days ‘ 文本变化时,其宽高始终在 [100,300] 的中变化 . Baseline 顾名思义 , 就是根据子部件基线进行定位. FractionallySizedBox(重点)百分比布局 eg: 1234567891011121314@override Widget build(BuildContext context) &#123; return new Container( color: Colors.blueGrey, alignment: Alignment.center, child: new FractionallySizedBox( widthFactor: 0.5, heightFactor: 0.5, child: new Container( color: Colors.teal, ), ), ); &#125; 代码示例中 Container1 &gt; FractionallySizedBox &gt; Container2 . Container2 宽高均为 Container1 的一半 IntrinsicHeight当高度不受限制时, 我们希望子部件保持一个合理的高度而不是去尝试无限扩张 , 这个时候我们可以用 IntrinsicHeight ,不过这个类消耗较多 , 不建议使用 IntrinsicWidth当宽度不受限制时, 我们希望子部件保持一个合理的宽度而不是去尝试无限扩张 , 这个时候我们可以用 IntrinsicWidth ,不过这个类消耗较多 , 不建议使用 LimitedBox当不受约束时限制大小 Offstage在其中的子部件不会被绘制,也不会占用空间.当offstage 属性为false时将会渲染子部件 eg: 12345678910111213141516171819202122@overrideWidget build(BuildContext context) &#123; return new Column( children: &lt;Widget&gt;[ new Container( height: 200.0, color: Colors.grey, ), new Offstage( offstage: true, // 默认为true , child: new Container( height: 100.0, color: Colors.pink, ), ), new Container( height: 100.0, color: Colors.teal, ) ], );&#125; 以上示例 , 当 offstage 为 true时(默认), Offstage部件及其子部件将不会绘制, 类似Android 中给View设置Visibility为View.GONE一样; 而 offstage 为 false时, 将会绘制 OverflowBoxOverflowBox会给子部件施加一个与其自身从父部件直接获取的不同的约束,可能会使得其溢出父部件 SizedBox有着明确尺寸的盒模型 SizedOverflowBox有着明确尺寸的盒模型,但是会传递原始约束给子部件,可能会溢出 Transform(重点)Transform在绘制子部件之前将应用变换效果 eg: 123456789101112131415161718@overrideWidget build(BuildContext context) &#123; return new Container( color: Colors.grey, alignment: Alignment.center, child: new Transform( alignment: Alignment.topRight, transform: new Matrix4.rotationZ(50.0), child: new Container( padding: const EdgeInsets.all(8.0), height: 200.0, width: 200.0, color: Colors.teal, child: const Text('halcyon'), ), ), );&#125; CustomSingleChildLayout(重点)]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[专栏:Flutter教程]]></title>
    <url>%2Fflutter-toc%2F</url>
    <content type="text"><![CDATA[Flutter 是一款谷歌用以同时在 iOS 和 Android 上制作高质量原生界面的移动应用UI框架.目前谷歌是已发布了 Flutter Beta 版 . 类似于 Fackbook 的 React Native , 我们可用 Flutter 开发一套代码,应用于 Android 以及 iOS 平台上.不仅如此, Flutter 还可应用于谷歌将推出的新系统 Fuchsia . 可以看出 , Flutter 确有统一移动端的能力 , 身为移动开发者 , 当然要有所了解 . 本栏相关文章内容主要是参考 Flutter 的 官方文档 . 官网的文章学习自由度很高 , 这里梳理了下我们将要学习的内容 , 目录如下, 期间可能进行调整 . 如有同学想了解本栏目未涵盖的内容 , 可以邮件lh_halcyondays@163.com, 或者直接提 Issue , 作者将筛选后进行更新. 基础 Flutter基础-(1)环境搭建及demo运行 Flutter基础-(2)基本概念及首个应用 Flutter基础-(3)widget-文本Text Flutter基础-(4)widget-图片Image Flutter基础-(5)布局之单子widget Flutter基础-(6)布局之多子widget Flutter基础-(7)手势 Flutter基础-(8)动画 Flutter基础-(9)资源和图片 Flutter基础-(10)文本输入 进阶 Flutter进阶-(1)路由和导航 Flutter进阶-(2)网络请求 Flutter进阶-(3)JSON和序列化 Flutter进阶-(4)特定平台处理 Flutter进阶-(5)读写文件 Flutter进阶-(6)主题切换 Flutter进阶-(7)自定义字体 Flutter进阶-(8)国际化 应用 Flutter实战-以太坊钱包 Flutter实战-BottomNavigationBar … Flutter实战-(n)发布Android Flutter实战-(n+1)发布iOS 个人精力有限 , 更新周期可能稍长一些 , 但是会尽量将学习过程写的详细 , 以及将开发过程中遇到的坑明示出来 . 为后面进入 Flutter 的小友们垫下基石 :)]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter基础-(4)widget-图片Image]]></title>
    <url>%2Fflutter-widget-image%2F</url>
    <content type="text"><![CDATA[本篇将讲解图片加载及特定平台图片处理. 为了更好的阅读体验 , 请点击 阅读原文 概览Image 是用来展示图片的 widget. 系统提供着不同方式去构造 Image : new Image, 从 ImageProvider 获取图片 new Image.asset , 从 AssetBundle 获取图片 new Image.network , 从网络获取图片 new Image.file , 从File获取图片 new Image.memory , 从 Uint8List 获取图片 Image 支持以下图片格式 : JPEG , PNG ,GIF , 动态 GIF , WebP , 动态WebP , BMP WBMP . 直接上示例 图中三个示例分别表示 从Assets加载图片 从网络加载图片并缓存在内存中 从网络加载图片并缓存在内存中且以渐现动画的形式展示 . 1 类似 Android 从 mipmap或drawable 下获取图片; iOS 从Assets.xcassets 中读取图片 2 常规的从网络加载图片,可选缓存在文件或者内存中. 3 移动应用中常用的图片展示效果. Assets加载图片Flutter 使用 pubspec.yaml文件定位项目根目录,识别app所需要的资产 示例: 123flutter: assets: - assets/images/ic_link.png 注意此处资产路径是根目录下的路径.示例中assets和源码lib是同级目录 加载代码: 1234567891011Widget build(BuildContext context) &#123; // ... var imageAssets = 'assets/images/ic_link.png'; return new Image.asset( imageAssets, width: 150.0, height: 150.0, ) ); // ...&#125; 或 1234567891011Widget build(BuildContext context) &#123; // ... var imageAssets = 'assets/images/ic_link.png'; return new Image( image: new AssetImage(imageAssets), width: 150.0, height: 150.0, ) ); // ...&#125; 以上为加载当前项目中的资产图片.当从依赖包中加载图片时,需要加上依赖包名 例如我们的应用依赖三方包 flutter_gallery_assets ,它有着以下目录结构 …/pubspec.yaml …/lib/ali_connors.png 我们就需要用以下代码来加载图片 1new AssetImage('ali_connors.png', package: 'flutter_gallery_assets') 同时还需要去 pubspec.yaml 文件中申明 123assets: - assets/images/ic_link.png - packages/flutter_gallery_assets/ali_connors.png 注意: ali_connors.png 文件路径其实为 flutter_gallery_assets-版本号/lib/ali_connors.png 其中lib作为三方包时是隐式包含了, 不需要我们自己添加 File加载图片直接上代码 123456789101112Widget build(BuildContext context) &#123; // ... var imagePath = '/Users/xx/Downloads/cow.png'; return new Image( image: new FileImage(new File(imagePath)), repeat: ImageRepeat.noRepeat, width: 150.0, height: 150.0, ) ); // ...&#125; 注意: 这里imagePath作为绝对路径读的是计算机上的图片地址 , 找不到本机图片时不会显示 . 因为平台关系 , 相对路径一般访问不到 , 需要通过三方包 path_provider 来提供与平台无关的访问设备文件的方法.届时还需要将图片导入到设备中 ,此处就不作展开 网络加载图片应用中网络加载图片的场景许多 , 先给出一个简单的示例: 1234567891011Widget build(BuildContext context) &#123; // ... var imgUrl = 'https://ws1.sinaimg.cn/large/006tNc79gy1fpa5bvsqskj3044048mx5.jpg'; return new Image.network( imgUrl, width: 150.0, height: 150.0, ) ); // ...&#125; 或 1234567891011Widget build(BuildContext context) &#123; // ... var imgUrl = 'https://ws1.sinaimg.cn/large/006tNc79gy1fpa5bvsqskj3044048mx5.jpg'; return new Image( image: new NetworkImage(imgUrl), width: 150.0, height: 150.0, ) ); // ...&#125; 这种只是简单的加载网络图片,若图片较大,或者网络卡顿.图片显示的效果就显得很突兀(可参考上面gif ) , 此时我们需要给图片呈现加一段渐现的Fading动画. FadeInImage FadeInImage更符合应用中的场景 , 渐现呈现网络图片,并且缓存到内存 12345678910111213141516import 'package:transparent_image/transparent_image.dart';Widget build(BuildContext context) &#123; // ... var imgUrl = 'https://ws1.sinaimg.cn/large/006tNc79gy1fpa5bvsqskj3044048mx5.jpg'; return new FadeInImage.memoryNetwork( placeholder: kTransparentImage, image: imgUrl, width: 150.0, height: 150.0, fadeInDuration: const Duration(milliseconds: 1200), fadeOutDuration: const Duration(milliseconds: 1200), ) ); // ...&#125; 示例效果请参考上面的gif效果图 , 其中用到了三方库 transparent_image 主要作用是使用其透明图片作为占位图 可使用 FadeInImage.assetNetwork 实现文件缓存. 若想实现 Android 中 Glide ,Picasso , iOS 中 Kingfisher 这样的图片三级缓存框架 , 就需要自行封装实现了. 这里我们可以发现 , 我们未主动地在Android应用清单文件中申明网络权限,Flutter默认已经授予了网络权限用以提供热部署等等. 分辨率处理手机有不同的像素比率 , 这时就需要根据手机的像素比率来加载不同图片 . 做法很简单,只需要在图片同级目录下创建 2.0x/abc.png 和 3.0x/abc.png 的目录即可 在 pubspec.yaml 中定义的assets路径不需要增加 2.0x 3.0x 例如以前图片是 123flutter: assets: - assets/images/ic_link.png 加入分辨率目录后不变 , 依然是该路径 特定平台图片对于 Android , iOS 特定平台的资产图片需要我们去对应的平台文件夹下去设置 . 以下为两个常见的场景 , 我们将在Flutter框架运行前使用到图片资产 更新应用图标更新应用图标的方式与在开发原生Android,iOS应用时一样. Android 在项目根目录下的 .../android/app/src/main/res里,默认应用图标为ic_launcher.png ,可分别替换对应分辨率下的图片从而更新应用图标 iOS 在项目根目录下的 .../ios/Runner/Assets.xcassets/AppIcon.appiconset , 替换相应图片从而更新应用图标 更新启动页Android Flutter 默认设置了个启动页 .../android/app/src/main/res/drawable/launch_background.xml . 可通过修改该文件来定制个性化的元素 iOS 在 .../ios/Runner/Assets.xcassets/LaunchImage.imageset , 放置LaunchImage.png ,LaunchImage@2x.png , LaunchImage@3x.png. 若用到不同的文件名称 , 需要在同目录下更新 Contents.json中的文件名称 还可以通过打开…/ios/Runner.xcworkspace , 来完全定制启动屏幕storyboard . 好了, 关于 Image 的部分就讲到这里了. 相关代码已经上传 GitHub ,如有帮到你, 请不吝点个Star🤗]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter基础-(3)Widget-文本Text]]></title>
    <url>%2Fflutter-widget-text%2F</url>
    <content type="text"><![CDATA[本来打算第三篇文章来讲解 Flutter 单子布局widget , 奈何 18种单子布局widget 内容颇多,加之年后有了新项目要开发 , 使得文章产出周期被拉长 :( . 这里先来篇简单的关于Text的文章 , 下次更新将会发出 Flutter系列的目录及布局widget的文章. TextText 文本是app里常见的控件 , 用以显示一串单一样式的文本 . 该字符串可跨越多行 , 或根据布局约束显示在同一行中 最简单的可以直接用这样的代码来展示文本 , 类似 Android 里的 TextView , iOS 里的 UILabel . 1new Text('简单的文本') 代码未指定样式 , 此时将使用最近的 DefaultTextStyle 样式 . 若给定样式中 TextStyle.inherit 属性为true , 给定样式则将与最近的 DefaultTextStyle 样式合并 . 类似 Android 里 , style.xml 主题样式 AppTheme 中定义了文本样式 , 并且将其设置为 Application 的主题样式 , 那么新建一个 TextView 就会默认使用 AppTheme中定义的文本样式 , 而当给这个 TextView 设置样式时,此样式就会和主题样式进行合并 当 TextStyle.inherit 属性设置为 false 时 , 文本样式会恢复到默认状态: 白色, 10像素 , sans-serif 字体 12345final TextStyle _inheritBigFont = new TextStyle(inherit: true, fontSize: 24.0);final TextStyle _notInheritBigFont = new TextStyle(inherit: false, fontSize: 24.0);...new Text('inherit true', style: widget._inheritBigFont)new Text('inherit false', style: widget._notInheritBigFont) 文本样式鸟瞰 RichText要显示多样式的文本 , 需要使用富文本 RichText 在开发中 , 有一些常见的应用场景需要用到富文本 . 比如在很多 app 注册 ,开户界面会有一个同意协议的模块 , 我已阅读并同意《xxx协议》 , 协议名称通常高亮显示并且可以点击打开协议页面 . 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import 'package:flutter/gestures.dart';import 'package:flutter/material.dart';class DemoText extends StatefulWidget &#123; final TextStyle _protocolFont = new TextStyle(fontSize: 16.0); final TextStyle _inheritBigFont = new TextStyle(inherit: true, fontSize: 24.0); final TextStyle _notInheritBigFont = new TextStyle(inherit: false, fontSize: 24.0); @override DemoTextState createState() &#123; return new DemoTextState(); &#125;&#125;class DemoTextState extends State&lt;DemoText&gt; &#123; @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: new AppBar( title: const Text('Text Demo'), ), body: new Builder(builder: builderBody)); &#125; Widget builderBody(BuildContext context) &#123; final TapGestureRecognizer recognizer = new TapGestureRecognizer(); recognizer.onTap = () &#123; Scaffold.of(context).showSnackBar(new SnackBar( content: new Text('协议被点击!'), )); &#125;; final Divider divider = new Divider(color: Colors.white, height: 2.0); return new Container( color: Colors.grey, alignment: Alignment.center, child: new Column( children: &lt;Widget&gt;[ new Text('inherit true', style: widget._inheritBigFont), new Text('inherit false', style: widget._notInheritBigFont), divider, new Text( '龙骑士囧雪诺JohnSnow', style: new TextStyle( color: Colors.blue, fontSize: 24.0, fontStyle: FontStyle.italic, letterSpacing: 2.0, decoration: TextDecoration.underline), ), divider, new RichText( text: new TextSpan( text: '我已阅读', style: widget._protocolFont, children: &lt;TextSpan&gt;[ new TextSpan( text: '《从flutter入门到放弃》', style: new TextStyle(color: Colors.redAccent), recognizer: recognizer), ], ), ), ], )); &#125;&#125; TapGestureRecognizer 是手势识别者 , 后面讲到手势时再具体说明 . 这里我们先知道它可以用来给富文本某一段添加点击事件 . 这里我们点击协议后 , 会弹出一个SnackBar提示协议被点击了 .]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter基础-(2)基本概念及首个应用]]></title>
    <url>%2Fflutter-basic-concept%2F</url>
    <content type="text"><![CDATA[在 上一篇文章 中,我们讲解了 Flutter 开发环境搭建 , 以及运行了官方demo简单体验了下 Flutter app . 此篇我们将开始对一些 Flutter app 中的一些基本概念进行讲解 , 一些基本的操作做一些示例 , 主要是参考官网的教程 Write Your First Flutter App 若你对面向对象编程熟悉,以及对基本编程概念如变量、循环、条件了解 , 则适合阅读本篇文章 . 不必需要拥有 Dart 或移动编程经验. 为了更好的阅读体验 , 请点击 阅读原文 :) 步骤 1 : 创建及启动 Flutter app 步骤 2 : 使用一个外部的程序包 步骤 3 : 增加一个 Stateful Widget 步骤 4 : 创建一个无限滚动的 ListView 步骤 5 : 增加交互 步骤 6 : 跳转到新页面 步骤 7 : 通过主题改变UI 完成! 我们将创建什么我们将实现一个简单的移动应用 , 它会生成创业公司的名称 . 用户可以选择和反选名称 , 保存喜好的那些 . 代码一次生成 10 个名称 . 当用户滑动时 , 新一批的名称就会生成 . 用户可以点击导航栏右上的按钮进入一个只展示喜好的名称的列表新页面. 我们将学到: Flutter app 的基本结构 使用额外的包去拓展功能 使用热部署来快速开发 如何去实现一个stateful 小部件 如何创建一个无线滑动,懒加载的列表 如何跳转去下一个界面 如果通过主题去修改app外观 步骤 1 : 创建及启动 Flutter app这里创建一个简单的 flutter app 123flutter create flutter_first_appcd flutter_first_appflutter run 如有疑问 , 可参考 前一篇文章 指引 简单地 , 我们先将 lib/main.dart中的代码全部删除 , 替换为以下代码 , 其主要就是在屏幕中间展示 ‘Hello World’ . 1234567891011121314151617181920import 'package:flutter/material.dart';void main() =&gt; runApp(new MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new MaterialApp( title: 'Welcome to Flutter', home: new Scaffold( appBar: new AppBar( title: new Text('Welcome to Flutter'), ), body: new Center( child: new Text('Hello World'), ), ), ); &#125;&#125; 重新运行得到结果 发现 这个例子创建了一个 Material Design 风格的app . Material 是一种在移动端及web上标准的视觉设计语言 . Flutter 提供了丰富的 Material 风格小部件 main 方法使用了一个大箭头=&gt;写法 , 它是一行代码功能或方法的缩写 . 同许多语言开发一样, main() 方法为程序入口 . app 继承 StatefulWidget 使得其自身也是个widget . 在 Flutter 里 , 大多数元素都是 widget , 包括对齐方式(alignment)、 内边距(padding)、布局(layout) . Material 库 中的脚手架小部件 (Scaffold widget) , 提供了一个默认的导航栏、 标题、 内容属性在屏幕中维持了部件树🌲.部件子树可以很复杂. 一个小部件的主要工作就是提供 build()方法 , 它是用来表明如何展示其他低层级的widget. 这个示例的部件树由 包含一个 Text 子部件 的Center Widget 组成 . 这个 Center Widget 将其子部件树排列在屏幕中间 . 步骤 2 : 使用一个外部的程序包在这个步骤里 , 我们将开始使用一个开源程序包 english_words , 它包含了较多的常用的英文单词还有一些工具方法 . 我们可以在 pub.dartlang.org 找到 english_words 及 其他开源程序包 1. pubspec 文件负责管理 Flutter 应用的资源. 在 pubspec.yaml 文件中,添加 english_words(3.1.0或更高版本)到依赖里. 123456dependencies: flutter: sdk: flutter cupertino_icons: ^0.1.0 english_words: ^3.1.0 2. 当我们在IDEA 视图中 , 修改yaml文件后 , 可点击右上方的 Packages get 使之生效.它会拉取我们才添加的依赖包, 控制台中打印 123flutter packages getRunning "flutter packages get" in flutter_first_app...Process finished with exit code 0 3. 在 lib/main.dart文件中,添加 import 语句 , 导入依赖相关类 1import 'package:english_words/english_words.dart'; 4. 用开源库生成文本代替原来的 ‘Hello World’ 1234567891011121314151617181920212223import 'package:flutter/material.dart';import 'package:english_words/english_words.dart';void main() =&gt; runApp(new MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; final wordPair = new WordPair.random(); return new MaterialApp( title: 'Welcome to Flutter', home: new Scaffold( appBar: new AppBar( title: new Text('Welcome to Flutter'), ), body: new Center( //child: new Text('Hello World'), // Replace the highlighted text... child: new Text(wordPair.asPascalCase), // With this highlighted text. ), ), ); &#125;&#125; 5. 若app正在运行, 可以通过点击⚡️按钮进行热部署. 每次点击或者保存时 , 会生成新的一个随机单词. 这是因为单词是在 build(...) 方法中生成, 它会在每次 MaterialApp 需要渲染或触发平台检视时执行. 步骤 3 : 增加一个 Stateful WidgetStateless widgets 是不可变的 , 意味着其属性是不可改变的 - 所有值均为final . Stateful widgets 维持着生命周期中可变的状态 . 实现一个 stateful widget 需要至少两个类: 一个 State 类 和 一个创建State示例的 StatefulWidget . StatefulWidget本身是不可变的 , 但是 State 类在widget生成周期中一直存留 . 在这个步骤里 , 我们将添加一个 stateful widget - RandomWords , 它创建自己的 State 类 - RandomWordsState . state 类将为widget最终维持建议的和喜好的单词. 1. 添加 stateful RandomWords 到 main.dart 1234class RandomWords extends StatefulWidget &#123; @override createState() =&gt; new RandomWordsState();&#125; 2. 添加 RandomWordsState . 大部分app的代码会在这个类中 , 将维持着 RandomWords 部件的状态 . 这个类将会保存生成的词对 , 它们随着用户滑动页面无线增加 . 然后喜好的词对 , 用户通过点击列表的心形按钮进行添加或移除 . 我们一步一步来创建这个类 12class RandomWordsState extends State&lt;RandomWords&gt; &#123;&#125; 3. 在添加 state 类后 , IDE会提示错误, 需要我们取实现未实现的方法 . 1234567class RandomWordsState extends State&lt;RandomWords&gt; &#123; @override Widget build(BuildContext context) &#123; final wordPair = new WordPair.random(); return new Text(wordPair.asPascalCase); &#125;&#125; 4. 移除单词生成代码 , 1234567891011121314151617class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new MaterialApp( title: 'Welcome to Flutter', home: new Scaffold( appBar: new AppBar( title: new Text('Welcome to Flutter'), ), body: new Center( child: new RandomWords(), ), ), ); &#125;&#125; 步骤 4 : 创建一个无限滚动的 ListView这个步骤里, 我们将扩充 RandomWordsState 类 来生成和展示单词对的列表. 当用户滑动页面, ListView widget 展示的列表将会无限增加. ListView 的 builder 工厂构造器允许我们视需懒加载创建列表视图 1. 在 RandomWordsState 类中添加成员变量 _suggestions 列表用来保存推荐的单词对.在 Dart 语言中 , 以 _下划线开头的变量/方法为私有访问权限. 同样的 , 添加 biggerFont 变量用来使字体大小更大 123456class RandomWordsState extends State&lt;RandomWords&gt; &#123; final _suggestions = &lt;WordPair&gt;[]; final _biggerFont = const TextStyle(fontSize: 18.0); ...&#125; 2 ~ 3. 添加 _buildSuggestions()方法到 RandomWordsState 类中. 此方法负责构建列表 ListView 和展示建议的单词对. ListView 类提供了一个 builder 属性 , itemBuilder 一个工厂构建者和指定匿名函数的回调功能.两个参数被传递给函数- BuildContext 还有行迭代器 i . 迭代器从 0 开始且每次方法调用递增. 添加 _buildRow 方法 123456789101112131415161718192021Widget _buildSuggestions() &#123; return new ListView.builder( // padding 16 padding: const EdgeInsets.all(16.0), // 每一对单词对调用一次itemBuilder 回调 ,然后放置一个推荐的单词对在行内 // 偶数行 , 函数增加个内容行显示单词对, // 奇数行 , 函数添加一条分割线小部件 (Divider Widget)去显示分割条目 itemBuilder: (context, i) &#123; if (i.isOdd) return new Divider(); // index 为 i/2 的余整数 final index = i ~/ 2; if (index &gt;= _suggestions.length) &#123; // ...生成10个词对,添加到list _suggestions.addAll(generateWordPairs().take(10)); &#125; return _buildRow(_suggestions[index]); &#125; ); &#125; 4. 更新 RandomWordsState 的 build 方法 , 使用 _buildSuggestions ,不再直接使用调用单词生产库. 12345678910111213class RandomWordsState extends State&lt;RandomWords&gt; &#123; ... @override Widget build(BuildContext context) &#123; return new Scaffold ( appBar: new AppBar( title: new Text('Startup Name Generator'), ), body: _buildSuggestions(), ); &#125; ...&#125; 5. 更新 MyApp 的 build 方法 . 从 MyApp 中移除 Scaffold 和 AppBar 实例. 这些将会被 RandomWordsState 管理 ,这样将更容易地在下个步骤页面跳转时去改变导航栏上的名称. 123456789class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new MaterialApp( title: 'Startup Name Generator', home: new RandomWords(), ); &#125;&#125; 步骤 5 : 增加交互这个步骤中 , 我们将增加可点击的心形图标到每一行 . 当用户点击列表条目时 , 触发其 “favorite” 状态 ,状态改变会将对应单词对添加到保存的集合或从中移除 1. 添加 _saved 集合到 RandomWordsState 里 . 集合存储用户喜好的单词对 , 更倾向于用 Set 是因为 Set 中不允许有重复的条目 12345678class RandomWordsState extends State&lt;RandomWords&gt; &#123; final _suggestions = &lt;WordPair&gt;[]; final _saved = new Set&lt;WordPair&gt;(); final _biggerFont = const TextStyle(fontSize: 18.0); ...&#125; 2. 在 _buildRow 函数里 , 添加 alreadySaved 变量来检查确保单词对还未被添加到喜好的集合中. 1234Widget _buildRow(WordPair pair) &#123; final alreadySaved = _saved.contains(pair); ...&#125; 3 ~ 4. 还是在_buildRow 里 , 添加心形图标 . 重启应用 , 我们可以看到心形已被添加 , 只是暂时没有交互事件 12345678910111213Widget _buildRow(WordPair pair) &#123; final alreadySaved = _saved.contains(pair); return new ListTile( title: new Text( pair.asPascalCase, style: _biggerFont, ), trailing: new Icon( alreadySaved ? Icons.favorite : Icons.favorite_border, color: alreadySaved ? Colors.red : null, ), );&#125; 5. 在_buildRow 中设置心形可点击. 如果一个单词条目被添加到喜欢的集合时, 再次单击它就能从喜欢的集合中移除 . 当心形被点击 , 函数会调用 setState()去通知框架状态被改变了. 12345678910111213141516171819202122Widget _buildRow(WordPair pair) &#123; final alreadySaved = _saved.contains(pair); return new ListTile( title: new Text( pair.asPascalCase, style: _biggerFont, ), trailing: new Icon( alreadySaved ? Icons.favorite : Icons.favorite_border, color: alreadySaved ? Colors.red : null, ), onTap: () &#123; setState(() &#123; if (alreadySaved) &#123; _saved.remove(pair); &#125; else &#123; _saved.add(pair); &#125; &#125;); &#125;, );&#125; 在 Flutter react式的框架中 , 调用 setState() 会为 State 对象触发 build() 方法 , 最后更新到UI上. 步骤 6 : 跳转到新页面在这个步骤里 , 我们将添加一个页面 (在Flutter里叫 route ) 展示喜好的推荐词对 . 我们将学到如何从主页面导航到新页面 . 在 Flutter 中 , Navigator 管理着一个包含app页面的栈 . 推送一个页面进入 Navigator 的栈中, 则会更新显示这个页面 . 从 Navigator栈中推出一个页面 , 则会显示上一个页面 . 1 ~ 3. 在 RandomWordsState 的 build 方法中给 AppBar 添加一个列表图标 . 当用户点击图标 , 一个包含喜好列表的页面会被推送呈现 . 12345678910111213141516class RandomWordsState extends State&lt;RandomWords&gt; &#123; ... @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: new AppBar( title: new Text('Startup Name Generator'), actions: &lt;Widget&gt;[ new IconButton(icon: new Icon(Icons.list), onPressed: _pushSaved), ], ), body: _buildSuggestions(), ); &#125; ...&#125; 然后在 RandomWordsState 中添加 _pushSaved方法 12345class RandomWordsState extends State&lt;RandomWords&gt; &#123; ... void _pushSaved() &#123; &#125;&#125; 4 ~ 6. 添加 MaterialPageRoute 及它的 builder . 添加代码生成 ListTile 行 . ListTile 的divideTiles() 方法在每一条条目间增加水平距离 . divided 变量保存着最终的行 , 通过函数 toList() 转换为列表 builder 属性返回一个 Scaffold , 包含了新页面的导航栏 ,名为 “Saved Suggestion” .新页面的内容部分由 ListView包含 ListTiles 行组成 , 每一行由一个 divider 分隔 . 123456789101112131415161718192021222324void _pushSaved() &#123; Navigator.of(context).push( new MaterialPageRoute( builder: (context) &#123; final tiles = _saved.map( (pair) &#123; return new ListTile( title: new Text( pair.asPascalCase, style: _biggerFont, ), ); &#125;, ); final divided = ListTile .divideTiles( context: context, tiles: tiles, ) .toList(); &#125;, ), );&#125; 步骤 7 : 通过主题改变UI在这个最终步骤中, 我们将改变app的主题 . 1. 我们可以简单地通过配置 ThemeData 类 改变app的主题 . 当前app是默认主题, 我们将改变主色为紫色 123456789101112class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new MaterialApp( title: 'Startup Name Generator', home: new RandomWords(), theme: new ThemeData( primaryColor: Colors.purple ), ); &#125;&#125; 最后贴一下 main.dart 完整代码 , 方便小友们查看 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123import 'package:flutter/material.dart';import 'package:english_words/english_words.dart';void main() =&gt; runApp(new MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new MaterialApp( title: 'Startup Name Generator', home: new RandomWords(), theme: new ThemeData(primaryColor: Colors.purple), ); &#125;&#125;class RandomWords extends StatefulWidget &#123; @override createState() =&gt; new RandomWordsState();&#125;class RandomWordsState extends State&lt;RandomWords&gt; &#123; final _suggestions = &lt;WordPair&gt;[]; final _saved = new Set&lt;WordPair&gt;(); final _biggerFont = const TextStyle(fontSize: 18.0); Widget _buildSuggestions() &#123; return new ListView.builder( // padding 16 padding: const EdgeInsets.all(16.0), // 每一对单词对调用一次itemBuilder 回调 ,然后放置一个推荐的单词对在行内 // 偶数行 , 函数增加个内容行显示单词对, // 奇数行 , 函数添加一条分割线小部件 (Divider Widget)去显示分割条目 itemBuilder: (context, i) &#123; if (i.isOdd) return new Divider(); // index 为 i/2 的余整数 final index = i ~/ 2; if (index &gt;= _suggestions.length) &#123; // ...生成10个词对,添加到list _suggestions.addAll(generateWordPairs().take(10)); &#125; return _buildRow(_suggestions[index]); &#125;); &#125; Widget _buildRow(WordPair pair) &#123; final alreadySaved = _saved.contains(pair); return new ListTile( title: new Text( pair.asPascalCase, style: _biggerFont, ), trailing: new Icon( alreadySaved ? Icons.favorite : Icons.favorite_border, color: alreadySaved ? Colors.red : null, ), onTap: () &#123; setState(() &#123; if (alreadySaved) &#123; _saved.remove(pair); &#125; else &#123; _saved.add(pair); &#125; &#125;); &#125;, ); &#125; @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: new AppBar( title: new Text('Startup Name Generator'), actions: &lt;Widget&gt;[// new IconButton(icon: new Icon(Icons.colorize),onPressed: _changeTheme), new IconButton(icon: new Icon(Icons.list), onPressed: _pushSaved) ], ), body: _buildSuggestions(), ); &#125; void _changeTheme()&#123; &#125; void _pushSaved() &#123; Navigator.of(context).push( new MaterialPageRoute( builder: (context) &#123; final tiles = _saved.map( (pair) &#123; return new ListTile( title: new Text( pair.asPascalCase, style: _biggerFont, ), ); &#125;, ); final divided = ListTile .divideTiles( context: context, tiles: tiles, ) .toList(); return new Scaffold( appBar: new AppBar( title: new Text('Saved Suggestions'), ), body: new ListView(children: divided), ); &#125;, ), ); &#125;&#125; 完成!至此 , 我们第一个 app 已经完成 . GitHub 地址 功能相对来说较简单 , 但是大体上让我们对开发 Flutter app 有了一定了解. 之后我们将延续阅读官网的教程 , 开始较全面地了解构建UI相关的部分.]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter基础-(1)环境搭建及demo运行]]></title>
    <url>%2Fflutter-basic-env%2F</url>
    <content type="text"><![CDATA[Flutter 是一款谷歌用以同时在 iOS 和 Android 上制作高质量原生界面的移动应用UI框架.目前谷歌是已发布了 Flutter Beta 版,同时也提供了多个 Sample Project 供学习. Flutter 主要有着快速开发、有表现力及灵活的UI、原生表现等特点. 快速开发 极速热部署就能使app构建生效,使用大量可深度自定义化的小部件 (Widgets) 供快速开发原生界面. 有表现力及灵活的UI 快速地将特性集中在客户端用户体验上.分层体系结构允许深度定制,最终呈现快速渲染以及有表现力和灵活的设计 原生表现 Flutter的小部件包含了所有关键的平台差异,如滚动、导航、图标和字体,以在iOS和Android上提供完整的原生表现 类似于 Fackbook 的 React Native , 我们可用 Flutter 开发一套代码,应用于 Android 以及 iOS 平台上.不仅如此, Flutter 还可应用于谷歌将推出的新系统 Fuchsia . 可以看出 , Flutter 确有统一移动端的能力 , 身为移动开发者 , 当然要有所了解. so , 接下来我们将开始 搭建开发环境 , 并且运行官方的 demo 为了更好的阅读体验, 请点击阅读原文 :) 安装首先进入 Flutter Install 选择相应操作系统下的安装包进行安装 首先此处有个温馨小点 , 谷歌为中国开发者准备了国内镜像,为图中的链接 this wiki article . 主要是配置两个环境变量 PUB_HOSTED_URL 和 FLUTTER_STORAGE_BASE_URL , 安装时当检测到有这俩环境变量,就会优先读取变量存储的地址去安装. 创建或者打开 $HOME/.bash_profile , 在下方添加两行变量 12export PUB_HOSTED_URL=https://pub.flutter-io.cnexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn 然后 source $HOME/.bash_profile 使之在当前 terminal 生效. 最后可用 echo $PUB_HOSTED_URL 和 echo $FLUTTER_STORAGE_BASE_URL 检测是否添加成功 最好配置下这个地址.笔者尝试数次,科学上网期间但没配置这倆地址时,下载组件时总会崩溃中断 😧. 此处我们选择 macOS ,其他系统下的安装可自行参考谷歌文档. 系统要求想要安装并运行 Flutter , 开发环境必须满足最低要求: 操作系统 : macOS (64位) 磁盘空间 : 700 MB (不包含 Xcode 或 Android Studio的空间) 工具 : Flutter 依赖于这些系统环境里的命令行工具 bash , mkdir , rm , git , curl , unzip , which 获取 Flutter SDK使用 git 命令克隆库并且添加 flutter 工具到环境变量中. 运行 flutter doctor 会显示剩余需要去安装的依赖. 克隆仓库当前我们需要克隆仓库beta分支 , 然后添加环境变量 12git clone -b beta https://github.com/flutter/flutter.gitexport PATH=`pwd`/flutter/bin:$PATH 以上命令只是设置临时变量,建议将其永久添加到环境变量中. 创建或打开 $HOME/.bash_profile 文件. 添加以下行,并且替换 [PATH_TO_FLUTTER_GIT_DIRECTORY] 为你的 Flutter git目录 1export PATH=[PATH_TO_FLUTTER_GIT_DIRECTORY]/flutter/bin:$PATH 然后运行 source $HOME/.bash_profile 使之在当前 terminal 生效. 可用 echo $PATH 检测是否添加成功 检测依赖运行以下命令来检测必要依赖是否已经完成安装 1flutter doctor 这个命令检测环境然后将结果显示在命令行窗口. Dart SDK 与 Flutter 绑定在一起 , 没必要单独安装 Dart. 仔细检查结果,可能需要安装依赖或者执行任务 (粗体显示) eg. 12345[-] Android toolchain - develop for Android devices • Android SDK at /Users/obiwan/Library/Android/sdk ✗ Android SDK is missing command line tools; download from https://goo.gl/XxQghQ • Try re-installing or updating your Android SDK, visit https://flutter.io/setup/#android-setup for detailed instructions. 第一次运行 flutter 命令 如( flutter doctor ), 会自行开始下载依赖库并编译. 后续的运行就会变的快的多. Flutter 使用 Google Analytics 来匿名报告功能使用统计以及崩溃日志, 可通过 flutter config --no-analytics 来禁用报告. 这里说句题外话 , 几年前谣传谷歌要采用新的 Android 开发语言 Sky 代替 Java . 后面沉溺了一段时间 , 最终它还是被谷歌发布出来了,只不过现在叫 Flutter . 但不难发现 , Flutter中多少还是有易容前的的影子,比如上图中第二个加载的包就叫 sky_engine .. 编辑器设置环境搭建好了 , 开始选择编辑器了. 建议的编辑器有 Android Studio , IntelliJ IDEA , VS Code等. Android Studio 需要 3.0 或以上的版本 IntelliJ IDEA 需要 2017.1 或之后的版本 VS Code 需要 1.20 或以上的版本 这里我们选择 IntelliJ IDEA 来作为编辑器并且安装 Flutter , Dart 两款插件 , 安装步骤主要为 开启 IntelliJ IDEA 打开插件偏好设置 (macOS上为Preferences&gt;Plugins , Windows及Linux上为File&gt;Settings&gt;Plugins) 选择 Browse repositories… , 输入 Flutter 然后点击 install 安装 点击 Yes 当提示去安装 Dart Plugin 安装完成后重启 IDEA Android Studio 安装插件与 IntelliJ IDEA一致 , VS Code 的请参考官网 Editor 平台设置macOS 支持开发 Android 及 iOS Flutter apps .完成其中一个平台的设置即可编译和运行 Flutter app . iOS 设置安装 Xcode我们需要安装 Xcode 7.2 或以上版本 , 整体步骤为: 安装 Xcode 7.2 或以上的版本 (通过 web 或者 Mac AppStore) 命令行运行 sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer 配置 Xcode命令行工具以使用新安装的 Xcode 版本 确认 Xcode license 协议被签署过. 可通过打开一次 Xcode 或命令行运行 sudo xcodebuild -license 使用 Xcode 我们就能在 iOS 设备或模拟器上运行 Flutter apps 设置iOS模拟器 首先打开模拟器 通过命令 open -a Simulator 或者 Spotlight 通过检查模拟器的 Hardware &gt; Device 菜单中得设置 , 以确保模拟器正在使用64位设备 (iPhone 5s或更高版本) 取决于开发设备屏幕尺寸 , 高屏幕密度的iOS模拟设备可能会在屏幕上溢出 , 在模拟器的Window &gt; Scale菜单下设置设备比例 通过运行 flutter run 来启动应用 部署到iOS设备要部署 Flutter app 到 iOS设备 , 我们需要一些额外的工具和 Apple 账号 . 还需要在设备上进行设置 安装 homebrew 打开命令终端运行以下命令以安装工具 1234brew updatebrew install --HEAD libimobiledevicebrew install ideviceinstaller ios-deploy cocoapodspod setup 如若这些命令出现异常失败了, 运行 brew doctor 按照说明解决问题 然后依照 Xcode 签名流程来配置项目 从Flutter项目目录中的终端窗口中运行ios/Runner.xcworkspace来打开Xcode工作空间 , 也可直接双击文件打开 在Xcode中,从左侧导航面板中选择 Runner 项目 Runner target设置页面 , 确保在General &gt; Signing &gt; Team下的开发团队是被选中的. 当选择一个团队 , Xcode会创建并下载开发证书 , 并账号中注册此设备 , 然后创建并下载一个描述文件. 如果是第一个iOS开发项目,则可能需要使用到 Apple ID 登录Xcode 当第一次使用设备进行iOS开发时, 需要在设备上信任Mac和开发证书.首次将iOS设备连接到Mac时,会弹出一个对话框,在对话框中点击信任即可. 然后去 iOS 设备上设置应用程序 , General &gt; Device Management下选择信任你的证书 若 Xcode中的自动签名失败 , 请验证项目中的General&gt; Identity&gt; Bundle Identifier下的值是否唯一 然后可通过 flutter run 运行app Android 设置安装 Android Studio我们需要安装并配置 Android Studio , 整体步骤为: 下载并安装 Android Studio 打开 Android Studio , 走完 ‘Android Studio 安装指南’ . 这将安装最新的 Android SDK, Android SDK Platform-Tools, and Android SDK Build-Tools , 这是 Flutter 开发 Android 必要的. 设置Android模拟器运行模拟器比较吃资源 , 这里建议还是使用Android真机. 如若需要配置模拟器请参考官网 设置Android设备要运行并且测试我们的应用在 Android 设备上 , 我们需要系统版本为 Android 4.1 及以上的 Android 设备 打开 开发者选项 还有 USB调试 . 使用USB将手机连接电脑 . 若手机出现提示,授权电脑访问手机 在命令执行 flutter devices 确认连接电脑的设备 然后可通过执行 flutter run 运行我们的app 这里的 flutter devices 命令类似 adb 的 adb devices . 如若提示不可用 , 请将 adb 所在目录添加到环境变量 . 运行app命令终端首先用 flutter create 命令创建新项目 12flutter create myappcd myapp 以上命令创建了一个 名为 myapp 的 Flutter 项目 , 其为一个包含 Material Components 的简单demo . 项目目录里 , app的代码在 lib/main.dart 中. 然后运行app 确保有设备已经连接 , 若无设备连接,请参考文中 平台设置 1flutter devices 通过 flutter run 命令运行app 1flutter run 若不出意外,则运行成功 尝试热部署 . Flutter 提供了热部署以供快速开发. 打开 lib/main.dart 修改界面文案,保存 在命令终端按下 ‘r’ 界面文案即刻更新生效 Android StudioIntelliJ IDEA 和 Android Studio 对热更新操作更便捷. 同样是在运行后,修改文案保存,然后点击闪电⚡️Reload即可 这里吐槽下, 首次运行 iOS 比 Android 要快不要太多. 主要是 Gradle构建的问题 . on Android : on iOS : 运行官方Demo创建的默认项目功能较简单,不能够给我们带来较深刻的体验. 我们可以参考 Flutter Demo . 这里我们拿其中较不错的 flutter_gallery 来运行. 首先下载下来,进入其目录. 这里因为demo运行需要安装额外依赖,所以需要对终端/IDEA 进行科学上网配置.不清楚的请根据自身科学上网姿势配置 :) 然后运行 flutter doctor ,如果是IDEA打开则直接自动运行 , 可能得到这结果. 此时打开项目目录中的 pubspec.yaml 找到 test: 0.12.30+4 改为 test: 0.12.30+3 即可 Flutter是一个初期的开源项目，它帮助开发者从一个代码库构建出高性能、高保真度的移动应用 . 这个Gallery是Flutter的许多小部件、行为、动画、布局等的预览 . 正如 Flutter Gallery 官方介绍所说 , 它主要呈现的是一些小部件的预览 , 主题皮肤切换 , 控件风格切换等示例 . 后期的学习中可参考其进行.]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ+Gradle自定义war包名称]]></title>
    <url>%2Fidea-gradle_war%2F</url>
    <content type="text"><![CDATA[最近在帮朋友开发小程序的 Java 后端,项目采用 Gradle 构建,使用IntelliJ开发. 开发中经常需要发包到外网上,方便前端联调,而IntelliJ默认构建的 war 包名称为项目名-版本号,使得每次上传war包至服务器tomcat时还得手动重命名,发布次数多了,就显得很繁琐.这里就水一篇,简短说明下 IntelliJ中Gradle构建如何自定义war包名称. 首先打开 Project Settings 选择 Artifacts 前两个 Gradle:xxx 是创建Gradle项目并添加tomcat后,自动生成的.我们这里点击 + 新增 选择 Web Application: Archive -&gt; Empty 修改war包名称及输出路径 添加war包内容,同样选择 Artifact 选择 Gradle: xxx (exploded) 之后打包只能选择 Build -&gt; Build Artifacts 然后选择自定义的build, 然后在输出目录下即可找到war包]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IntelliJ</tag>
        <tag>war</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo绑定自定义Https域名]]></title>
    <url>%2Fhexo_ssl_netlify%2F</url>
    <content type="text"><![CDATA[通常我们将Hexo博客部署到 GitHub Pages 上,然后绑定自定义域名.例如作者的 GitHub Page lhalcyon.github.io绑定到了lhalcyon.com上.但是 GitHub Pages 无法给自定义域名配置SSL GitHub Pages默认是支持https的,即我们可通常https://lhalcyon.github.io来访问博客,但是绑定自定义域名后,只能通过http://lhalcyon.com正常访问,如直接访问https://lhalcyon.com就会爆红 由于博客已改造完成,就度娘了张示例图 为了实现自定义域名SSL认证,通常的做法是在Cloudflare配置一个反向代理到GitHub Pages,但是其访问速度及稳定性不太好,再就是博客更新后生效也会有延迟,于是我们得寻索一个解决办法. 为了更好的阅读体验,请点击 阅读原文😉. 起初是考虑将Hexo迁移到 Coding Pages 上,后来发现其免费托管下必须在首页对其做一个广告,否则访问会先跳转到一个中转广告页再进行跳转 ,想免广告只能升级黄金会员及以上,这点太不友好. 问题传送门 跳转页: or 主动添加广告链接,审核过后会免去跳转页 某博客页脚添加的广告: 无疑这样大大影响我们的博客美观,不能接受,但又不想迁回GitHub Pages,怎么办?下面我们介绍一些免费及好用的静态网站托管平台 免费静态网站托管平台GitHub Pages优点 自带域名可https访问 可配置自定义域名 缺点 无法给自定义域名配置SSL Bitbucket Cloud跟 GitHub Pages 功能一样,但是: 无法自定义域名 能且只能通过 https 协议访问（http 协议会被跳转到 https 协议) 所有项目的静态网站代码都只能放在专门的站点仓库里（accountName.bitbucket.io) ,不能像 GitHub 那样可以在每个项目里用 gh-pages 分支保存文件 aerobaticBitbucket 旗下的静态网站托管服务. 可以使用 CLI 上传代码 支持自动构建 (Continuous Deployment) 可以自定义域名但是收费功能,自定义域名支持 https 且不需要提供证书,它会帮你生成一个 GitLab Pages同样和 GitHub Pages 的功能一样,但是: 自定义域名可配置https,不过需要上传证书 surge.sh 只能使用 CLI 上传代码 支持自定义域名,但开启 SSL 是收费功能且需要自行上传证书 支持200.html —— 适用于使用 History API 的 SPA Firebase Hosting 只能使用 CLI 上传代码 支持自定义域名并支持一键开启 https 支持重定向（Redirects）和重写（Rewrites）功能（当网站使用 History API 时特别有用) but 有被墙的风险…… Netlify (推荐) 可以使用 CLI 上传代码 支持自定义域名且自定义域名支持一键开启 https（证书来自 Let’s Encrype） 支持强制让用户通过 https 访问网站（开启后此功能后，http 的访问一律会 301 跳转到 https 支持自动构建 支持重定向（Redirects）和重写（Rewrites）功能 数据通过 HTTP2 协议传输 提供 webhooks 与 API now 可以使用 CLI 上传代码，或者链接一个 Git 仓库 不仅提供静态网站托管，同时也支持托管 Node.js 服务 支持自定义域名且自定义域名支持一键开启 https（证书来自 Let’s Encrype） 数据通过 HTTP2 协议传输 提供 API Coding Pages上面我们说过,收费机制甚不友好 鉴于各平台特点,我们选择Netlify Netlify部署网站首先去 Netlify 注册账号登录 接着点击页面右上角的 New site from Git 这里选择的 GitHub ,别忘记勾选访问公共仓库选项.之后授权给 Netlify 指定Repository,然后 Deploy 设置自定义域名点击 Domain settings 然后点击 Add custom domain. 然后到域名解析处,修改域名CNAME记录,记录值就是设置完域名页面显示的配置值 添加SSL证书设置完成域名绑定后,设置中心选项有所变化,增加了一个 Enable HTTPS的选项 , 点击 点击 Let’s Encrypt Certificate, 系统会自动签发证书给站点,若域名解析没问题就能签发成功 若想一直使用Https访问的话,就勾选 Force TLS connections 强制所有访问转换为Https 至此,配置全部完成 后续Netlify 还有很多技巧,比如可以设置变量及命令.免费用户可以为网站设置变量、webhook等.付费用户则可以为网站设置更加详细的SEO优化.各位可以自行去挖掘~ 🧐 参考: https://github.com/lmk123/blog/issues/55]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>SSL</tag>
        <tag>GitHub Pages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC+WebSocket+Gradle实现消息实时推送]]></title>
    <url>%2Fspringmvc-websocket_im%2F</url>
    <content type="text"><![CDATA[WebSocket是HTML5开始提供的一种浏览器与服务器间进行全双工通讯的网络技术。 WebSocket通信协议于2011年被IETF定为标准RFC 6455，WebSocketAPI被W3C定为标准。 在WebSocket API中，浏览器和服务器只需要要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。 以上摘自Wikipedia. 本文将说明在Intellij IDEA下使用Gradle构建SpringMVC+WebSocket实现消息推送.为了更好的阅读体验,请点击阅读原文😉. 创建项目在之前的文章中有详细的说明,此篇不做赘述.可参考IDEA+Gradle创建MyBatis+SpringMVC项目 导入依赖在build.gradle中导入denpendies 12345678910111213// ------------------------ Spring SpringMVC start -------------------------compile group: 'org.springframework', name: 'spring-webmvc', version: '4.2.4.RELEASE'compile group: 'org.springframework', name: 'spring-context-support', version: '4.2.4.RELEASE'// ------------------------ Spring SpringMVC end -------------------------// ------------------------ WebSocket start -------------------------compile group: 'org.springframework', name: 'spring-websocket', version: '4.2.4.RELEASE'compile group: 'org.springframework', name: 'spring-messaging', version: '4.2.4.RELEASE'compile group: 'javax.servlet', name: 'javax.servlet-api', version: '3.1.0'// ------------------------ WebSocket end -------------------------compile group: 'log4j', name: 'log4j', version: '1.2.17'compile group: 'com.google.code.gson', name: 'gson', version: '2.8.2' 此处需要注意的是Spring从4.0+版本开始支持WebSocket,而servlet-api需要为3.0+版本 配置文件web.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" version="3.0"&gt; &lt;!-- 初始化spring 容器 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:config/spring/applicationContext-*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 配置前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;index-dispather&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath*:config/spring/spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;index-dispather&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 解决post乱码问题 --&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;/web-app&gt; 此处需要给servlet及filter添加异步&lt;async-supported&gt;true&lt;/async-supported&gt;. spring-mvc.xml 123456789101112131415161718192021222324252627&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; &lt;!-- 自动扫描控制器,webSocket --&gt; &lt;context:component-scan base-package="com.lhalcyon.king.controller,com.lhalcyon.king.socket"/&gt; &lt;!-- 视图渲染 --&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/views/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt; &lt;!-- 控制器映射器和控制器适配器 --&gt; &lt;mvc:annotation-driven&gt; &lt;/mvc:annotation-driven&gt; &lt;!-- 静态资源映射器 --&gt; &lt;mvc:resources mapping="/statics/**" location="/WEB-INF/statics/" /&gt;&lt;/beans&gt; 此处需配置扫描controller和websocket所在包 还有一个applicationContext-websocket.xml配置文件我们在代码实现中说明 代码实现握手拦截器HandshakeInterceptor 拦截器说明 An interceptor to copy information from the HTTP session to the “handshakeattributes” map to made available via WebSocketSession.getAttributes()Copies a subset or all HTTP session attributes and/or the HTTP session id 拦截器主要用于用户登录标识的记录,便于后面获取指定用户的会话标识并向指定用户发送消息, 这里我们继承HttpSessionHandshakeInterceptor 123456789101112131415161718192021222324public class HandshakeInterceptor extends HttpSessionHandshakeInterceptor &#123; private Logger logger = Logger.getLogger(HandshakeInterceptor.class); // 握手前 @Override public boolean beforeHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Map&lt;String, Object&gt; attributes) throws Exception &#123; logger.info("++ HandshakeInterceptor: beforeHandshake ++"+attributes); return super.beforeHandshake(request, response, wsHandler, attributes); &#125; // 握手后 @Override public void afterHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Exception ex) &#123; logger.info("++ HandshakeInterceptor: afterHandshake ++"); super.afterHandshake(request, response, wsHandler, ex); &#125;&#125; beforeHandshake(..) Invoked before the handshake is processed. afterHandshake(..) Invoked after the handshake is done. The response status and headers indicate the results of the handshake, i.e. whether it was successful or not. 两个方法调用时机均为字面所述,握手前后分别调用.主要是在握手前后去做一些事,比如将需要的数据设置到attributes里,之后在WebSocketHandler的session中获取这些数据. 处理类WebSocketHandler 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class MyWebSocketHandler implements WebSocketHandler &#123; private static final Logger log = Logger.getLogger(MyWebSocketHandler.class); // 保存所有的用户session private static final ArrayList&lt;WebSocketSession&gt; users = new ArrayList&lt;WebSocketSession&gt;(); @Override public void afterConnectionEstablished(WebSocketSession session) throws Exception &#123; log.info("connect websocket success......."); users.add(session); &#125; @Override public void handleMessage(WebSocketSession session, WebSocketMessage&lt;?&gt; message) throws Exception &#123; Gson gson = new Gson(); // 将消息JSON格式通过Gson转换成Map // message.getPayload().toString() 获取消息具体内容 Map&lt;String, Object&gt; msg = gson.fromJson(message.getPayload().toString(), new TypeToken&lt;Map&lt;String, Object&gt;&gt;() &#123;&#125;.getType()); log.info("handleMessage......."+message.getPayload()+"..........."+msg); String content = message.getPayload().toString(); // 处理消息 msgContent消息内容 TextMessage textMessage = new TextMessage(content, true); // 调用方法（发送消息给所有人） sendMsgToAllUsers(textMessage); &#125; @Override public void handleTransportError(WebSocketSession session, Throwable exception) throws Exception &#123; log.warn("handleTransportError"); users.remove(session); &#125; @Override public void afterConnectionClosed(WebSocketSession session, CloseStatus closeStatus) throws Exception &#123; log.info("connect websocket closed......."); users.remove(session); &#125; // 给所有用户发送 信息 public void sendMsgToAllUsers(WebSocketMessage&lt;?&gt; message) throws Exception&#123; for (WebSocketSession user : users) &#123; user.sendMessage(message); &#125; &#125; @Override public boolean supportsPartialMessages() &#123; return false; &#125;&#125; 以下对主要方法进行说明: afterConnectionEstablished(..) 连接建立后调用,常用于记录用户的连接标识,便于后面信息发送. handleTextMessage(..) 对消息进行处理. handleTransportError(..) 连接异常处理.需要关闭出错会话连接 afterConnectionClosed(..) 连接关闭处理 此处我们对消息的处理很简单,即在接受消息后发送给所有连接的用户,类似一个匿名群聊室. 注册完成了WebSocket处理类,还需要对其进行注册生效.这里有两种方式,择其一即可. 创建配置类,并通过注解注册123456789101112131415161718192021@Configuration@EnableWebMvc@EnableWebSocketpublic class MyWebSocketConfig extends WebMvcConfigurerAdapter implements WebSocketConfigurer &#123; @Override public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) &#123; //前台 可以使用websocket环境 registry.addHandler(myWebSocketHandler(),"/websocket").addInterceptors(new HandshakeInterceptor()).setAllowedOrigins("*"); //前台 不可以使用websocket环境，则使用sockjs进行模拟连接 registry.addHandler(myWebSocketHandler(), "/sockjs/websocket").addInterceptors(new HandshakeInterceptor()) .withSockJS(); &#125; // websocket 处理类 @Bean public WebSocketHandler myWebSocketHandler()&#123; return new MyWebSocketHandler(); &#125;&#125; 同时还需要配置上文提到过的Spring扫描配置类. 12&lt;!-- 自动扫描控制器,webSocket --&gt;&lt;context:component-scan base-package="com.lhalcyon.king.controller,com.lhalcyon.king.socket"/&gt; 通过xml配置注册applicationContext-websocket.xml 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:websocket="http://www.springframework.org/schema/websocket" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/websocket http://www.springframework.org/schema/websocket/spring-websocket-4.0.xsd"&gt; &lt;!-- websocket处理类 --&gt; &lt;bean id="myHandler" class="com.lhalcyon.king.socket.MyWebSocketHandler"/&gt; &lt;!-- 握手接口/拦截器 --&gt; &lt;bean id="myInterceptor" class="com.lhalcyon.king.socket.HandshakeInterceptor"/&gt; &lt;websocket:handlers&gt; &lt;websocket:mapping path="/websocket" handler="myHandler"/&gt; &lt;websocket:handshake-interceptors&gt; &lt;ref bean="myInterceptor"/&gt; &lt;/websocket:handshake-interceptors&gt; &lt;/websocket:handlers&gt; &lt;!-- 注册 sockJS --&gt; &lt;websocket:handlers&gt; &lt;websocket:mapping path="/websocket" handler="myHandler"/&gt; &lt;websocket:handshake-interceptors&gt; &lt;ref bean="myInterceptor"/&gt; &lt;/websocket:handshake-interceptors&gt; &lt;websocket:sockjs /&gt; &lt;/websocket:handlers&gt;&lt;/beans&gt; 以上服务端代码实现基本完成,接下来对客户端测试页面做一个简单的实现. 客户端页面index.jsp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;首页&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta name="renderer" content="webkit"&gt; &lt;!-- 引入 JQuery --&gt; &lt;script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js"&gt;&lt;/script&gt; &lt;!-- 引入 sockJS --&gt; &lt;script type="text/javascript" src="https://cdn.bootcss.com/sockjs-client/1.1.4/sockjs.min.js" &gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function() &#123; var websocket; // 首先判断是否 支持 WebSocket var url = 'ws://' + window.location.host + '/word-king/websocket'; if('WebSocket' in window) &#123; websocket = new WebSocket(url); &#125; else if('MozWebSocket' in window) &#123; websocket = new MozWebSocket(url); &#125; else &#123; url = "http://"+ window.location.host +"/word-king/sockjs/websocket"; websocket = new SockJS(url); &#125; // 打开时 websocket.onopen = function(evnt) &#123; console.log(" websocket.onopen "); &#125;; // 处理消息时 websocket.onmessage = function(evnt) &#123; $("#msg").append("&lt;p&gt;(&lt;font color='red'&gt;" + evnt.data + "&lt;/font&gt;)&lt;/p&gt;"); console.log(" websocket.onmessage "); &#125;; websocket.onerror = function(evnt) &#123; alert("onerror"); console.log(" websocket.onerror "); &#125;; websocket.onclose = function(evnt) &#123; console.log(" websocket.onclose "); alert("onclose"); &#125;; // 点击了发送消息按钮的响应事件 $("#TXBTN").click(function()&#123; // 获取消息内容 var text = $("#tx").val(); // 判断 if(text == null || text == "")&#123; alert(" content can not empty!!"); return false; &#125; var msg = &#123; msgContent: text, postsId: 1 &#125;; // 发送消息 websocket.send(JSON.stringify(msg)); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 最外边框 --&gt;&lt;div style="margin: 20px auto; border: 1px solid blue; width: 300px; height: 500px;"&gt; &lt;!-- 消息展示框 --&gt; &lt;div id="msg" style="width: 100%; height: 70%; border: 1px solid yellow;overflow: auto;"&gt;&lt;/div&gt; &lt;!-- 消息编辑框 --&gt; &lt;textarea id="tx" style="width: 100%; height: 20%;"&gt;&lt;/textarea&gt; &lt;!-- 消息发送按钮 --&gt; &lt;button id="TXBTN" style="width: 100%; height: 8%;"&gt;发送数据&lt;/button&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 需要注意的是此处引入JQuery时,如果是本地的文件,可能存在无效的情况,需要去设置静态资源映射路径,可自行🔍解决. 本文采用的是引入在线地址 12&lt;!-- 引入 JQuery --&gt; &lt;script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.5/jquery.min.js"&gt;&lt;/script&gt; 地址写入后需Download下来 代码不高亮警告后即能生效. 最后我们来看看效果 参考: http://blog.csdn.net/mybook201314/article/details/70173674]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
        <tag>WebSocket</tag>
        <tag>IM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现apk上传蒲公英后自动发送钉钉通知]]></title>
    <url>%2Fwebhook_dingding-pgyer%2F</url>
    <content type="text"><![CDATA[Webhook是一个API概念，并且变得越来越流行。我们能用事件描述的事物越多，webhook的作用范围也就越大。Webhook作为一个轻量的事件处理应用，正变得越来越有用。 准确的说webhook是一种web回调或者http的push API，是向APP或者其他应用提供实时信息的一种方式。Webhook在数据产生时立即发送数据，也就是你能实时收到数据。这一种不同于典型的API，需要用了实时性需要足够快的轮询。这无论是对生产还是对消费者都是高效的，唯一的缺点是初始建立困难。 Webhook有时也被称为反向API，因为他提供了API规则，你需要设计要使用的API。Webhook将向你的应用发起http请求，典型的是post请求，应用程序由请求驱动。 在Android开发中会经常提交apk给测试人员进行测试,通常的做法是将构建完成的包上传至蒲公英,测试人员直接扫码下载并安装apk包从而进行测试.一般我们会将构建及发布过程自动化,可参考: Linux+Jenkins+Gradle构建Android参数化自动打包(一) Linux+Jenkins+Gradle构建Android参数化自动打包(二) 文章中实现了apk上传蒲公英后邮件通知,可是实际中,大家对邮件的关注远远没有对IM消息的关注度高,所以接下来本文将说明,实现上传apk后自动发送钉钉消息,将更新内容,apk版本号等信息通知到测试人员 环境准备首先环境搭建是IntelliJ+SpringMVC+Gradle构建的,如有疑问的同学可参考IDEA+Gradle创建MyBatis+SpringMVC项目,项目中主要是对接口数据的调整及转发,实际上未用到MyBatis,可自行进行去除🙄. 模型建立对照蒲公英doc、钉钉doc分别建立Java Bean. PgyerMessage 123456789101112131415&#123; "action": "应用更新", "title": "OooPlay", "link": "https://www.pgyer.com/oooplay_test", "message": "您的应用OooPlay有了新的版本(2.4)更新。", "type": "updateVersion", "os_version": "2.4", "build_version": "139", "created": "2015-10-09 11:25:16", "updated": "2015-10-09 11:25:16", "timestamp": 1444361118, "appsize": "2238036", "device_type": 'iOS', "notes": "修复了一些小弱智的小bug"&#125; 1234567891011121314151617181920212223242526272829303132333435public class PgyerMessage &#123; public String action; public String title; public String link; public String message; public String type; public String os_version; public String build_version; public String created; public String updated; public int timestamp; public String appsize; public String device_type; public String notes; @Override public String toString() &#123; return "PgyerMessage&#123;" + "action='" + action + '\'' + ", title='" + title + '\'' + ", link='" + link + '\'' + ", message='" + message + '\'' + ", type='" + type + '\'' + ", os_version='" + os_version + '\'' + ", build_version='" + build_version + '\'' + ", created='" + created + '\'' + ", updated='" + updated + '\'' + ", timestamp=" + timestamp + ", appsize='" + appsize + '\'' + ", device_type='" + device_type + '\'' + ", notes='" + notes + '\'' + '&#125;'; &#125;&#125; 此处有个小技巧,IDEA IntelliJ有个好用的插件GsonFormat可一键将Json字符串转换为Java Model 钉钉消息则分为几种类型,具体举例可参考钉钉doc 123456789public static final String TYPE_LINK = "link";public static final String TYPE_MARKDOWN = "markdown";public static final String TYPE_TEXT = "text";public static final String TYPE_ACTIONCARD = "actionCard";public static final String TYPE_FEEDCARD = "feedCard"; 此处我们选择markdown类型.为了便于拓展,此处将消息抽取了个基类BaseDingMessage. 123456789101112131415161718192021public class BaseDingMessage &#123; public static final String TYPE_LINK = "link"; public static final String TYPE_MARKDOWN = "markdown"; public static final String TYPE_TEXT = "text"; public static final String TYPE_ACTIONCARD = "actionCard"; public static final String TYPE_FEEDCARD = "feedCard"; public String msgtype; public AtBean at; public static class AtBean &#123; public boolean isAtAll; public List&lt;String&gt; atMobiles; &#125;&#125; 12345678910public class MarkdownMessage extends BaseDingMessage &#123; public MarkdownBean markdown; public static class MarkdownBean &#123; public String title; public String text; &#125;&#125; 代码实现首先在build.gradle中导入依赖 12compile group: 'com.alibaba', name: 'fastjson', version: '1.2.45'compile group: 'com.squareup.okhttp3', name: 'okhttp', version: '3.9.0' fastjson是用力啊转化json,okhttp用来网络请求 spring-mvc.xml加入json配置 12345678910111213141516171819202122232425262728293031323334353637&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; &lt;!-- 自动扫描控制器 --&gt; &lt;context:component-scan base-package="com.lhalcyon.webhook.controller"/&gt; &lt;!-- 视图渲染 --&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/views/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt; &lt;!-- 控制器映射器和控制器适配器 --&gt; &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults="true"&gt; &lt;bean class="com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter"&gt; &lt;property name="supportedMediaTypes"&gt; &lt;list&gt; &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt; &lt;value&gt;application/json&lt;/value&gt; &lt;value&gt;application/xml;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; &lt;!-- 静态资源映射器 --&gt; &lt;mvc:resources mapping="/statics/**" location="/WEB-INF/statics/" /&gt;&lt;/beans&gt; 消息发送服务DingServiceImpl.java 123456789101112131415161718192021Servicepublic class DingServiceImpl implements DingService &#123; private static final Logger logger = Logger.getLogger(DingServiceImpl.class); @Override public void send(BaseDingMessage message,String url) &#123; MediaType jsonType = MediaType.parse("application/json; charset=utf-8"); okhttp3.RequestBody body = okhttp3.RequestBody.create(jsonType, JSON.toJSONString(message)); final Request request = new Request.Builder() .url(url) .post(body) .build(); OkHttpClient client = OkhttpProvider.get(); try &#123; client.newCall(request).execute(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 蒲公英请求控制器PgyerController.java 123456789101112131415161718@RestController@RequestMapping("/pgyer")public class PgyerController &#123; @Autowired DingService dingService; private static final Logger logger = Logger.getLogger(PgyerController.class); @ResponseBody @RequestMapping(value = "/update",method = RequestMethod.POST) public BaseDingMessage apkUpdate(@RequestBody PgyerMessage pgyerMessage)&#123; BaseDingMessage dingMessage = WebhookConverter.pgyer2Ding(pgyerMessage); dingService.send(dingMessage, Urls.DING_TEST); logger.info(dingMessage); return dingMessage; &#125;&#125; 其中Urls.DING_TEST为钉钉机器人的会话token地址,后面会说明如何创建/获取 消息转换器WebhookConverter.java 123456789101112131415161718192021222324public class WebhookConverter &#123; private static final Logger logger = Logger.getLogger(WebhookConverter.class); public static MarkdownMessage pgyer2Ding(PgyerMessage pgyerMessage)&#123; MarkdownMessage message = new MarkdownMessage(); message.msgtype = BaseDingMessage.TYPE_MARKDOWN; message.markdown = new MarkdownMessage.MarkdownBean(); message.markdown.title = pgyerMessage.device_type + "蒲公英更新"; StringBuilder builder = new StringBuilder(); builder.append("#### ").append(pgyerMessage.device_type).append("测试包已更新! \n\n") .append("###### version: ").append(pgyerMessage.os_version).append(" | build ").append(pgyerMessage.build_version).append("\n\n") .append("更新内容:\n").append("&gt; ").append(pgyerMessage.notes).append("\n\n") .append("![qr_code_test](图片地址)\n\n") .append("[下载地址](https://www.pgyer.com/你的apk地址) 密码:你的密码\n").append(" @18810100000 @18810100001 @18818100002 "); message.markdown.text = builder.toString(); message.at = new BaseDingMessage.AtBean(); message.at.isAtAll = false; message.at.atMobiles = Arrays.asList("18818100000","18818100001","18818100002"); return message; &#125;&#125; 以上需自行修改内容. 然后创建钉钉机器人.创建四连 1 2 3 4 点此复制钉钉机器人会话token,建立Urls.java. 1234567public interface Urls &#123; /** * 提测群机器人token */ String DING_TEST = "钉钉token";&#125; 此处的Ding_Test即为上面复制的地址 至此,代码主要实现类已经完成,接下来需要去配置蒲公英webhook 配置webhook打开 蒲公英 应用设置 创建webhook,写入PgyerController的更新请求地址,如果配置与本文的相同,地址则为 1http://你的地址:端口/webhook-1.0-SNAPSHOT/pgyer/update 其中webhook-1.0-SNAPSHOT为war包在tomcat解压后的名称 done! 之后只要上传成功后,即有钉钉消息通知并@测试人员了! 让我们再看下打包后的消息通知! .jpg) 类似的,代码push,merge也可以做成webhook消息. Github、Gitlab既有成熟的对接机器人.而笔者使用的Coding是没有与钉钉做对接的,此时可自定义机器人实现,有兴趣的同学可参考上面的教程自行实现.]]></content>
      <categories>
        <category>Webhook</category>
      </categories>
      <tags>
        <tag>Dingding</tag>
        <tag>Webhook</tag>
        <tag>Pgyer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux升级Glibc2.14中文乱码]]></title>
    <url>%2Fupdate_glibc_issue%2F</url>
    <content type="text"><![CDATA[CenterOS上默认的Glibc版本为2.12.1,由于我们的Android项目使用到了JNI,将项目构建部署在服务器上时会遇到问题&#39;GLIBC_2.14&#39; not found,那么就需要升级Glibc至2.14.升级的教程网上很多,可是却漏掉了一个步骤,导致后面中文乱码的问题.本篇会做一个全面的解说 1. Glibc下载首先从Glibc Download下载包,这里选择是Glibc 2.14 2. 安装上传至服务器,进入目录解压 1tar zxvf glibc-2.14.tar.gz 进入解压后的目录 1cd glibc-2.14 接着 12345mkdir /opt/buildcd build../configure --prefix=/opt/glibc-2.14make -j4make install 若顺利的话,至此则安装成功了. issue1. 在make install过程中出现错误: 1Can&apos;t open configuration file /opt/glibc-2.14/etc/ld.so.conf: No such file or directory 缺少了报错的编译文件ld.so.conf.通过find命令找到对应的文件配置 然后拷贝文件至对应文件目录,继续编译 12cp /etc/ld.so.conf /opt/glibc-2.14/etc/ make install 编译成功,接着定义下环境变量即可 3. 补充通常的教程至此就结束了.最初笔者参考网上的教程也是做到这里.当时跑程序也没问题,直到前段时间大楼停电,服务器重启后,通过服务器上Jenkins打包上传到蒲公英的中文信息全是乱码! 相当于服务器的编码文件丢失了,所有中文都会乱码. 是因为遗漏了localedata未编译,在服务器重启后,Glibc2.14找不到对应版本2.14的glibc locale文件. 正确操作是,在make&amp;make install完成后继续编译local包 1make localedata/install-locales 编译需要一些时间,完成后重启服务器即可生效 1shutdown -r now 参考: http://blog.csdn.net/clirus/article/details/62425498 参考: http://blog.csdn.net/fzuzhanghao1993/article/details/77650500]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA+Gradle创建MyBatis+SpringMVC项目]]></title>
    <url>%2Fssm_build%2F</url>
    <content type="text"><![CDATA[Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化构建工具.它使用一种基于Groovy的特定领域语言(DSL)来声明项目设置,抛弃了基于XML的各种繁琐配置. IDEA 全称IntelliJ IDEA,是java语言开发的集成环境,IntelliJ在业界被公认为最好的java开发工具之一,尤其在智能代码助手、代码自动提示、重构、J2EE支持、Ant、JUnit、CVS整合、代码审查、 创新的GUI设计等方面的功能可以说是超常的. 以上为百度的简介.从事Android的童鞋应该不难发现Gradle以及Android Studio的强(hen)大(ka).🤫而AS是基于IntelliJ IDEA开发的.习惯了Gradle的便捷,于是开始基于Gradle+IDEA构建Java项目. 环境准备1. 数据库MySql在MySql Downloads下载对应的版本并安装 此处笔者在macOS上安装5.7.21后打开系统偏好设置,遇到无法加载MySql面板的问题.一番搜索🔍后发现是macOS版本与MySql不兼容,选择低版本的MySql如5.6.39即可. 2. IntelliJ IDEA请自行安(po)装(jie). 3. Tomcat请自行下载解压.如若是macOS或是Linux上解压后需进入bin目录执行下命令chmod u+x *.sh修改权限 创建项目点击 Create New Project 选择基于Gradle的Java Web项目 填写GroupId和ArtifactId 选择gradle.可使用默认的,可使用本地的 接着选择项目目录,基本项目创建好了,接下来进入文件配置 文件配置首先创建java和resources目录,并且创建包以及web.xml. log4j.properties12345678910111213141516171819#设置日志的级别，定义日志信息的输出目的log4j.rootLogger=DEBUG, A1 ,R#定义A1的输出目的地为控制台log4j.appender.A1=org.apache.log4j.ConsoleAppender#布局为 PatternLayout 可以灵活地指定布局模式。log4j.appender.A1.layout=org.apache.log4j.PatternLayout#设置输出格式log4j.appender.A1.layout.ConversionPattern=%-d&#123;yyyy-MM-dd HH\:mm\:ss&#125; [%c]-[%p] %m%n#定义R的输出目的地为文件，并且文件大小到达指定尺寸的时候产生一个新的文件log4j.appender.R=org.apache.log4j.RollingFileAppender#设置输出的文件地址log4j.appender.R.File=/Users/xx/Documents/ServerLog#设置文件大小伟100 kb 文件到达100时，产生一个新文件，#MaxBackupIndex 最大记录的文件数为1 查过一个文件删除文件较早的。log4j.appender.R.MaxFileSize=100KB log4j.appender.R.MaxBackupIndex=1#以下和上面一样log4j.appender.R.layout=org.apache.log4j.PatternLayoutlog4j.appender.R.layout.ConversionPattern=%p %t %c - %m%n 以上输出文件地址自行更改 generatorConfig.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;classPathEntry location="$&#123;jarDirection&#125;"/&gt; &lt;context id="mysql" targetRuntime="MyBatis3"&gt; &lt;jdbcConnection driverClass="$&#123;driverClass&#125;" connectionURL="$&#123;connectionURL&#125;" userId="$&#123;userId&#125;" password="$&#123;password&#125;"&gt; &lt;/jdbcConnection&gt; &lt;javaTypeResolver &gt; &lt;property name="forceBigDecimals" value="false" /&gt; &lt;/javaTypeResolver&gt; &lt;javaModelGenerator targetPackage="$&#123;modelPackage&#125;" targetProject="$&#123;src_main_java&#125;"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;property name="trimStrings" value="true" /&gt; &lt;/javaModelGenerator&gt; &lt;sqlMapGenerator targetPackage="$&#123;sqlMapperPackage&#125;" targetProject="$&#123;src_main_java&#125;"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;/sqlMapGenerator&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="$&#123;mapperPackage&#125;" targetProject="$&#123;src_main_java&#125;"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 每一个数据库表都对应一个对应的table属性 --&gt; &lt;table tableName="book" domainObjectName="Book"&gt; &lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; gradle.properties123456# 生成的model类所在包modelPackage=com.lhalcyon.webhook.domain# 生成的mapper接口类所在包mapperPackage=com.lhalcyon.webhook.mapper# 生成的mapper xml文件所在包sqlMapperPackage=com.lhalcyon.webhook.mapper 为了方便扫描,将mapper xml以及接口类放在了同一包下了 😕 jdbc-mysql.properties12345678910# 将jdbc.jarDirection后的内容更改为gradle下载的# mysql-connector-java-5.1.x.jar所在的路径，gradle自动下载的路径如下所示jdbc.jarDirection=/Users/ceyx/.gradle/caches/modules-2/files-2.1/mysql/mysql-connector-java/5.1.38/dbbd7cd309ce167ec8367de4e41c63c2c8593cc5/mysql-connector-java-5.1.38.jarjdbc.driverClassName=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/halcyonjdbc.user=rootjdbc.pass=root 自行填写jdbc.jarDirection路径 build.gradle123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596group 'com.lhalcyon'version '1.0-SNAPSHOT'apply plugin: 'java'apply plugin: 'war'sourceCompatibility = 1.8repositories &#123; mavenCentral()&#125;configurations &#123; mybatisGenerator&#125;// 读取config文件夹中对应的配置文件ext&#123; def prop = new Properties(); file("src/main/resources/config/mybatis/jdbc-mysql.properties") .withInputStream &#123; prop.load(it) &#125; file("src/main/resources/config/mybatis/gradle.properties") .withInputStream &#123; prop.load(it) &#125; prop.each &#123; project.extensions.add("$it.key",it.value); &#125;&#125;dependencies &#123; testCompile group: 'junit', name: 'junit', version: '4.12' compile 'org.codehaus.groovy:groovy-all:2.3.11' compile 'jstl:jstl:1.2' compile 'org.springframework:spring-aop:4.2.4.RELEASE' compile 'org.springframework:spring-context:4.2.4.RELEASE' compile 'org.springframework:spring-beans:4.2.4.RELEASE' compile 'org.springframework:spring-web:4.2.4.RELEASE' compile 'org.springframework:spring-webmvc:4.2.4.RELEASE' compile 'org.springframework:spring-tx:4.2.4.RELEASE' compile 'org.springframework:spring-jdbc:4.2.4.RELEASE' compile 'org.springframework:spring-test:4.2.4.RELEASE' compile 'mysql:mysql-connector-java:5.1.38' compile 'org.mybatis.generator:mybatis-generator-core:1.3.2' compile 'org.mybatis:mybatis-spring:1.2.3' compile 'org.mybatis:mybatis:3.3.0' compile 'junit:junit:4.12' compile group: 'commons-dbcp', name: 'commons-dbcp', version: '1.4' compile group: 'org.aspectj', name: 'aspectjweaver', version: '1.8.13' compile group: 'log4j', name: 'log4j', version: '1.2.17' mybatisGenerator 'org.mybatis.generator:mybatis-generator-core:1.3.2' mybatisGenerator 'mysql:mysql-connector-java:5.1.38'&#125;// 利用ant创建一个自动生成MyBatis目录文件的tasktask mybatisGenerate &lt;&lt; &#123; ant.properties['targetProject'] = projectDir.path ant.properties['jarDirection'] = project['jdbc.jarDirection'] ant.properties['driverClass'] = project['jdbc.driverClassName'] ant.properties['connectionURL'] = project['jdbc.url'] ant.properties['userId'] = project['jdbc.user'] ant.properties['password'] = project['jdbc.pass'] ant.properties['src_main_java'] = sourceSets.main.java.srcDirs[0].path ant.properties['src_main_resources'] = sourceSets.main.resources.srcDirs[0].path ant.properties['modelPackage'] = project['modelPackage'] ant.properties['mapperPackage'] = project['mapperPackage'] ant.properties['sqlMapperPackage'] = project['sqlMapperPackage'] ant.taskdef( name: 'mbgenerator', classname: 'org.mybatis.generator.ant.GeneratorAntTask', classpath: configurations.mybatisGenerator.asPath ) ant.mbgenerator(overwrite: true, configfile: 'src/main/resources/config/mybatis/generatorConfig.xml', verbose: true) &#123; propertyset &#123; propertyref(name: 'targetProject') propertyref(name: 'jarDirection') propertyref(name: 'userId') propertyref(name: 'driverClass') propertyref(name: 'connectionURL') propertyref(name: 'password') propertyref(name: 'src_main_java') propertyref(name: 'src_main_resources') propertyref(name: 'modelPackage') propertyref(name: 'mapperPackage') propertyref(name: 'sqlMapperPackage') &#125; &#125;&#125; 接着Sync或者点击Import Changes IDEA就会下载依赖包了.依赖版本号均源于Maven Repository spring-mvc.xml 导入依赖后,则可直接创建spring相关xml 123456789101112131415161718192021222324&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; &lt;!-- 自动扫描控制器 --&gt; &lt;context:component-scan base-package="com.lhalcyon.webhook.controller"/&gt; &lt;!-- 视图渲染 --&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/views/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt; &lt;!-- 控制器映射器和控制器适配器 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 静态资源映射器 --&gt; &lt;mvc:resources mapping="/statics/**" location="/WEB-INF/statics/" /&gt;&lt;/beans&gt; applicationContext-dao.xml123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd"&gt; &lt;!-- 加载配置文件 --&gt; &lt;context:property-placeholder location="classpath:config/mybatis/jdbc-mysql.properties" /&gt; &lt;!-- 数据库连接池 --&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driverClassName&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.user&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.pass&#125;" /&gt; &lt;property name="maxActive" value="10" /&gt; &lt;property name="maxIdle" value="5" /&gt; &lt;/bean&gt; &lt;!-- mapper配置 --&gt; &lt;!-- 让spring管理sqlsessionfactory 使用mybatis和spring整合包中的 --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- 自动扫描mapping.xml文件 --&gt; &lt;!--&lt;property name="mapperLocations" value="classpath*:com/lhalcyon/mapper/*.xml"/&gt;--&gt; &lt;/bean&gt; &lt;!-- 配置Mapper扫描器 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.lhalcyon.webhook.mapper"/&gt; &lt;/bean&gt;&lt;/beans&gt; applicationContext-service.xml1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd"&gt; &lt;!-- 配置包扫描器 --&gt; &lt;context:component-scan base-package="com.lhalcyon.webhook.service"/&gt;&lt;/beans&gt; applicationContext-trans.xml1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd"&gt; &lt;!-- 事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;!-- 数据源 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;!-- 通知 --&gt; &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;!-- 传播行为 --&gt; &lt;tx:method name="insert*" propagation="REQUIRED" /&gt; &lt;tx:method name="delete*" propagation="REQUIRED" /&gt; &lt;tx:method name="update*" propagation="REQUIRED" /&gt; &lt;tx:method name="query*" propagation="SUPPORTS" read-only="true" /&gt; &lt;tx:method name="get*" propagation="SUPPORTS" read-only="true" /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 切面 --&gt; &lt;aop:config&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut="execution(* com.lhalcyon.webhook.service.*.*(..))" /&gt; &lt;/aop:config&gt;&lt;/beans&gt; web.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" version="3.0"&gt; &lt;!-- 初始化spring 容器 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:config/spring/applicationContext-*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 配置前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;index-dispather&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath*:config/spring/spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;index-dispather&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 解决post乱码问题 --&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; Tomcat部署Run-&gt;Edit Configurations 有fix项点击配置即可,然后运行. MyBatis配置数据库管理工具笔者使用的是 首先创建数据库halcyon,接着创建book表,用于后面的mybatis generator 12345CREATE TABLE book ( book_id INT PRIMARY KEY AUTO_INCREMENT, book_name VARCHAR(30) NOT NULL, author VARCHAR(20) default '佚名') 然后在gradle创建mybatis generator task 运行task 运行成功后,会生成与数据库表对应的java bean与dao文件,即项目里的Book.java、BookExample.java、BookMapper.xml、BookMapper.java generatorConfig.xml配置参数可自行搜索补充修改🤔.手动覆写下Book的toString方法方便日志输出 测试为了满足同时测试Spring、SpringMVC、Mybatis,笔者建立一个Controller通过Get请求进行CURD操作. Service1234567891011121314151617181920212223242526272829@Servicepublic class BookServiceImpl implements BookService &#123; @Autowired private BookMapper bookMapper; @Override public void insertBook(Book book) &#123; bookMapper.insert(book); &#125; @Override public void updateBook(Book book) &#123; bookMapper.updateByPrimaryKey(book); &#125; @Override public List&lt;Book&gt; getAllBooks() &#123; BookExample example = new BookExample(); return bookMapper.selectByExample(example); &#125; @Override public void deleteBookById(int bookId) &#123; BookExample example = new BookExample(); example.createCriteria().andBookIdEqualTo(bookId); bookMapper.deleteByExample(example); &#125;&#125; Controller1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@RestControllerpublic class BookController &#123; private static final Logger logger = Logger.getLogger(BookController.class); @Autowired private BookService bookService; @RequestMapping(value = "/insert",method = RequestMethod.GET) public String insert(String bookName,String author)&#123; Book book = new Book(); book.setBookName(bookName); book.setAuthor(author); bookService.insertBook(book); return queryStrings(); &#125; @RequestMapping("/update") public String updateAuthor(int bookId,String bookName,String author)&#123; Book book = new Book(); book.setBookId(bookId); book.setBookName(bookName); book.setAuthor(author); bookService.updateBook(book); return queryStrings(); &#125; @RequestMapping("/delete") public String deleteBook(int bookId)&#123; bookService.deleteBookById(bookId); return queryStrings(); &#125; @RequestMapping("/find_all") public String getAllBooks()&#123; List&lt;Book&gt; books = bookService.getAllBooks(); logger.info(books); return books.toString(); &#125; private String queryStrings()&#123; List&lt;Book&gt; allBooks = bookService.getAllBooks(); return allBooks.toString(); &#125;&#125; 直接通过请求地址,获得结果 插入: 1http://localhost:8080/webhook/insert?bookName=java&amp;author=jack 执行后直接将数据库中所有book记录输出,方便观察. 其它操作类似 更新: 1http://localhost:8080/webhook/update?bookId=3&amp;bookName=go&amp;author=joe 删除: 1http://localhost:8080/webhook/delete?bookId=4 查询(所有): 1http://localhost:8080/webhook/find_all 如若发生500 Invalid bound statement (not found)类似错误,一般是没有扫描到Mapper.xml.其中一种情况下是xml根本没被打包进war.需要在build.gradle中进行配置,并且配置后Sync或Import Changes,再重新用命令./gradlew build才可生效. 123456//将src文件夹中的资源文件同时打包processResources &#123; from(&apos;src/main/java&apos;) &#123; include &apos;**/*.xml&apos; &#125;&#125; 至此SpringMVC+MyBatis+Gradle项目已经构建测试完毕. 代码已上传GayHub,文章若对各位大佬有帮助,麻烦顺手点个star~ ❤️ 各位可能发现了,SSM配置起来比较繁琐,相比之下,SpringBoot就精简了许多.后面有机会,我们再来细说 🤒 参考: https://www.cnblogs.com/bojuetech/p/5844413.html 参考: http://blog.csdn.net/kingboyworld/article/details/78251425]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IntelliJ</tag>
        <tag>Spring</tag>
        <tag>SpringMVC</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio版本兼容Api警告]]></title>
    <url>%2Fas_warning%2F</url>
    <content type="text"><![CDATA[Android Studio版本兼容Api警告最近在开发中,组内的小伙伴在开发中使用了高版本SDK25的Api,但是我们的项目最低兼容14,因此测试在5.1上的手机直接就崩溃了,问其在开发中没有看到警告吗,回复说确实没看到.后来查究一下,他的工具上确实没有显示.本文简述下如何手动去调整兼容Api的提示等级,避免在开发中用到高版本的Api却不自察. 首先win电脑是打开Android Studio的 Setting ,mac是打开Android Studio的 Preferences 选择Editor中的Inspections 对Calling new methods on older versions进行勾选并且配置为Error级别 如此简单即可搞定.如遇到其他警告,错误代码没提示也可类似进行操作配置.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode代码提示问题处理]]></title>
    <url>%2Fxcode-idiot%2F</url>
    <content type="text"><![CDATA[最近在写Swift.对于笔者这种被JetBrains的几大IDE工具给惯坏的开发者,Xcode的代码提示真是无力吐槽,先不论智能提示度,就连基本的提示也经常出不来.这里就简单总结下iOS同事传授的几招解决办法 1.Clean Project最直接的办法就是清空项目. 可视化按钮入口再哪请自行查找,笔者一般是用Command+Shift+K进行清空,此方法一般有效,缺点是会重新编译项目,比较慢 2.清空Xcode缓存前往Xcode的缓存目录,清空项目编译缓存. 具体操作为右键Finder前往文件夹文件夹路径为/用户/ceyx/资源库/Developer/Xcode/DerivedData 其中ceyx 替换为自己的用户名,删除目录下所有文件,然后重新打开Xcode,编译. 此方法比1更慢,往往也更有效 3.终极大招如若上述两种方法还无效,只能使用绝招了…重启Xcode,还不行就重启电脑… 笔者黔驴技穷了,只能充当下网吧老板传授下终极大招.👻 题外话,对于JetBrains出品的appcode还未尝试过,不知对于Xcode项目兼容到何程度,是否支持Cocoapod等,有时间会去体验下,希望至少在代码提示上能更友善些😀 笔者去体验了下Appcode,其代码提示和快捷键如Jetbrains其他产品一样非常智能,但是代码中偶有飘红,却可以成功运行,比较干扰编码.尤为尴尬的一点是,Appcode不支持storyboard,即在项目内点开storyboard文件就直接跳转xcode了😥. 如真的被Xcode逼疯的童鞋可以考虑下用AppCode编码,用Xcode操作storyboard]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux+Jenkins+Gradle构建Android参数化自动打包(二)]]></title>
    <url>%2Flinux-jenkins-gradle_build_android2%2F</url>
    <content type="text"><![CDATA[在前一篇文章中,说明了在CenterOS上进行一系列的环境搭建,本文开始说明关于项目的一系列配置 Jenkins项目配置首先创建一个项目,将构建保持的天数和个数进行限制 此处感谢后台同事提示,因为Android SDK NDK 就特别占空间了,如果构建缓存不进行限制,则很快服务器空间就会不足🤥 参数构建配置打包环境 分支指定 email自定义接收者 打包时间戳 因为笔者的公司对打包的Apk名以及测试版本号时间戳显示的要求,因此需要使用动态参数 还有其他参数均与以上类似,可自行配置 !!! 记住尤为重要的是这些参数都是Jenkins上配置的Gradle属性,得传递到App的Gradle中 这里勾选Pass all job parameters as Project properties 源码管理在源码管理处配置Git账号 这里的*/${BRANCH}对应参数配置时的BRANCH.为什么这里做成选择型参数呢,是因为分支名是未知的,做成填写的话,可能压根拉不到指定分支的代码🤐 Gradle构建脚本增加构建动作 这里${WORKSPACE}指的是Git拉下的根目录.途中马赛克位置则为项目根目录 蒲公英上传增加构建动作,将Apk上传蒲公英 1curl -k -F &quot;file=@$&#123;WORKSPACE&#125;/source/项目根目录/app/apks/$&#123;BUILD_PREFIX&#125;_$&#123;JENKINS_TIME&#125;_$&#123;DAY_VERSION&#125;.apk&quot; -F &quot;uKey=你的ukey&quot; -F &quot;_api_key=你的apiKey&quot; -F &quot;installType=2&quot; -F &quot;password=下载密码&quot; -F &quot;updateDescription=$&#123;DESCRIPTION&#125;&quot; https://www.pgyer.com/apiv1/app/upload ${WORKSPACE}/source/项目根目录/app/apks/为笔者自行修改的Apk输出目录,此处请根据自己的项目输入目录进行修改 curl命令如果使用不了可自行百度解决 以下为蒲公英的上传Api,可以自行调整参数 邮件通知首先还是进入Jenkins-&gt;系统设置 在Jenkins Location中进行配置 Jenkins URL:http://10.50.0.16:8777/jenkins/ 系统管理员邮件地址: Android参数化构建&lt;aaa@163.com&gt; 此处Android参数化构建就为邮件中的发送人名称 系统设置中的默认收件人最好不要配置为自己,因为如果配置后,自己就永远在收件人的前端,后面想发送给领导时,便不大好. 邮件的内容可自定义html内容,二维码直接线下生成蒲公英的地址然后贴在邮件内即可 App本地Gradle配置首先在gradle.properties文件中进行参数化构建在非Jenkins写入情况时的缺省值配置 在未使用Jenkins构建的情况下应用会读本地的这些变量值 然后在appmodule下的build.gradle中进行配置写入的值配置 12345678910111213141516171819202122232425262728293031323334//修改生成的apk名字及输出目录applicationVariants.all &#123; variant -&gt; variant.outputs.each &#123; output -&gt; def newName def oldFile = output.outputFile def outDirectory = oldFile.parent def buildPrefix def showVersion if (variant.buildType.name == &apos;debug&apos;) &#123; buildPrefix = BUILD_PREFIX &#125; else &#123; buildPrefix = BUILD_PREFIX_RELEASE &#125; def jenkinsTime = JENKINS_TIME if (variant.buildType.name == &apos;debug&apos;) &#123; showVersion = buildPrefix + &apos;_&apos; + jenkinsTime + &apos;_&apos; + DAY_VERSION &#125; else &#123; showVersion = APP_VERSION &#125; resValue(&quot;string&quot;, &apos;fund_app_version&apos;, showVersion) def tempFile = file(&quot;build.gradle&quot;) outDirectory = tempFile.parent + &apos;/apks&apos; if (IS_JENKINS) &#123; newName = buildPrefix + &apos;_&apos; + jenkinsTime + &apos;_&apos; + DAY_VERSION + &apos;.apk&apos; &#125; else &#123; newName = &apos;android-v&apos; + APP_VERSION + &apos;-&apos; + variant.productFlavors[0].name + &apos;-&apos; + variant.buildType.name + &apos;.apk&apos; &#125; output.outputFile = new File(outDirectory, newName) &#125;&#125; 系统默认的输入路径是在build文件夹中,层级比较深.此处笔者将apk的输出路径进行了修改并且对apk的输出名称进行了调整 至此,Jenkins参数自动化构建已经完成!😀]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Linux</tag>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux+Jenkins+Gradle构建Android参数化自动打包(一)]]></title>
    <url>%2Flinux-jenkins-gradle_build_android1%2F</url>
    <content type="text"><![CDATA[前言关于Jenkins部署安卓自动打包有很多好处,可以配置参数进行构建,选择打包环境、设置App版本、设置加密开关等.起初,笔者也是参考了一些网上的教程,将自动化打包构建在了自己的windows开发机器上,而将Jenkins自动构建Android部署在服务器上和本机上在环境构建方面略有不同,坑略多. 参数化构建的过程却是很便捷,但是部署在本机上自动化打包其实是个会增加打包时长的工作,因为自动化打包会首先去代码仓库拉取代码到本地,然后再开始打包,这个过程会比直接用AS打包慢很多.后来提出需求,要将自动化打包配置到服务器上.运维就提供了一台Linux服务器,并且上面已配置后台的自动化打包环境,用的是Jdk1.7和比较旧版本的Jenkins,于是我们得另行使用独立的安装的环境. 最终结果最终我们要实现的是实现Jenkins上面配置应用版本号、Git分支、应用渠道、请求基地址、应用环境等参数,进行一键参数化构建打包上传至蒲公英并发送邮件通知给自定义的接收者 最终实现参数化配置大致如下所示: 发送邮件(邮件内容较长,进行了相应缩小) 环境搭建所需环境 新版Jenkins(需能安装参数化构建插件) Tomcat 新版Jenkins Android SDK Android NDK aapt Git Gradle 其它(视自身项目所需) CenterOS64位已有环境 Jdk1.7 Tomcat 旧版Jenkins 1. Jdk安装及配置由于Android开发使用的 Jdk1.8,因此不能复用服务器上现有的Jdk 首先去Oracle Downloads下载 Jdk for Linux.笔者下载的是jdk-8u131-linux-x64.tar.gz 上传到服务器,进入相关目录解压 1tar -zxvf jdk-8u131-linux-x64.tar.gz 可将目录移至其他目录.其实最好在解压前就将压缩包移至目标目录 Jdk环境变量配置(可选) 由于后台使用了JAVA_HOME、JENKINS_HOME等一系列环境变量名,所以服务器上默认调用的会是他们的环境变量,我们开发的一套只能在自己的Tomcat、Jenkins中进行指定,具体下文会进行说明 2. Tomcat安装及配置首先去Tomcat Download选择版本进行下载.这里笔者选择的是apache-tomcat-7.0.79.tar.gz 上传到服务器,进入相关目录解压 1tar -zxv -f apache-tomcat-7.0.79.tar.gz a.端口修改由于常规tomcat端口被已有tomcat占用,因此我们需要修改端口 进入conf目录下的server.xml修改,此处笔者是用Vim修改.不会用的同学请出门左转度娘🤔 主要修改的是,设置为自定义端口号 Tomcat admin port 即文件最上面的端口号 Http/1.1 port 连接访问的端口号 AJP/1.3 port b.环境配置指定Tomcat运行时环境,在bin目录下修改setclasspath.sh 以下是笔者的环境,请自行替换路径 123export JAVA_HOME=/usr/android/java/jdk1.8.0_131export JRE_HOME=/usr/android/java/jdk1.8.0_131/jreexport JENKINS_HOME=/home/android/jenkins 3. Gradle安装及配置首先去Gradle Download下载对应Gradle版本,笔者使用到的是gradle-3.3-all.zip 上传到指定目录解压 1unzip gradle-3.3-all.zip 然后添加环境变量vim /etc/profile,在环境变量配置处增加一句 1export GRADLE_HOME=/home/gradle-3.3/bin 4. Android Sdk For Linux 安装及更新这里下载Sdk解压都不是难点.难点在于安装之后更新的问题. 用AS或者Eclipse的同学肯定接触过Sdk Manager,此处选择更新后要手动点Accept License才能启动更新.但是在Linux下没有界面化的勾选可用.因此需要用脚本来更新.网上有说复制License的方法笔者试了无效,也许是姿势不对吧,此处也是踩了很久的坑才搜出来的解决方法: 更新Sdk方法传送门 这里先感谢下该作者👏 这里也为不愿跳传送门的同学说明一下,就几个步骤. a.查看可更新列表 在Sdk的tools目录使用./android list sdk --all查看远程服务器提供的Sdk包的序号,记录想要更新的Sdk序号 b.编辑脚本 1234567#!/usr/bin/expectset timeout -1spawn /usr/local/android-sdk-linux/tools/android update sdk -u -a -t 1,2,3,24,25,26,27,28,30,95,96,102,103,104,105,106,107expect &#123; &quot;Do you accept the license&quot; &#123; exp_send &quot;y\r&quot; ; exp_continue &#125; eof&#125; 此处1,2,3,...为需要下载的Sdk序号 c.运行脚本 待脚本跑完,sdk就更新完毕了 注意此处脚本用到了expect,需要在服务器上安装,此处提供expect安装传送门 5. Ndk for Linux安装安装较简单,后续需配置Jenkins系统变量,下文会进行说明 项目因用到了Jni,需要安装Ndk,可是后期发现在项目里每次均去编译jni导致项目的compile sdk不能使用高于23的,致使Instant Run等功能使用,很影响开发效率.后期改在项目外编译好了静态库然后放入项目中,这样不会限制项目自身的SDK版本,因此若未使用JNI的项目,则可跳过此步骤 6. Git安装及环境变量配置下载安装并配置环境变量 1export GIT_HOME=/usr/android/git-2.12.2/bin 7. Jenkins安装及配置a. 下载下载Jenkins将war包放入Tomcat的webapps目录下,启动tomcat 然后在地址栏输入路径http://localhost:/8777 其中8777为第二步中自定义的端口号 b. 插件安装然后安装插件(基本参考网上的) 12345678910111213141516171819202122231.Branch API Plugin2.build timeout plugin3.build-name-setter4.Credentials Binding Plugin5.description setter plugin6.Dynamic Parameter Plug-in7.Environment Injector Plugin9.Git plugin10.GIT server Plugin11.Gradle Plugin12.Git Parameter Plug-In13.Pipeline: Basic Steps14.Pipeline: Build Step15.Pipeline: Input Step16.Pipeline: Nodes and Processes17.Pipeline: Stage Step18.Scriptler19.Workspace Cleanup Plugin20.Post-Build Script Plug-in21.Email Extension Plugin22.SSH Slaves plugin23.Timestamper(不明为什么少8) 因为Jenkins版本不同,实际使用中发现缺失不少 以下附上笔者所安装的所有插件(若无问题的可跳过) c. 环境变量配置环境变量 首先点击系统管理-&gt;系统设置配置Jdk、Android Sdk、Gradle、Android Ndk环境变量(此处也可配置Git目录,笔者是将Git目录配置在Linux环境变量中了) 其它如邮件相关配置的在下篇会说明 至此环境大体上配置已经完成,下篇即可进入项目相关配置]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Linux</tag>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[混编:Swift调用Objective-C]]></title>
    <url>%2Fhybrid-compile_swift2oc%2F</url>
    <content type="text"><![CDATA[环境 Xcode 8.3.3 Swift3.+ 步骤1.创建混编桥接头文件 名称随便取,最好能和普通header文件做区别 2.项目配置桥接文件 点击工程,选中Build Settings,子选项勾选All 在下面配置中找到(或者搜索)Swift Compile - General 配置混编桥接头文件 点开图中红圈区域进行配置,如我所建的文件在工程里路径为MyProject/Hybrid-Compile.h 则配置也应是这个路径 保存后在该头文件中引用相应OC类头文件即可在Swift中调用 引用注意如果是项目内的OC文件直接引用即可 如果是Pod引用的库中的OC文件则需要带上其Pod中的路径]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Xcode</tag>
      </tags>
  </entry>
</search>
